<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Hypervisor From Scratch ‚Äì Part 7: Using EPT &amp; Page-Level Monitoring Features" /><meta name="author" content="Sina Karvandi" /><meta property="og:locale" content="en" /><meta name="description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><meta property="og:description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><link rel="canonical" href="https://rayanfam.com/topics/hypervisor-from-scratch-part-7/" /><meta property="og:url" content="https://rayanfam.com/topics/hypervisor-from-scratch-part-7/" /><meta property="og:site_name" content="Rayanfam Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-01-20T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Hypervisor From Scratch ‚Äì Part 7: Using EPT &amp; Page-Level Monitoring Features" /><meta name="twitter:site" content="@Intel80x86" /><meta name="twitter:creator" content="@Sina Karvandi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sina Karvandi"},"dateModified":"2024-07-13T13:14:26+00:00","datePublished":"2020-01-20T00:00:00+00:00","description":"We write about Windows Internals, Hypervisors, Linux, and Networks.","headline":"Hypervisor From Scratch ‚Äì Part 7: Using EPT &amp; Page-Level Monitoring Features","mainEntityOfPage":{"@type":"WebPage","@id":"https://rayanfam.com/topics/hypervisor-from-scratch-part-7/"},"url":"https://rayanfam.com/topics/hypervisor-from-scratch-part-7/"}</script><title>Hypervisor From Scratch ‚Äì Part 7: Using EPT & Page-Level Monitoring Features | Rayanfam Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Rayanfam Blog"><meta name="application-name" content="Rayanfam Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/images/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Rayanfam Blog</a></div><div class="site-subtitle font-italic">An aggressive out-of-order, superscalar blog...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tutorials/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TUTORIALS</span> </a><li class="nav-item"> <a href="/tools/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TOOLS & SCRIPTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/rayanfam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Intel80x86" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sina','rayanfam.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Hypervisor From Scratch ‚Äì Part 7: Using EPT & Page-Level Monitoring Features</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Hypervisor From Scratch ‚Äì Part 7: Using EPT & Page-Level Monitoring Features</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Intel80x86">Sina Karvandi</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1579478400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-01-20 </em> </span> <span> Updated <em class="timeago" data-ts="1720876466" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-07-13 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="15303 words"> <em>85 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="../../assets/images/hypervisor-from-scratch-7-cover.png" alt="" data-proofer-ignore></p><p><strong>If you‚Äôre looking to use a hypervisor for analysis and reverse engineering tasks, check out <a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> Debugger. It‚Äôs a hypervisor-based debugger designed specifically for analyzing, fuzzing, and reversing applications. A free and comprehensive tutorial on hypervisor-based reverse engineering is available at <a href="https://ost2.fyi/dbg3301">OpenSecurityTraining2‚Äôs website</a> (<em>preferred</em>) and <a href="https://www.youtube.com/playlist?list=PLUFkSN0XLZ-kF1f143wlw8ujlH2A45nZY">YouTube</a>, which demonstrates numerous practical examples on how to utilize hypervisors for reverse engineering.</strong></p><h2 id="introduction"><span class="mr-2"><strong>Introduction</strong></span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>This is the 7th part of the tutorial Hypervisor From Scratch, and it‚Äôs about using the <strong>E</strong>xtended <strong>P</strong>age <strong>T</strong>able (<strong>EPT</strong>) in an already running system. As you might know, paging is an essential part of managing memory on modern operating systems. Hypervisors use an additional paging table; this gives us an excellent opportunity to monitor different aspects of memory (<strong>R</strong>ead-<strong>W</strong>rite-<strong>E</strong>xecute) without modifying the operating systems page-tables. EPT is a hardware mechanism, so it‚Äôs fast, but on the other hand, we have to deal with different caching and synchronization problems.</p><p>This part is highly dependent on the 4th part of the tutorial - <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-4/">Part 4: Address Translation Using Extended Page Table (EPT)</a>, so please read this part one more time; thus, I avoid redescribing about the basic concept relating to EPT Tables.</p><p>In the 7th part, we‚Äôll see how we can virtualize our currently running system by configuring VMCS and creating identity tables based on <a href="https://en.wikipedia.org/wiki/Memory_type_range_register"><strong>M</strong>emory <strong>T</strong>ype <strong>R</strong>ange <strong>R</strong>egister (<strong>MTRR</strong>)</a> then we use monitoring features to detect the execution of some of the Windows functions.</p><p>This part is highly inspired by <a href="https://github.com/ionescu007/SimpleVisor">Simplevisor</a> and <a href="https://github.com/Gbps/gbhv">Gbhv</a>.</p><p>The picture of this post was taken by one of my best friends <a href="https://500px.com/amdghazi">Ahmad</a>, from <a href="https://en.wikipedia.org/wiki/Khanabad,_Aligudarz">KhƒÅnƒÅbƒÅd Village, Aligudarz</a>.</p><p>Before starting, I should give special thanks to my friend <a href="https://twitter.com/PetrBenes">Petr Benes</a> for his contributions to Hypervisor From Scratch, of course, Hypervisor From Scratch could never exist without his help. I also give my regards to <a href="https://twitter.com/aionescu">Alex Ionescu</a> as he always answers my question patiently.</p><h2 id="overview"><span class="mr-2"><strong>Overview</strong></span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>This part is divided into <strong>seven</strong> main sections :</p><ol><li>Implementing mechanisms to manage Vmcalls<li>Starting with MMU Virtualization (EPT)<li>Explaining Memory Type Range Register (MTRR) concepts<li>Describing Page-Level Monitoring features using EPT<li>Invalidating Translations Derived from EPT (INVEPT)<li>Fixing some previous design caveat regarding deadlocks and synchronization problems<li>Discussion (In this section we discuss the different question(s) and approaches about EPT)</ol><p>At last, I talk about some important notes you need to know in order to debug hypervisor and EPT.</p><p>Guys, it‚Äôs ok if you didn‚Äôt understand some of the parts, by reading this article, you‚Äôll get an idea, you could use EPT and over the time you‚Äôll understand things better.</p><p>The source code of this part changed drastically compared to the previous part; naming conventions are improved, so you see a much cleaner and readable code; also lots of new routines added to the code, for examples routines starting with <strong>Hv</strong> are hypervisor routines, you have to call them from IRP Major functions and avoid calling methods with <strong>Vmx</strong> prefix directly as these functions manage the operations relating to VMX Operations, functions with <strong>Asm</strong> prefix are inline-assembly functions and functions starting with <strong>Ept</strong> are those that relate to Extended Page Table (EPT). Also, functions with <strong>Vmcall</strong> prefix are for VMCALL services, and functions with <strong>Invept</strong> are related to Invalidate EPT caches.</p><p>The full source code of this tutorial is available on GitHub :</p><p>[<a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch">https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a>]</p><p>Note: Remember that hypervisors change over time because new features are added to the operating systems or new technologies are used. For example, updates to Meltdown &amp; Spectre have made a lot of changes to the hypervisors. So, if you want to use Hypervisor From Scratch in your projects, research, or whatever, you should use the <a href="https://github.com/HyperDbg/HyperDbg"><strong>HyperDbg</strong></a> drivers. <strong>HyperDbg</strong> is actively maintained, stable, and reliable, ensuring you avoid the errors and instability problems that can arise from using older parts of the tutorial series.</p><h1 id="table-of-contents"><strong>Table of Contents</strong></h1><ul><li><strong>Introduction</strong><li><strong>Overview</strong><li><strong>Table of Contents</strong><li><strong>Implementing Functions to Manage Vmcalls</strong><li><strong>Starting with MMU virtualization (EPT)</strong><li><strong>Memory Type Range Register (MTRR)</strong><ul><li>Building MTRR Map<li>Fixed-Range MTRRs and PAT</ul><li><p><strong>Virtualizing Current System‚Äôs Memory using EPT</strong></p><ul><li>EPT Identity Mapping<li>Setting up PML4 and PML3 entries<li><p>Setting up PML2 entries</p><li>EPT Violation<li>EPT Misconfiguration<li>Adding EPT to VMCS</ul><li><p><strong>Monitoring Page‚Äôs RWX Activity</strong></p><ul><li>Pre-allocating Buffers for VMX Root Mode<li>Setting hook before Vmlaunch<li>Setting hook after Vmlaunch<li>Finding a Page‚Äôs entry in EPT Tables<ol><li>Finding PML4, PML3, PML2 entries<li>Finding PML1 entry</ol><li>Splitting 2 MB Pages to 4 KB Pages<li><p>Applying the Hook</p><li>Handling hooked pages‚Äô vm-exits</ul><li><strong>Invalidating Translations Derived from EPT (INVEPT)</strong><ul><li>Invalidating All Contexts<li>Invalidating Single Context<li>Broadcasting Invept to all logical cores simultaneously</ul><li><strong>Fixing Previous Design Issues</strong><ul><li>Support to more than 64 logical cores<li>Synchronization problem in exiting VMX<li>The issues relating to the Meltdown mitigation</ul><li><strong>Some tips for debugging hypervisors</strong><li><strong>Let‚Äôs Test it!</strong><ul><li>How to test?<li>Demo</ul><li><strong>Discussion</strong><li><strong>Conclusion</strong><li><strong>References</strong></ul><p><img data-src="../../assets/images/anime-girl-aqua-blue.jpg" alt="Aniiiiime :)" data-proofer-ignore></p><h1 id="implementing-functions-to-manage-vmcalls"><strong>Implementing Functions to Manage Vmcalls</strong></h1><p>We start this article by implementing functions relating to VMCALL. Intel describes Vmcall by ‚ÄúCall to VM monitor by causing VM exit.‚Äù.</p><p>Vmcall allows guest software to call for service into an underlying VM monitor. The details of the programming interface for such calls are VMM-specific. This instruction does nothing more than cause a VM exit.</p><p>In other words, whenever you execute a <strong>Vmcall</strong> instruction in Vmx non-root mode (whenever a vm-exit occurs, we are in vmx root-mode, and we stay in vmx root mode until we execute <strong>VMRESUME</strong> or <strong>VMXOFF</strong> so any other contexts is vmx non-root mode means that other drivers can use <strong>Vmcall</strong> in their contexts to request a service from our hypervisor in vmx root mode).</p><p>Execution of <strong>VMCALL</strong> causes a Vm-exit (<strong>EXIT_REASON_VMCALL</strong>). As we can set registers and stack before execution of VMCALL so we can send parameters to the Vmcall handler, I mean all we need to do is designing a calling-convention so that both vmcall handler and driver which requests a service can work together perfectly.</p><p>The first thing we need to implement is a function in assembly, which executes <strong>VMCALL</strong> and returns.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">AsmVmxVmcall</span> <span class="n">PROC</span>
    <span class="n">vmcall</span>                  <span class="p">;</span> <span class="n">VmxVmcallHandler</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">VmcallNumber</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam1</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam2</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam3</span><span class="p">)</span>
    <span class="n">ret</span>                     <span class="p">;</span> <span class="n">Return</span> <span class="n">type</span> <span class="n">is</span> <span class="n">NTSTATUS</span> <span class="n">and</span> <span class="n">it</span><span class="err">'</span><span class="n">s</span> <span class="n">on</span> <span class="n">RAX</span> <span class="n">from</span> <span class="n">the</span> <span class="n">previous</span> <span class="n">function</span><span class="p">,</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">change</span> <span class="n">anything</span>
<span class="n">AsmVmxVmcall</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>It defines like this,</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="kr">inline</span> <span class="nf">AsmVmxVmcall</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">VmcallNumber</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">OptionalParam1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">OptionalParam2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">OptionalParam3</span><span class="p">);</span>
</pre></table></code></div></div><p>What distinguished from the above code is that we‚Äôre not modifying anything in <strong>AsmVmxVmcall</strong>, means that if someone passes the parameters to the <strong>AsmVmxVmcall</strong>, then the parameters are in RCX, RDX, R8, R9 and rest of them into the stack, that‚Äôs because of x64 FAST CALL calling convention.</p><p>Keep in mind that if you‚Äôre designing hypervisor for Linux, fast call in Linux is different from the fast-call in Windows.</p><p>As we saved all the registers on vm-exit so in vm-exit handler we pass the <strong>GuestRegs-&gt;rcx</strong>, <strong>GuestRegs-&gt;rdx</strong>, <strong>GuestRegs-&gt;r8</strong>, <strong>GuestRegs-&gt;r9</strong> to the <strong>VmxVmcallHandler</strong>, the <strong>RCX</strong> is the <strong>Vmcall Number</strong> which specifies the service we want our hypervisor to perform and <strong>RDX</strong> and <strong>R8</strong> and <strong>R9</strong> are optional parameters.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">EXIT_REASON_VMCALL</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">VmxVmcallHandler</span><span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>For example, we have the following services (<strong>Vmcall Numbers</strong>) for our hypervisor in this part.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>
<span class="cp">#define VMCALL_TEST						0x1			// Test VMCALL
#define VMCALL_VMXOFF					0x2			// Call VMXOFF to turn off the hypervisor
#define VMCALL_EXEC_HOOK_PAGE			0x3			// VMCALL to Hook ExecuteAccess bit of the EPT Table
#define VMCALL_INVEPT_ALL_CONTEXT		0x4			// VMCALL to invalidate EPT (All Contexts)
#define VMCALL_INVEPT_SINGLE_CONTEXT	0x5			// VMCALL to invalidate EPT (A Single Context)
</span></pre></table></code></div></div><p>There is nothing special for <strong>VmxVmcallHandler</strong>, it‚Äôs just a simple switch case.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cm">/* Main Vmcall Handler */</span>
<span class="n">NTSTATUS</span> <span class="nf">VmxVmcallHandler</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">VmcallNumber</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam1</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam2</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NTSTATUS</span> <span class="n">VmcallStatus</span><span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">HookResult</span><span class="p">;</span>

	<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">VmcallNumber</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">VMCALL_TEST</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">VmcallTest</span><span class="p">(</span><span class="n">OptionalParam1</span><span class="p">,</span> <span class="n">OptionalParam2</span><span class="p">,</span> <span class="n">OptionalParam3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
	<span class="p">{</span>
		<span class="n">LogWarning</span><span class="p">(</span><span class="s">"Unsupported VMCALL"</span><span class="p">);</span>
		<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">VmcallStatus</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>For testing it, I created a function called <strong>VmcallTest</strong>, it simply shows the parameters passed to Vmcall.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/* Test Vmcall (VMCALL_TEST) */</span>
<span class="n">NTSTATUS</span> <span class="nf">VmcallTest</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">Param1</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">Param2</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">Param3</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"VmcallTest called with @Param1 = 0x%llx , @Param2 = 0x%llx , @Param3 = 0x%llx"</span><span class="p">,</span> <span class="n">Param1</span><span class="p">,</span> <span class="n">Param2</span><span class="p">,</span> <span class="n">Param3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Finally, we can use the following piece of code and pass <strong>VMCALL_TEST</strong> as the <strong>Vmcall Number</strong> along with other optional parameters.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//  Check if everything is ok then return true otherwise false</span>
<span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_TEST</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x333</span><span class="p">,</span> <span class="mh">0x4444</span><span class="p">);</span>
</pre></table></code></div></div><p>Don‚Äôt forget that the above code should bee only executed in vmx non-root mode.</p><p>There is nothing more I can say about VMCALL, but for further reading (not related to our hypervisor), if you want to know what happens if you execute VMCALL in vmx root-mode, it invokes an SMM monitor. This invocation will activate the dual-monitor treatment of system-management interrupts (SMIs) and system-management mode (SMM) if it is not already active. In other words, executing Vmcall in vmx root mode causes an <strong>SMM VM exit</strong>!</p><p>Read Section 34.15.2 and Section 34.15.6 in Intel SDM for more information.</p><h1 id="starting-with-mmu-virtualization-ept"><strong>Starting with MMU virtualization (EPT)</strong></h1><p>Let me start with differences between physical and virtual address,</p><p>Physical addressing means that your program knows the real layout of RAM. When you access a variable at address 0x8746b3, that‚Äôs where it stored in the physical RAM chips.</p><p>With virtual addressing, all application memory accesses go to a page table, which then maps from the virtual to the physical address. So every application has its own ‚Äúprivate‚Äù address space, and no program can read or write to another program‚Äôs memory.¬†</p><p>EPT is a page table with a page-walk length of 4 (or in the newer versions 5). It translates guest-physical addresses to host-physical addresses.</p><p>First, you have to understand that EPT maps guest physical pages to host physical pages, mapping physical addresses make hypervisors much easier to understand because you can forget about all the concepts relating to virtual memory and operating system‚Äôs memory manager. Why? That‚Äôs because you cannot allocate more physical memory. Sure, you can hot-plug RAM right into the motherboard, but let‚Äôs forget about that for now üòâ , so the RAM usually starts at 0 and usually ends at AMOUNT OF RAM + SOME MORE, where SOME MORE is some MMIO/device space.</p><p>Look at the following picture (from <a href="https://github.com/wbenny/hvpp">hvpp</a>), Memory Ranges from VMWare VM with 2 GB of RAM.</p><p><img data-src="../../assets/images/memory-ranges.png" alt="Memory Ranges" data-proofer-ignore></p><p>Note the holes between ranges (e.g., A0000 - 100000); the ranges in the screenshot are backed by actual physical RAM, and the holes are the MMIO space.</p><p>By now, you know that if you allocate or free memory, the RAM ranges are always present and what changes are the content of data in the RAM.</p><p>Keep in mind, there are certainly no holes in the RAM as an electronic circuit, but it‚Äôs how BIOS maps certain physical memory ranges to the actual hardware RAM, in other words, RAM usually isn‚Äôt one contiguous address space, if you have 1 GB of RAM it‚Äôs often not one single piece of 0 ‚Ä¶ 1GB physical address space, but some parts of that space belongs to, e.g. network card, audio card, USB hub, etc.</p><p>Let‚Äôs see what hypervisors like VMWare, Hyper-V, VirtualBox do with physical memory. We don‚Äôt have the same approach, but it helps you understand MMU virtualization better.</p><p>In VMWare (Hyper-v, VirtualBox, etc), the VM has its own physical memory, and our PC (host) also has some physical address space. EPT exists so that you can translate the guest physical memory to host physical memory. For example, if a guest wants to read from Physical Address 0x1000, it looks into EPT, and EPT tells it that the content of the memory is on the host‚Äôs physical address 0x5000. You certainly do not want to let some guests in VMWare read physical memory on the host, so it‚Äôs VMWare‚Äôs job to setup EPTs correctly and have some chunk of physical memory dedicated to a guest.</p><h2 id="memory-type-range-register-mtrr"><span class="mr-2"><strong>Memory Type Range Register (MTRR)</strong></span><a href="#memory-type-range-register-mtrr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>By now, you have some idea about how memory (RAM) is divided into regions; these regions can be found using MTRR registers, that‚Äôs all!</p><p>Now let‚Äôs explain them more precisely.</p><p><a href="https://en.wikipedia.org/wiki/Memory_type_range_register">Wikipedia</a> defines MTRRs like this :</p><p>Memory type range registers (MTRRs) are a set of processor supplementary capabilities control registers that provide system software with control of how accesses to memory ranges by the CPU are cached. It uses a set of programmable model-specific registers (MSRs), which are special registers provided by most modern CPUs. Possible access modes to memory ranges can be uncached, write-through, write-combining, write-protect, and write-back. In write-back mode, writes are written to the CPU‚Äôs cache, and the cache is marked dirty so that its contents are written to memory later.</p><p><img data-src="../../assets/images/memory-types-in-MTRRs.png" alt="" data-proofer-ignore></p><p>In old x86 architecture systems, mainly where separate chips provided the cache outside of the CPU package, this function was controlled by the chipset itself and configured through BIOS settings, when the CPU cache was moved inside the CPU, the CPUs implemented fixed-range MTRRs.</p><p>Typically, the BIOS software configures the MTRRs. The operating system or executive is then free to modify the memory map using the typical page-level cacheability attributes.</p><p>If you confused by reading the above sentences, let me explain it more clearly. RAM is divided into different regions, We want to read the details (Base Address, End Address, and Cache Policy) of these chunks using MTRR Registers. Cache policy is something that BIOS or Operating System sets for a particular region. For example, the operating system decides to put UC (uncached) to a region that starts from 0x1000 to 0x2000 (Physical Address) of RAM then it chooses to put WB (Writeback) to a region starting from 0x5000 to 0x7000 (Physical Address), it‚Äôs based on OS policy. If you don‚Äôt know about the different memory type caches (e.g., UC, WB), you can read <a href="http://ethv.net/workshops/osdev/notes/notes-2">here</a>.</p><p>OK, let‚Äôs see how to read these MTRRs.</p><p>The availability of the MTRR feature is model-specific means that we can determine if MTRRs are supported on a processor by executing the CPUID instruction and reading the state of the MTRR flag (bit 12) in the feature information register (EDX). Still, This check is not essential as our process probably supports as it‚Äôs an old feature.</p><p>What is essential for us, is an MSR called ‚Äú<strong>IA32_MTRR_DEF_TYPE</strong>‚Äù. The following structure represents the <strong>IA32_MTRR_DEF_TYPE</strong> :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// MSR_IA32_MTRR_DEF_TYPE </span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">_IA32_MTRR_DEF_TYPE_REGISTER</span>
<span class="p">{</span>
	<span class="k">struct</span>
	<span class="p">{</span>
		<span class="cm">/**
		 * [Bits 2:0] Default Memory Type.
		 */</span>
		<span class="n">UINT64</span> <span class="n">DefaultMemoryType</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">UINT64</span> <span class="n">Reserved1</span> <span class="o">:</span> <span class="mi">7</span><span class="p">;</span>

		<span class="cm">/**
		 * [Bit 10] Fixed Range MTRR Enable.
		 */</span>
		<span class="n">UINT64</span> <span class="n">FixedRangeMtrrEnable</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/**
		 * [Bit 11] MTRR Enable.
		 */</span>
		<span class="n">UINT64</span> <span class="n">MtrrEnable</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">UINT64</span> <span class="n">Reserved2</span> <span class="o">:</span> <span class="mi">52</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">UINT64</span> <span class="n">Flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IA32_MTRR_DEF_TYPE_REGISTER</span><span class="p">,</span> <span class="o">*</span> <span class="n">PIA32_MTRR_DEF_TYPE_REGISTER</span><span class="p">;</span>
</pre></table></code></div></div><p>We implement a function called ‚Äú<strong>EptCheckFeatures,‚Äù</strong> this function checks to see whether our processor supports basic EPT features or not; for MTRRs, we‚Äôll check whether MTRRs are enabled or not. Having an enabled MTRR is necessary for our hypervisor. (we‚Äôll complete this function later when we‚Äôre describing EPT.)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="n">IA32_MTRR_DEF_TYPE_REGISTER</span> <span class="n">MTRRDefType</span><span class="p">;</span>

	<span class="n">MTRRDefType</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_MTRR_DEF_TYPE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MTRRDefType</span><span class="p">.</span><span class="n">MtrrEnable</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Mtrr Dynamic Ranges not supported"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><h2 id="building-mtrr-map"><span class="mr-2"><strong>Building MTRR Map</strong></span><a href="#building-mtrr-map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Before creating a map from memory regions, It‚Äôs good to see how Windbg shows the MTRR regions and their caching policies using the ‚Äú!mtrr‚Äù command.</p><p><img data-src="../../assets/images/MTRR-windbg.png" alt="!mtrr windbg" data-proofer-ignore></p><p>As you can see in the above picture, Windows prefers to use Fixed Range Registers (Fixed-support enabled) and variable range registers.</p><p>I‚Äôll talk about fixed range registers later in this article.</p><p>In order to read MTRRs, we start by reading the <strong>VCNT</strong> value of <strong>IA32_MTRRCAP</strong> MSR (0xFE), which determines the number of variable MTRRs (Number of regions).</p><p><img data-src="../../assets/images/IA32-MTRRCAP.png" alt="" data-proofer-ignore></p><p>The next step is to iterate through each MTRR variable; we read <strong>MSR_IA32_MTRR_PHYSBASE0</strong> and <strong>MSR_IA32_MTRR_PHYSMASK0</strong> for each range and check if the range is valid or not (based on <strong>IA32_MTRR_PHYSMASK_REGISTER.Valid</strong> bit).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>		<span class="n">CurrentPhysBase</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_MTRR_PHYSBASE0</span> <span class="o">+</span> <span class="p">(</span><span class="n">CurrentRegister</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">CurrentPhysMask</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_MTRR_PHYSMASK0</span> <span class="o">+</span> <span class="p">(</span><span class="n">CurrentRegister</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
</pre></table></code></div></div><p>Now we need to calculate the start address and the end address (physical) based on MSRs.</p><p>The start address:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>			<span class="c1">// Calculate the base address in bytes</span>
			<span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">=</span> <span class="n">CurrentPhysBase</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</pre></table></code></div></div><p>The end address:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>			<span class="c1">// Calculate the total size of the range</span>
			<span class="c1">// The lowest bit of the mask that is set to 1 specifies the size of the range</span>
			<span class="n">_BitScanForward64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NumberOfBitsInMask</span><span class="p">,</span> <span class="n">CurrentPhysMask</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

			<span class="c1">// Size of the range in bytes + Base Address</span>
			<span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalEndAddress</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">NumberOfBitsInMask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1ULL</span><span class="p">);</span>

</pre></table></code></div></div><p>For further information about the calculation of MTRRs, you can read Intel SDM Vol 3A (11.11.3 Example Base and Mask Calculations).</p><p>And finally, read the cache policy which is set by whether BIOS or operating system.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>			<span class="c1">// Memory Type (cacheability attributes)</span>
			<span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">MemoryType</span> <span class="o">=</span> <span class="p">(</span><span class="n">UCHAR</span><span class="p">)</span><span class="n">CurrentPhysBase</span><span class="p">.</span><span class="n">Type</span><span class="p">;</span>
</pre></table></code></div></div><p>Putting it all together, we have the following function :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre>
<span class="cm">/* Build MTRR Map of current physical addresses */</span>
<span class="n">BOOLEAN</span> <span class="nf">EptBuildMtrrMap</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">IA32_MTRR_CAPABILITIES_REGISTER</span> <span class="n">MTRRCap</span><span class="p">;</span>
	<span class="n">IA32_MTRR_PHYSBASE_REGISTER</span> <span class="n">CurrentPhysBase</span><span class="p">;</span>
	<span class="n">IA32_MTRR_PHYSMASK_REGISTER</span> <span class="n">CurrentPhysMask</span><span class="p">;</span>
	<span class="n">PMTRR_RANGE_DESCRIPTOR</span> <span class="n">Descriptor</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">CurrentRegister</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">NumberOfBitsInMask</span><span class="p">;</span>


	<span class="n">MTRRCap</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_MTRR_CAPABILITIES</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">CurrentRegister</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">CurrentRegister</span> <span class="o">&lt;</span> <span class="n">MTRRCap</span><span class="p">.</span><span class="n">VariableRangeCount</span><span class="p">;</span> <span class="n">CurrentRegister</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// For each dynamic register pair</span>
		<span class="n">CurrentPhysBase</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_MTRR_PHYSBASE0</span> <span class="o">+</span> <span class="p">(</span><span class="n">CurrentRegister</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">CurrentPhysMask</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_MTRR_PHYSMASK0</span> <span class="o">+</span> <span class="p">(</span><span class="n">CurrentRegister</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>

		<span class="c1">// Is the range enabled?</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CurrentPhysMask</span><span class="p">.</span><span class="n">Valid</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// We only need to read these once because the ISA dictates that MTRRs are to be synchronized between all processors</span>
			<span class="c1">// during BIOS initialization.</span>
			<span class="n">Descriptor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">MemoryRanges</span><span class="p">[</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">NumberOfEnabledMemoryRanges</span><span class="o">++</span><span class="p">];</span>

			<span class="c1">// Calculate the base address in bytes</span>
			<span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">=</span> <span class="n">CurrentPhysBase</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

			<span class="c1">// Calculate the total size of the range</span>
			<span class="c1">// The lowest bit of the mask that is set to 1 specifies the size of the range</span>
			<span class="n">_BitScanForward64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NumberOfBitsInMask</span><span class="p">,</span> <span class="n">CurrentPhysMask</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

			<span class="c1">// Size of the range in bytes + Base Address</span>
			<span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalEndAddress</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">NumberOfBitsInMask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1ULL</span><span class="p">);</span>

			<span class="c1">// Memory Type (cacheability attributes)</span>
			<span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">MemoryType</span> <span class="o">=</span> <span class="p">(</span><span class="n">UCHAR</span><span class="p">)</span><span class="n">CurrentPhysBase</span><span class="p">.</span><span class="n">Type</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">MemoryType</span> <span class="o">==</span> <span class="n">MEMORY_TYPE_WRITE_BACK</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* This is already our default, so no need to store this range.
				 * Simply 'free' the range we just wrote. */</span>
				<span class="n">EptState</span><span class="o">-&gt;</span><span class="n">NumberOfEnabledMemoryRanges</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">LogInfo</span><span class="p">(</span><span class="s">"MTRR Range: Base=0x%llx End=0x%llx Type=0x%x"</span><span class="p">,</span> <span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span><span class="p">,</span> <span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">PhysicalEndAddress</span><span class="p">,</span> <span class="n">Descriptor</span><span class="o">-&gt;</span><span class="n">MemoryType</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Total MTRR Ranges Committed: %d"</span><span class="p">,</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">NumberOfEnabledMemoryRanges</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="fixed-range-mtrrs-and-pat"><span class="mr-2"><strong>Fixed-Range MTRRs and PAT</strong></span><a href="#fixed-range-mtrrs-and-pat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The above section is enough for understanding the MTRRs for EPT. Still, I want to talk a little more about physical and virtual memory layout and caching policy (<strong><em>you can skip this section as it does not relate to our hypervisor</em></strong>).</p><p>There are other MTRR registers called <strong>Fixed Range Registers</strong> as its name implies, these registers are some predefined ranges defined by the processor (you can see them in the first lines of <strong>!mtrr</strong> command in Windbg).</p><p>These ranges are showed in the following table:</p><p><img data-src="../../assets/images/fixed-ranges-MTRRs.png" alt="" data-proofer-ignore></p><p>As you can see, the start of physical RAM is defined by these fixed range registers, which are for performance and legacy reasons.</p><p>Note that MTRRs should be defined contiguously; if your MTRRs are not contiguous, then the rest of the RAM is typically assumed as a hole.</p><p>Keep in mind that caching policy for each region of RAM is defined by MTRRs for PHYSICAL regions and <strong>PAGE ATTRIBUTE TABLE (PAT)</strong> for virtual areas so that each page can use its own caching policy by configuring <strong>IA32_PAT</strong> MSR. This means that sometimes the caching policy specified in MTRR registers is ignored, and instead, a page-level cache policy is used. There is a table in Intel SDM that shows the precedence rules between PAT and MTRRs (Table 11-7. Effective Page-Level Memory Types for Pentium III and More Recent Processor Families).</p><p>For further reading, you can read Intel SDM (Chapter 11 volume 3 A - 11.11 MEMORY TYPE RANGE REGISTERS (MTRRS) and 11.12 PAGE ATTRIBUTE TABLE (PAT)).</p><p><img data-src="../../assets/images/anime-girl-watching-city.jpg" alt="Anime :)" data-proofer-ignore></p><h2 id="virtualizing-current-systems-memory-using-ept"><span class="mr-2"><strong>Virtualizing Current System‚Äôs Memory using EPT</strong></span><a href="#virtualizing-current-systems-memory-using-ept" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>As you have some previous information from EPT (part 4), we create an EPT table for our VM. In the case of fully virtualizing memory of the current machine, there are different approaches in implementing EPT; we can either have a separate EPT table for each of the cores or an EPT table for all the cores, our approach is using one EPT for all the cores as it‚Äôs simpler to implement and manage (more details about the benefits and caveat are discussed in <strong>Discussion</strong> section).</p><p>What we are trying to do is creating an EPT table that maps all of the available physical memory (we have the details of physical memory from MTRRs) to the physical address. It‚Äôs something like adding a table that maps the previous addresses to the previous address with some additional fields to control them. It‚Äôs ok if you‚Äôre confused, just read the rest of the article and things become more clear.</p><h2 id="ept-identity-mapping"><span class="mr-2"><strong>EPT Identity Mapping</strong></span><a href="#ept-identity-mapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In our hypervisor or all of the hypervisors that virtualize an already running system (not VMWare, VirtualBox, etc), we have a term called ‚Äú<strong>Identity Mapping or 1:1 mapping</strong>‚Äù. It means that if you access guest PA (Physical Address) 0x4000, it will access host PA at 0x4000, thus, you have to map RAM‚Äôs hole as well as memory ranges to the guest.</p><p>It is the same as regular page tables (you can set page tables that way as well so that virtual address 0x1234 corresponds to the physical address 0x1234);</p><p>If you don‚Äôt map some physical memory and the guest access it, then you‚Äôll get ‚ÄúEPT Violation‚Äù, which can be understood as the hypervisor‚Äôs page fault.</p><p>In order to map everything one by one, we‚Äôll create PML4Es, then PDPTEs, then PDEs, and finally, PEs. In cases with 2 MB of granularity, we‚Äôll skip PEs. Of course, it‚Äôs preferred to have 4 KB granularity but keep in mind that 4GB of RAM results in one million of 4 KB pages thus having a 4 KB granularity will eat a lot of memory, besides this, setting 4 KB granularity will take quite some time which will drive you crazy if you test your hypervisor frequently.</p><p>What <a href="https://github.com/wbenny/hvpp">hvpp</a>, <a href="https://github.com/Gbps/gbhv">gbhv</a>, <a href="https://github.com/Gbps/gbhv"></a> and most of the other hypervisors do is initially set up 2 MB for the whole system (including RAM Ranges and MMIO holes) and then break some 2 MB pages into 4 KB pages as needed.</p><p>After splitting to 4 KB pages, you can merge them back to 2 MB pages again. We do the same for our hypervisor driver, first initial with 2 MB of granularity, then split them to 4 KB whenever needed.</p><p>Why we shouldn‚Äôt care about new memory allocations of Windows?</p><p>Well, that‚Äôs because we mapped all of the physical memory (every possible addresses in physical RAM) using 2 MB chunks, including those which are allocated and those which are not allocated yet, so no matter if Windows allocates a new memory chunk, we already have it in our EPT table.</p><p>What we want to do is creating a PML4E; then PDPTE, we‚Äôll add that PDPTE into PML4E, then create PDE and add it to the PDPTE and finally create PE, which will point to physical address 0. Then we create another PE, that will point to address 0x1000 (if the granularity is 4 KB) or 0x200000 ( if the granularity is 2 MB ) and add it again 512 times (maximum entries in all paging tables including EPT Page tables and regular page tables are 512) then we‚Äôll create another PDE and repeat!</p><p>All in all, our hypervisor should not care about any virtual address, it‚Äôs all about physical memory.</p><p>That‚Äôs enough for theory, let‚Äôs implement it!</p><h2 id="setting-up-pml4-and-pml3-entries"><span class="mr-2"><strong>Setting up PML4 and PML3 entries</strong></span><a href="#setting-up-pml4-and-pml3-entries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>First of all, we have to allocate a large memory for our EPT page table and then zero it.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>	<span class="n">PageTable</span> <span class="o">=</span> <span class="n">MmAllocateContiguousMemory</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_PAGE_TABLE</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MaxSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageTable</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to allocate memory for PageTable"</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Zero out all entries to ensure all unused entries are marked Not Present </span>
	<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">PageTable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_PAGE_TABLE</span><span class="p">));</span>
</pre></table></code></div></div><p>We have a linked list that holds the trace of every allocated memory; we have to initialize it first so we can de-allocate our allocated pages whenever we want to turn off our hypervisor.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Initialize the dynamic split list which holds all dynamic page splits </span>
	<span class="n">InitializeListHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">DynamicSplitList</span><span class="p">);</span>
</pre></table></code></div></div><p>It‚Äôs time to initialize the first table (EPT PML4). For the initialization phase, we set all the accesses to 1 (including Read Access, Write Access, Execute Access) on all of the EPT tables.</p><p>The physical address (Page Frame Number - PFN) for the PML4E is PML3‚Äôs address, and as it‚Äôs aligned and whenever the processor wants to translate it (it performs multiplication by <strong>PAGE_SIZE</strong>) so we divide it by <strong>PAGE_SIZE</strong> (4096).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	<span class="c1">// Mark the first 512GB PML4 entry as present, which allows us to manage up to 512GB of discrete paging structures. </span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><p>Each PML4 entry covers 512 GB of memory, so one entry is more than enough. Each table has 512 entries, so we have to fill PML3 with 512 of 1 GB entries. We‚Äôre done this by creating a template with RWX enabled and use <strong>__stosq</strong> to fill the table with this template continuously. <strong>__stosq</strong> generates a store string instruction (<strong>rep stosq</strong>) means that continuously (in our case <strong>VMM_EPT_PML3E_COUNT=512)</strong> copy something on a special location.</p><p>The next step is to convert our previously allocated PML2 entries to physical addresses and fill the PML3 with those addresses.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>	<span class="c1">// Set up one 'template' RWX PML3 entry and copy it into each of the 512 PML3 entries </span>
	<span class="c1">// Using the same method as SimpleVisor for copying each entry using intrinsics. </span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// Copy the template into each of the 512 PML3 entry slots </span>
	<span class="n">__stosq</span><span class="p">((</span><span class="n">SIZE_T</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">RWXTemplate</span><span class="p">.</span><span class="n">Flags</span><span class="p">,</span> <span class="n">VMM_EPT_PML3E_COUNT</span><span class="p">);</span>

	<span class="c1">// For each of the 512 PML3 entries </span>
	<span class="k">for</span> <span class="p">(</span><span class="n">EntryIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML3E_COUNT</span><span class="p">;</span> <span class="n">EntryIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Map the 1GB PML3 entry to 512 PML2 (2MB) entries to describe each large page.</span>
		<span class="c1">// NOTE: We do *not* manage any PML1 (4096 byte) entries and do not allocate them.</span>
		<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML3</span><span class="p">[</span><span class="n">EntryIndex</span><span class="p">].</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="n">EntryIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>For PML2, we have the same approach, fill it with an RWX template, but this time we set <strong>LargePage</strong> to 1 (for the reason I told you above about initialization with 2 MB granularity). Exactly same as above, we use <strong>__stosq</strong> to fill these entries, this time with 512*512 entries as we have 512 entries, each of which describes 512 entries.</p><p>The next step is to set up each entry‚Äôs PFN addresses. I‚Äôll describe EptSetupPML2Entry in the next section.</p><p>Note that we‚Äôre are filling entries for a 512*512 table, so we have to perform a multiplication by 512 for each <strong>EntryGroupIndex</strong> and then add it to the current PML2‚Äôs address (<strong>EntryIndex</strong>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>	<span class="c1">// All PML2 entries will be RWX and 'present' </span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// We are using 2MB large pages, so we must mark this 1 here. </span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">LargePage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* For each collection of 512 PML2 entries (512 collections * 512 entries per collection), mark it RWX using the same template above.
	   This marks the entries as "Present" regardless of if the actual system has memory at this region or not. We will cause a fault in our
	   EPT handler if the guest access a page outside a usable range, despite the EPT frame being present here.
	 */</span>
	<span class="n">__stosq</span><span class="p">((</span><span class="n">SIZE_T</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">Flags</span><span class="p">,</span> <span class="n">VMM_EPT_PML3E_COUNT</span> <span class="o">*</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">);</span>

	<span class="c1">// For each of the 512 collections of 512 2MB PML2 entries </span>
	<span class="k">for</span> <span class="p">(</span><span class="n">EntryGroupIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryGroupIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML3E_COUNT</span><span class="p">;</span> <span class="n">EntryGroupIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// For each 2MB PML2 entry in the collection </span>
		<span class="k">for</span> <span class="p">(</span><span class="n">EntryIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">;</span> <span class="n">EntryIndex</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Setup the memory type and frame number of the PML2 entry. </span>
			<span class="n">EptSetupPML2Entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="n">EntryGroupIndex</span><span class="p">][</span><span class="n">EntryIndex</span><span class="p">],</span> <span class="p">(</span><span class="n">EntryGroupIndex</span> <span class="o">*</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">)</span> <span class="o">+</span> <span class="n">EntryIndex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Putting it all together we have the following code:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre><td class="rouge-code"><pre><span class="cm">/* Allocates page maps and create identity page table */</span>
<span class="n">PVMM_EPT_PAGE_TABLE</span> <span class="nf">EptAllocateAndCreateIdentityPageTable</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PVMM_EPT_PAGE_TABLE</span> <span class="n">PageTable</span><span class="p">;</span>
	<span class="n">EPT_PML3_POINTER</span> <span class="n">RWXTemplate</span><span class="p">;</span>
	<span class="n">EPT_PML2_ENTRY</span> <span class="n">PML2EntryTemplate</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">EntryGroupIndex</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">EntryIndex</span><span class="p">;</span>

	<span class="c1">// Allocate all paging structures as 4KB aligned pages </span>
	<span class="n">PHYSICAL_ADDRESS</span> <span class="n">MaxSize</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">Output</span><span class="p">;</span>

	<span class="c1">// Allocate address anywhere in the OS's memory space</span>
	<span class="n">MaxSize</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="n">MAXULONG64</span><span class="p">;</span>

	<span class="n">PageTable</span> <span class="o">=</span> <span class="n">MmAllocateContiguousMemory</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_PAGE_TABLE</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MaxSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageTable</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to allocate memory for PageTable"</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Zero out all entries to ensure all unused entries are marked Not Present </span>
	<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">PageTable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_PAGE_TABLE</span><span class="p">));</span>

	<span class="c1">// Initialize the dynamic split list which holds all dynamic page splits </span>
	<span class="n">InitializeListHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">DynamicSplitList</span><span class="p">);</span>

	<span class="c1">// Mark the first 512GB PML4 entry as present, which allows us to manage up to 512GB of discrete paging structures. </span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Now mark each 1GB PML3 entry as RWX and map each to their PML2 entry */</span>

	<span class="c1">// Ensure stack memory is cleared</span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Set up one 'template' RWX PML3 entry and copy it into each of the 512 PML3 entries </span>
	<span class="c1">// Using the same method as SimpleVisor for copying each entry using intrinsics. </span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">RWXTemplate</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// Copy the template into each of the 512 PML3 entry slots </span>
	<span class="n">__stosq</span><span class="p">((</span><span class="n">SIZE_T</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">RWXTemplate</span><span class="p">.</span><span class="n">Flags</span><span class="p">,</span> <span class="n">VMM_EPT_PML3E_COUNT</span><span class="p">);</span>

	<span class="c1">// For each of the 512 PML3 entries </span>
	<span class="k">for</span> <span class="p">(</span><span class="n">EntryIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML3E_COUNT</span><span class="p">;</span> <span class="n">EntryIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Map the 1GB PML3 entry to 512 PML2 (2MB) entries to describe each large page.</span>
		<span class="c1">// NOTE: We do *not* manage any PML1 (4096 byte) entries and do not allocate them.</span>
		<span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML3</span><span class="p">[</span><span class="n">EntryIndex</span><span class="p">].</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="n">EntryIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// All PML2 entries will be RWX and 'present' </span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// We are using 2MB large pages, so we must mark this 1 here. </span>
	<span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">LargePage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* For each collection of 512 PML2 entries (512 collections * 512 entries per collection), mark it RWX using the same template above.
	   This marks the entries as "Present" regardless of if the actual system has memory at this region or not. We will cause a fault in our
	   EPT handler if the guest access a page outside a usable range, despite the EPT frame being present here.
	 */</span>
	<span class="n">__stosq</span><span class="p">((</span><span class="n">SIZE_T</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PML2EntryTemplate</span><span class="p">.</span><span class="n">Flags</span><span class="p">,</span> <span class="n">VMM_EPT_PML3E_COUNT</span> <span class="o">*</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">);</span>

	<span class="c1">// For each of the 512 collections of 512 2MB PML2 entries </span>
	<span class="k">for</span> <span class="p">(</span><span class="n">EntryGroupIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryGroupIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML3E_COUNT</span><span class="p">;</span> <span class="n">EntryGroupIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// For each 2MB PML2 entry in the collection </span>
		<span class="k">for</span> <span class="p">(</span><span class="n">EntryIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">;</span> <span class="n">EntryIndex</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Setup the memory type and frame number of the PML2 entry. </span>
			<span class="n">EptSetupPML2Entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="n">EntryGroupIndex</span><span class="p">][</span><span class="n">EntryIndex</span><span class="p">],</span> <span class="p">(</span><span class="n">EntryGroupIndex</span> <span class="o">*</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">)</span> <span class="o">+</span> <span class="n">EntryIndex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PageTable</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="setting-up-pml2-entries"><span class="mr-2"><strong>Setting up PML2 entries</strong></span><a href="#setting-up-pml2-entries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>PML2 is different from the other tables; this is because, in our 2 MB design, it‚Äôs the last table, so it has to deal with MTRRs‚Äô caching policy.</p><p>First, we have to set the <strong>PageFrameNumber</strong> of our PML2 entry. This is because we‚Äôre mapping all 512 GB without any hole, I mean, we‚Äôre not trying to see just what are MTRR‚Äôs base and end address and map based on them, but we map every possible physical address within 512 GB. Think about it one more time.</p><p>If you want to know more about PFNs in Windows, then you can read my blog posts <strong>Inside Windows Page Frame Number (PFN) ‚Äì <a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part1/">Part 1</a> and <a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part2/">Part 2</a></strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>	  <span class="n">Each</span> <span class="n">of</span> <span class="n">the</span> <span class="mi">512</span> <span class="n">collections</span> <span class="n">of</span> <span class="mi">512</span> <span class="n">PML2</span> <span class="n">entries</span> <span class="n">is</span> <span class="n">setup</span> <span class="n">here</span><span class="p">.</span>
	  <span class="n">This</span> <span class="n">will</span><span class="p">,</span> <span class="n">in</span> <span class="n">total</span><span class="p">,</span> <span class="n">identity</span> <span class="n">map</span> <span class="n">every</span> <span class="n">physical</span> <span class="n">address</span> <span class="n">from</span> <span class="mh">0x0</span> <span class="n">to</span> <span class="n">physical</span> <span class="n">address</span> <span class="mh">0x8000000000</span> <span class="p">(</span><span class="mi">512</span><span class="n">GB</span> <span class="n">of</span> <span class="n">memory</span><span class="p">)</span>

	  <span class="p">((</span><span class="n">EntryGroupIndex</span> <span class="o">*</span> <span class="n">VMM_EPT_PML2E_COUNT</span><span class="p">)</span> <span class="o">+</span> <span class="n">EntryIndex</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="n">MB</span> <span class="n">is</span> <span class="n">the</span> <span class="n">actual</span> <span class="n">physical</span> <span class="n">address</span> <span class="n">we</span><span class="err">'</span><span class="n">re</span> <span class="n">mapping</span>
	 <span class="err">*/</span>
	<span class="n">NewEntry</span><span class="o">-&gt;</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="n">PageFrameNumber</span><span class="p">;</span>
</pre></table></code></div></div><p>Now it‚Äôs time to see the actual caching policy based on MTRRs. Ranges in MTRRs are not divided by 4 KB or 2 MB, and these are exact physical addresses. What we are going to do is iterating over each MTRR and see whether a special MTRR describes our current physical address or not.</p><p>If none of them describe it, then we choose Write-Back (<strong>MEMORY_TYPE_WRITE_BACK</strong>) as the default caching policy; otherwise, we have to select the caching policy that is used in MTRRs.</p><p>This approach will make our EPT PML2 as it‚Äôs like a real system.</p><p>If we don‚Äôt choose the system-specific caching policy, then it will cause catastrophic errors. For example, some of the devices that use physical memory as the command and control mechanism go through the cache and won‚Äôt immediately respond to our requests or for APIC devices will not work in the case of real-time interrupts.</p><p>The following code is responsible for finding the desired caching policy based on MTRRs.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre>	<span class="c1">// Default memory type is always WB for performance. </span>
	<span class="n">TargetMemoryType</span> <span class="o">=</span> <span class="n">MEMORY_TYPE_WRITE_BACK</span><span class="p">;</span>

	<span class="c1">// For each MTRR range </span>
	<span class="k">for</span> <span class="p">(</span><span class="n">CurrentMtrrRange</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">CurrentMtrrRange</span> <span class="o">&lt;</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">NumberOfEnabledMemoryRanges</span><span class="p">;</span> <span class="n">CurrentMtrrRange</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// If this page's address is below or equal to the max physical address of the range </span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AddressOfPage</span> <span class="o">&lt;=</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">MemoryRanges</span><span class="p">[</span><span class="n">CurrentMtrrRange</span><span class="p">].</span><span class="n">PhysicalEndAddress</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// And this page's last address is above or equal to the base physical address of the range </span>
			<span class="k">if</span> <span class="p">((</span><span class="n">AddressOfPage</span> <span class="o">+</span> <span class="n">SIZE_2_MB</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">MemoryRanges</span><span class="p">[</span><span class="n">CurrentMtrrRange</span><span class="p">].</span><span class="n">PhysicalBaseAddress</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* If we're here, this page fell within one of the ranges specified by the variable MTRRs
				   Therefore, we must mark this page as the same cache type exposed by the MTRR
				 */</span>
				<span class="n">TargetMemoryType</span> <span class="o">=</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">MemoryRanges</span><span class="p">[</span><span class="n">CurrentMtrrRange</span><span class="p">].</span><span class="n">MemoryType</span><span class="p">;</span>
				<span class="c1">// LogInfo("0x%X&gt; Range=%llX -&gt; %llX | Begin=%llX End=%llX", PageFrameNumber, AddressOfPage, AddressOfPage + SIZE_2_MB - 1, EptState-&gt;MemoryRanges[CurrentMtrrRange].PhysicalBaseAddress, EptState-&gt;MemoryRanges[CurrentMtrrRange].PhysicalEndAddress);</span>

				<span class="c1">// 11.11.4.1 MTRR Precedences </span>
				<span class="k">if</span> <span class="p">(</span><span class="n">TargetMemoryType</span> <span class="o">==</span> <span class="n">MEMORY_TYPE_UNCACHEABLE</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="c1">// If this is going to be marked uncacheable, then we stop the search as UC always takes precedent. </span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Finally, commit the memory type to the entry. </span>
	<span class="n">NewEntry</span><span class="o">-&gt;</span><span class="n">MemoryType</span> <span class="o">=</span> <span class="n">TargetMemoryType</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="ept-violation"><span class="mr-2"><strong>EPT Violation</strong></span><a href="#ept-violation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Intel describes EPT Violation like this:</p><p>An EPT violation occurs when there is no EPT misconfiguration, but the EPT paging structure entries disallow access using the guest-physical address.</p><p>But that‚Äôs hard to understand, in short, every time one instruction tries to read a page (<strong>Read Access</strong>), or an instruction tries to write on a page (<strong>Write Access</strong>), or an instruction causes instruction fetch from a page and EPT attributes (the one we configured in the above sections) of that page doesn‚Äôt allow this, then an EPT Violation occurs.</p><p>Let me explain a little bit more, imagine we have an entry in our EPT Table which is responsible for mapping physical address 0x1000. In this entry, we set <strong>Write Access</strong> to 0 (<strong>Read Access</strong> = 1 and <strong>Execute Access</strong> = 1). If any instruction tries to write on that page, for example by using (Mov [0x1000], RAX) then as the paging attributes doesn‚Äôt allow writing, so an EPT Violation occurs and now our callback is called so that we can decide to what we want to do with that page.</p><p>By 0x1000, I mean a physical address. Of course, if you have the virtual address, then it gets translated to a physical.</p><p>Another example, let‚Äôs assume an NT function (for example <strong>NtCreateFile</strong>) is located fffff801`80230540.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">nt</span><span class="o">!</span><span class="n">NtCreateFile</span><span class="o">:</span>
<span class="n">fffff801</span><span class="err">`</span><span class="mi">80230540</span> <span class="mi">4881</span><span class="n">ec88000000</span>  <span class="n">sub</span>     <span class="n">rsp</span><span class="p">,</span><span class="mi">88</span><span class="n">h</span>
<span class="n">fffff801</span><span class="err">`</span><span class="mi">80230547</span> <span class="mi">33</span><span class="n">c0</span>            <span class="n">xor</span>     <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>
<span class="n">fffff801</span><span class="err">`</span><span class="mi">80230549</span> <span class="mi">4889442478</span>      <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">78</span><span class="n">h</span><span class="p">],</span><span class="n">rax</span>
</pre></table></code></div></div><p>If we convert it to a physical address, then the address of <strong>NtCreateFile</strong> in physical memory is 0x3B8000, now we try to find this physical address in our EPT PTE Table. Then we set <strong>Execute Access</strong> of that entry to 0. Now, each time someone tries to call, jmp, ret, etc. to this particular page, then an EPT Violation occurs.</p><p>This is the basic idea of using EPT function hooks, we talk about it in detail in Part 8.</p><p>For now, first, we have to read the physical address, which caused this EPT Violation. It‚Äôs done by reading <strong>GUEST_PHYSICAL_ADDRESS</strong> using <strong>Vmread</strong> instruction.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>		<span class="c1">// Reading guest physical address</span>
		<span class="n">GuestPhysicalAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_PHYSICAL_ADDRESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestPhysicalAddr</span><span class="p">);</span>
		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Guest Physical Address : 0x%llx"</span><span class="p">,</span> <span class="n">GuestPhysicalAddr</span><span class="p">);</span>
</pre></table></code></div></div><p>The second thing that we have to read is <strong>Exit Qualification.</strong> If you remember from the previous part, <strong>Exit Qualification</strong> gives additional details about <strong>Exit Reasons</strong>.</p><p>I mean, each <strong>Exit Reason</strong> might have a special <strong>Exit Qualification</strong> that has a special meaning for that special <strong>Exit Reason</strong>. (how many ‚Äúspecial‚Äù I used in the previous sentence ?)</p><p><strong>Exit Reason</strong> can be read from <strong>VM_EXIT_REASON</strong> using <strong>Vmread</strong> instruction.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="n">ULONG</span> <span class="n">ExitReason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_REASON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitReason</span><span class="p">);</span>
</pre></table></code></div></div><p>In the case of EPT Violation, <strong>Exit Qualification</strong> shows that the reason why this violation occurs. For example, it indicates that EPT Violation occurs because of a data read to a physical page that its <strong>Read Access</strong> is 0 or instruction fetches (a function tries to execute instruction) from a physical page that its <strong>Execute Access</strong> is 0.</p><p>The following table shows the structure of <strong>Exit Qualification</strong> and each bit‚Äôs meaning for <strong>EPT Violation</strong>.</p><p><img data-src="../../assets/images/exit-qualification-for-ept-violation.png" alt="" data-proofer-ignore></p><p>Now that we have all the details, we need to pass them to <strong>EptHandlePageHookExit,</strong> and we deal with it in the next sections.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cm">/*
   Handle VM exits for EPT violations. Violations are thrown whenever an operation is performed
   on an EPT entry that does not provide permissions to access that page.
*/</span>
<span class="n">BOOLEAN</span> <span class="nf">EptHandleEptViolation</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">ExitQualification</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">GuestPhysicalAddr</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">VMX_EXIT_QUALIFICATION_EPT_VIOLATION</span> <span class="n">ViolationQualification</span><span class="p">;</span>

	<span class="n">DbgBreakPoint</span><span class="p">();</span>

	<span class="n">ViolationQualification</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">ExitQualification</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EptHandlePageHookExit</span><span class="p">(</span><span class="n">ViolationQualification</span><span class="p">,</span> <span class="n">GuestPhysicalAddr</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="c1">// Handled by page hook code.</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">LogError</span><span class="p">(</span><span class="s">"Unexpected EPT violation"</span><span class="p">);</span>
	<span class="n">DbgBreakPoint</span><span class="p">();</span>

	<span class="c1">// Redo the instruction that caused the exception. </span>
	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="ept-misconfiguration"><span class="mr-2"><strong>EPT Misconfiguration</strong></span><a href="#ept-misconfiguration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Another EPT derived vm-exit is EPT Misconfiguration (<strong>EXIT_REASON_EPT_MISCONFIG</strong>).</p><p>An EPT Misconfiguration occurs when, in the course of translating a physical guest address, the logical processor encounters an EPT paging-structure entry that contains an unsupported value.</p><p>If you want to know more about all the reasons why EPT Misconfiguration occurs, you can see Intel SDM - Vol 3C Section 28.2.3.1.</p><p>Based on my experience, I encountered EPT Misconfiguration most of the time because I clear the bit 0 of the entry (indicating that data reads are not allowed), and bit 1 is set (reporting that data writes are permitted).</p><p>Also, EPT misconfigurations occur when an EPT paging-structure entry is configured with settings reserved for future functionality.</p><p>It‚Äôs fatal error, let‚Äôs just break and see what we‚Äôve done wrong !</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">VOID</span> <span class="nf">EptHandleMisconfiguration</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">GuestAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"EPT Misconfiguration!"</span><span class="p">);</span>
	<span class="n">LogError</span><span class="p">(</span><span class="s">"A field in the EPT paging structure was invalid, Faulting guest address : 0x%llx"</span><span class="p">,</span> <span class="n">GuestAddress</span><span class="p">);</span>

	<span class="n">DbgBreakPoint</span><span class="p">();</span>
	<span class="c1">// We can't continue now. </span>
	<span class="c1">// EPT misconfiguration is a fatal exception that will probably crash the OS if we don't get out now.</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="adding-ept-to-vmcs"><span class="mr-2"><strong>Adding EPT to VMCS</strong></span><a href="#adding-ept-to-vmcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Our hypervisor starts virtualizing MMU by calling <strong>EptLogicalProcessorInitialize,</strong> which sets a 64-bit value called <strong>EPTP</strong>. The following table shows the structure of <strong>EPTP</strong>. If you look at part 4, we have this table in that part too, but there is a change here, bit 7 was reserved at the time I wrote part 4, and now it has something to do with <a href="http://windows-internals.com/cet-on-windows/">shadow stacks</a>.</p><p><img data-src="../../assets/images/new-EPTP-table.png" alt="" data-proofer-ignore></p><p><strong>EptLogicalProcessorInitialize</strong> calls <strong>EptAllocateAndCreateIdentityPageTable</strong> to allocate identity table (as described above).</p><p>For performance, we let the processor know it can cache the EPT (<strong>MemoryType</strong> to <strong>MEMORY_TYPE_WRITE_BACK</strong>).</p><p>We are not utilizing the ‚Äò<strong>access</strong>‚Äô and ‚Äò<strong>dirty</strong>‚Äô flag features (<strong>EnableAccessAndDirtyFlags</strong> to <strong>FALSE</strong>).</p><p>As Intel mentioned, Page Walk should be the count of the tables we use (4) minus 1, so <strong>PageWalkLength = 3</strong> indicates an EPT page-walk length of 4. It is because we‚Äôre not using just three tables with 2 MB granularity, we‚Äôll split 2 MB pages to 4 KB granularity.</p><p>The last step is to save <strong>EPTP</strong> somewhere into a global variable so we can use it later.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="cm">/*
  Initialize EPT for an individual logical processor.
  Creates an identity mapped page table and sets up an EPTP to be applied to the VMCS later.
*/</span>
<span class="n">BOOLEAN</span> <span class="nf">EptLogicalProcessorInitialize</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PVMM_EPT_PAGE_TABLE</span> <span class="n">PageTable</span><span class="p">;</span>
	<span class="n">EPTP</span> <span class="n">EPTP</span><span class="p">;</span>

	<span class="cm">/* Allocate the identity mapped page table*/</span>
	<span class="n">PageTable</span> <span class="o">=</span> <span class="n">EptAllocateAndCreateIdentityPageTable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageTable</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Unable to allocate memory for EPT"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Virtual address to the page table to keep track of it for later freeing </span>
	<span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span> <span class="o">=</span> <span class="n">PageTable</span><span class="p">;</span>

	<span class="n">EPTP</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// For performance, we let the processor know it can cache the EPT.</span>
	<span class="n">EPTP</span><span class="p">.</span><span class="n">MemoryType</span> <span class="o">=</span> <span class="n">MEMORY_TYPE_WRITE_BACK</span><span class="p">;</span>

	<span class="c1">// We are not utilizing the 'access' and 'dirty' flag features. </span>
	<span class="n">EPTP</span><span class="p">.</span><span class="n">EnableAccessAndDirtyFlags</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="cm">/*
	  Bits 5:3 (1 less than the EPT page-walk length) must be 3, indicating an EPT page-walk length of 4;
	  see Section 28.2.2
	 */</span>
	<span class="n">EPTP</span><span class="p">.</span><span class="n">PageWalkLength</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="c1">// The physical page number of the page table we will be using </span>
	<span class="n">EPTP</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PageTable</span><span class="o">-&gt;</span><span class="n">PML4</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="c1">// We will write the EPTP to the VMCS later </span>
	<span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span> <span class="o">=</span> <span class="n">EPTP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Finally, we need to configure Vmcs with our <strong>EPTP</strong> Table, so we use <strong>vmwrite</strong> with <strong>EPT_POINTER</strong> and set it to our <strong>EPTP</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Set up EPT </span>
	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">);</span>
</pre></table></code></div></div><p>Also, don‚Äôt forget to enable EPT feature in Secondary Processor-Based VM-Execution Controls using <strong>CPU_BASED_CTL2_ENABLE_EPT;</strong> otherwise, it won‚Äôt work.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>	<span class="n">SecondaryProcBasedVmExecControls</span> <span class="o">=</span> <span class="n">HvAdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_CTL2_RDTSCP</span> <span class="o">|</span>
		<span class="n">CPU_BASED_CTL2_ENABLE_EPT</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_INVPCID</span> <span class="o">|</span>
		<span class="n">CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">);</span>

	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">SecondaryProcBasedVmExecControls</span><span class="p">);</span>
	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Secondary Proc Based VM Exec Controls (MSR_IA32_VMX_PROCBASED_CTLS2) : 0x%x"</span><span class="p">,</span> <span class="n">SecondaryProcBasedVmExecControls</span><span class="p">);</span>
</pre></table></code></div></div><p>Now we have a perfect EPT Table which virtualizes MMU and now all of the translations go through the EPT.</p><h1 id="monitoring-pages-rwx-activity"><strong>Monitoring Page‚Äôs RWX Activity</strong></h1><p>The next important topic is the monitoring of the page‚Äôs RWX. From the above section, you saw that we put each of the Read Access, Write Access and Execute Access to 1, but to use EPT‚Äôs monitoring features, we have to set some of them to 0 so that we get EPT Violation on each of the accesses mentioned above.</p><p>Using these features (setting access to 0) has its difficulties by its nature, problems relating to IRQL, splitting, absence of the ability to use NT functions, synchronization, and deadlock are some of these problems and limitations.</p><p>In this section we‚Äôre trying to solve these problem.</p><h2 id="pre-allocating-buffers-for-vmx-root-mode"><span class="mr-2"><strong>Pre-allocating Buffers for VMX Root Mode</strong></span><a href="#pre-allocating-buffers-for-vmx-root-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>After executing VMLAUNCH, we shouldn‚Äôt modify EPT Tables from Vmx non-root mode; that is because if we do it, then it might (and will) causes system inconsistency.</p><p>This limitation and the fact that we couldn‚Äôt use any NT function in VMX Root Mode bring us new challenges.</p><p>One of these challenges is that we might need to split a 2 MB Page into 4 KB pages, of course, another Page Table (PML1) is necessary to store the details of new 4 KB pages. I mean, we have to create another Page Table (PML1), and it needs a new memory.</p><p>We can‚Äôt use <strong>ExAllocatePoolTag</strong> in Vmx root-mode as it‚Äôs an NT API. (you can use it in Vmx root-mode, and you‚Äôll see that it sometimes work and sometimes halts the system - the reason is described in the <strong>Discussion</strong> section).</p><p>The solution to this problem is using a previously allocated buffer from Vmx non-root mode and use it in Vmx root mode, so this brings us the first limitation to our hypervisor which is we have to start setting hooks from vmx non-root mode because we want to pre-allocate a buffer then we pass the buffer and hook settings to Vmx root-mode using a special Vmcalls.</p><p>By the way, this is not an unsolvable limitation, for example, you can allocate 100 pages from Vmx non-root mode and use them whenever you want in Vmx root-mode, and it‚Äôs not necessarily a limitation anymore but for now, let‚Äôs assume that the caller should start setting hooks from Vmx non-root mode.</p><p>Honestly, I wanted to make a mechanism for running code from Vmx root mode to Vmx non-root mode using NMI events; using this approach will resolve the problem of pre-allocating buffers, but for this part, let‚Äôs use pre-allocated buffers.</p><p><a href="https://github.com/tandasat/HyperPlatform">Hyperplatform</a> and <a href="https://github.com/wbenny/hvpp">Hvpp</a> use the pre-allocated buffers.</p><p>In this section and next sections we‚Äôre trying to complete a function called ‚Äú<strong>EptPageHook</strong>‚Äù.</p><p>There is a per-core global variable called ‚Äú<strong>PreAllocatedMemoryDetails</strong>‚Äù in <strong>GuestState</strong> that is defined like this:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_VMX_NON_ROOT_MODE_MEMORY_ALLOCATOR</span>
<span class="p">{</span>
	<span class="n">PVOID</span> <span class="n">PreAllocatedBuffer</span><span class="p">;</span>		<span class="c1">// As we can't use ExAllocatePoolWithTag in VMX Root mode, this holds a pre-allocated buffer address</span>
									<span class="c1">// PreAllocatedBuffer == 0 indicates that it's not previously allocated</span>
<span class="p">}</span> <span class="n">VMX_NON_ROOT_MODE_MEMORY_ALLOCATOR</span><span class="p">,</span> <span class="o">*</span> <span class="n">PVMX_NON_ROOT_MODE_MEMORY_ALLOCATOR</span><span class="p">;</span>
</pre></table></code></div></div><p>Now that we‚Äôre trying to hook, we‚Äôll see whether the current core has a previously pre-allocated buffer or not. If it doesn‚Äôt have a buffer, then we allocate it using <strong>ExAllocatePoolWithTag</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">PreAllocatedMemoryDetails</span><span class="p">.</span><span class="n">PreAllocatedBuffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PreAllocBuff</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_DYNAMIC_SPLIT</span><span class="p">),</span> <span class="n">POOLTAG</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PreAllocBuff</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">LogError</span><span class="p">(</span><span class="s">"Insufficient memory for pre-allocated buffer"</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// Zero out the memory</span>
		<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">PreAllocBuff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_DYNAMIC_SPLIT</span><span class="p">));</span>

		<span class="c1">// Save the pre-allocated buffer</span>
		<span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">PreAllocatedMemoryDetails</span><span class="p">.</span><span class="n">PreAllocatedBuffer</span> <span class="o">=</span> <span class="n">PreAllocBuff</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Now we have two different states if we previously configured the VMCS with EPT and we‚Äôre already in a hypervisor then we have to ask, Vmx root-mode to set the hook for us (<em>Setting hook after Vmlaunch</em>); otherwise, we can modify it in a regular function as we don‚Äôt execute VMLAUNCH (with EPT) yet (<em>Setting hook before Vmlaunch</em>).</p><p>By ‚Äúwith EPT,‚Äù I mean if we used this EPT in our hypervisor. For example, you might configure VMCS without EPTP, then you execute VMLAUNCH, and now you decide to create an EPT Table, this way doesn‚Äôt need Vmx root-mode to modify EPT Table, we can change it from Vmx non-root mode as we didn‚Äôt use this EPT Table yet.</p><h2 id="setting-hook-before-vmlaunch"><span class="mr-2"><strong>Setting hook before Vmlaunch</strong></span><a href="#setting-hook-before-vmlaunch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>I prefer to do everything in a function so that <strong>EptVmxRootModePageHook</strong> can be used for both Vmx root-mode and non-root mode. Still, you shouldn‚Äôt directly call this function as it needs a preparing phase (instead, you can call <strong>EptPageHook</strong>).</p><p>What we have to do is calling <strong>EptVmxRootModePageHook</strong> and a <strong>HasLaunched</strong> flag that determines whether we used our EPT in our Vmx operation our not.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">EptVmxRootModePageHook</span><span class="p">(</span><span class="n">TargetFunc</span><span class="p">,</span> <span class="n">HasLaunched</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LogInfo</span><span class="p">(</span><span class="s">"[*] Hook applied (VM has not launched)"</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
</pre></table></code></div></div><p>I‚Äôll describe <strong>EptVmxRootModePageHook</strong> in the section, <strong>Applying the Hook</strong> later.</p><h2 id="setting-hook-after-vmlaunch"><span class="mr-2"><strong>Setting hook after Vmlaunch</strong></span><a href="#setting-hook-after-vmlaunch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>If we‚Äôre already used this EPT in our Vmx operation, then we need to ask Vmx root-mode to modify the EPT Table for us; in other words, we have to call <strong>EptVmxRootModePageHook</strong> from Vmx root-mode, so it needs Vmcall.</p><p>We have some additional things to do here, as I told you, each logical core has its own set of caches relating to EPT, so we have to invalidate all the cores‚Äô EPT Tables immediately and of course it has to be done in Vmx non-root mode as we want to use NT APIs.</p><p>To call <strong>EptVmxRootModePageHook</strong> from Vmx root-mode, we‚Äôll use Vmcall with <strong>VMCALL_EXEC_HOOK_PAGE</strong> and also sent the functions virtual address (<strong>TargetFunc</strong>) as the first parameter.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">HasLaunched</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_EXEC_HOOK_PAGE</span><span class="p">,</span> <span class="n">TargetFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Hook applied from VMX Root Mode"</span><span class="p">);</span>

			<span class="c1">// Now we have to notify all the core to invalidate their EPT</span>
			<span class="n">HvNotifyAllToInvalidateEpt</span><span class="p">();</span>

			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>In Vmcall handler, we just call <strong>EptVmxRootModePageHook</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">VMCALL_EXEC_HOOK_PAGE</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">HookResult</span> <span class="o">=</span> <span class="n">EptVmxRootModePageHook</span><span class="p">(</span><span class="n">OptionalParam1</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">HookResult</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Let‚Äôs get down to invalidation part,</p><p><strong>HvNotifyAllToInvalidateEpt</strong> uses <strong>KeIpiGenericCall</strong> which broadcasts <strong>HvInvalidateEptByVmcall</strong> on all the core.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/* Notify all core to invalidate their EPT */</span>
<span class="n">VOID</span> <span class="nf">HvNotifyAllToInvalidateEpt</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Let's notify them all</span>
	<span class="n">KeIpiGenericCall</span><span class="p">(</span><span class="n">HvInvalidateEptByVmcall</span><span class="p">,</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As the invalidation should be within vmx root-mode (<strong>INVEPT</strong> instruction is only valid in vmx root-mode) thus <strong>HvInvalidateEptByVmcall</strong> uses Vmcall with <strong>VMCALL_INVEPT_ALL_CONTEXT</strong> and <strong>VMCALL_INVEPT_SINGLE_CONTEXT</strong> to notify vmx root-mode about invalidation.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cm">/* Invalidate EPT using Vmcall (should be called from Vmx non root mode) */</span>
<span class="n">VOID</span> <span class="nf">HvInvalidateEptByVmcall</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">Context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Context</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// We have to invalidate all contexts</span>
		<span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_INVEPT_ALL_CONTEXT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// We have to invalidate all contexts</span>
		<span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_INVEPT_SINGLE_CONTEXT</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The Vmcall handler uses <strong>InveptSingleContext</strong> and <strong>InveptAllContexts</strong> to invalidate the contexts; we‚Äôll talk about invalidation in details later in this part (<strong>Invalidating Translations Derived from EPT (INVEPT)</strong>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">VMCALL_INVEPT_SINGLE_CONTEXT</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">InveptSingleContext</span><span class="p">(</span><span class="n">OptionalParam1</span><span class="p">);</span>
		<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">VMCALL_INVEPT_ALL_CONTEXT</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">InveptAllContexts</span><span class="p">();</span>
		<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><h2 id="finding-a-pages-entry-in-ept-tables"><span class="mr-2"><strong>Finding a Page‚Äôs entry in EPT Tables</strong></span><a href="#finding-a-pages-entry-in-ept-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Let‚Äôs see how we can find addresses in PML1, PML2, PML3 and PML4.</p><h2 id="finding-pml4-pml3-pml2-entries"><span class="mr-2"><strong>Finding PML4, PML3, PML2 entries</strong></span><a href="#finding-pml4-pml3-pml2-entries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>We want to find PML2 entry, for finding PML2, first, we have to find PML4 and PML3.</p><p>We used an ordinal approach to map the physical addresses so all the physical addresses are stored in the same way so we need some definitions to find the <strong>index</strong> of the entries from tables.</p><p>Here‚Äôs the definitions.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// Index of the 1st paging structure (4096 byte)</span>
<span class="cp">#define ADDRMASK_EPT_PML1_INDEX(_VAR_) ((_VAR_ &amp; 0x1FF000ULL) &gt;&gt; 12)
</span>
<span class="c1">// Index of the 2nd paging structure (2MB)</span>
<span class="cp">#define ADDRMASK_EPT_PML2_INDEX(_VAR_) ((_VAR_ &amp; 0x3FE00000ULL) &gt;&gt; 21)
</span>
<span class="c1">// Index of the 3rd paging structure (1GB)</span>
<span class="cp">#define ADDRMASK_EPT_PML3_INDEX(_VAR_) ((_VAR_ &amp; 0x7FC0000000ULL) &gt;&gt; 30)
</span>
<span class="c1">// Index of the 4th paging structure (512GB)</span>
<span class="cp">#define ADDRMASK_EPT_PML4_INDEX(_VAR_) ((_VAR_ &amp; 0xFF8000000000ULL) &gt;&gt; 39)
</span></pre></table></code></div></div><p>After finding the indexes, we have to find the virtual address to that index so we can modify the page table. It‚Äôs because in protected mode we can‚Äôt access physical addresses.</p><p>The following code, first finds the indexes then return the virtual address from the EPT Page Table to that indexes.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cm">/* Get the PML2 entry for this physical address. */</span>
<span class="n">PEPT_PML2_ENTRY</span> <span class="nf">EptGetPml2Entry</span><span class="p">(</span><span class="n">PVMM_EPT_PAGE_TABLE</span> <span class="n">EptPageTable</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SIZE_T</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">DirectoryPointer</span><span class="p">,</span> <span class="n">PML4Entry</span><span class="p">;</span>
	<span class="n">PEPT_PML2_ENTRY</span> <span class="n">PML2</span><span class="p">;</span>

	<span class="n">Directory</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML2_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>
	<span class="n">DirectoryPointer</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML3_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>
	<span class="n">PML4Entry</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML4_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Addresses above 512GB are invalid because it is &gt; physical address bus width </span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PML4Entry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PML2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptPageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="n">DirectoryPointer</span><span class="p">][</span><span class="n">Directory</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">PML2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="finding-pml1-entry"><span class="mr-2"><strong>Finding PML1 entry</strong></span><a href="#finding-pml1-entry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For PML1, we have the same approach. First, we find the PML2 the same as above. Then we check to see if the PML2 is split or not. It‚Äôs because if it‚Äôs not split before then we don‚Äôt have PML1 and it‚Äôs 3-level paging.</p><p>Finally, as we saved physical addresses contiguously, so we can find the index using <strong>ADDRMASK_EPT_PML1_INDEX</strong> (as defined above) and then return the virtual address to that page entry.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="cm">/* Get the PML1 entry for this physical address if the page is split. Return NULL if the address is invalid or the page wasn't already split. */</span>
<span class="n">PEPT_PML1_ENTRY</span> <span class="nf">EptGetPml1Entry</span><span class="p">(</span><span class="n">PVMM_EPT_PAGE_TABLE</span> <span class="n">EptPageTable</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SIZE_T</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">DirectoryPointer</span><span class="p">,</span> <span class="n">PML4Entry</span><span class="p">;</span>
	<span class="n">PEPT_PML2_ENTRY</span> <span class="n">PML2</span><span class="p">;</span>
	<span class="n">PEPT_PML1_ENTRY</span> <span class="n">PML1</span><span class="p">;</span>
	<span class="n">PEPT_PML2_POINTER</span> <span class="n">PML2Pointer</span><span class="p">;</span>

	<span class="n">Directory</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML2_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>
	<span class="n">DirectoryPointer</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML3_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>
	<span class="n">PML4Entry</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML4_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Addresses above 512GB are invalid because it is &gt; physical address bus width </span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PML4Entry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PML2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptPageTable</span><span class="o">-&gt;</span><span class="n">PML2</span><span class="p">[</span><span class="n">DirectoryPointer</span><span class="p">][</span><span class="n">Directory</span><span class="p">];</span>

	<span class="c1">// Check to ensure the page is split </span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PML2</span><span class="o">-&gt;</span><span class="n">LargePage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Conversion to get the right PageFrameNumber.</span>
	<span class="c1">// These pointers occupy the same place in the table and are directly convertable.</span>
	<span class="n">PML2Pointer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PEPT_PML2_POINTER</span><span class="p">)</span><span class="n">PML2</span><span class="p">;</span>

	<span class="c1">// If it is, translate to the PML1 pointer </span>
	<span class="n">PML1</span> <span class="o">=</span> <span class="p">(</span><span class="n">PEPT_PML1_ENTRY</span><span class="p">)</span><span class="n">PhysicalAddressToVirtualAddress</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">PML2Pointer</span><span class="o">-&gt;</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PML1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Index into PML1 for that address </span>
	<span class="n">PML1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PML1</span><span class="p">[</span><span class="n">ADDRMASK_EPT_PML1_INDEX</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">)];</span>

	<span class="k">return</span> <span class="n">PML1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="splitting-2-mb-pages-to-4-kb-pages"><span class="mr-2"><strong>Splitting 2 MB Pages to 4 KB Pages</strong></span><a href="#splitting-2-mb-pages-to-4-kb-pages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>As you know, in all of our hypervisor parts we used 3 LEVEL paging (PML4, PML3, PML2) and our granularity is 2 MB. Having pages with 2 MB granularity is not adequate for monitoring purposes because we might get lots of unrelated violations caused by non-relevant areas.</p><p>To fix these kind of problems, we use PML1 and 4 KB granularity.</p><p>This is where we might need an additional buffer and as we‚Äôre in vmx root-mode, then we‚Äôll use our previously allocated buffers.</p><p>First, we get the actual entry from PML2 and check if it‚Äôs already a 4 KB defined table, if it previously split then nothing to do, we can use it.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>	<span class="c1">// Find the PML2 entry that's currently used</span>
	<span class="n">TargetEntry</span> <span class="o">=</span> <span class="n">EptGetPml2Entry</span><span class="p">(</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetEntry</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"An invalid physical address passed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// If this large page is not marked a large page, that means it's a pointer already.</span>
	<span class="c1">// That page is therefore already split.</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetEntry</span><span class="o">-&gt;</span><span class="n">LargePage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>If not, we set <strong>PreAllocatedMemoryDetails</strong>‚Äôs <strong>PreAllocatedBuffer</strong> to null so that next time the pre-allocator allocates a new buffer for this purpose.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Free previous buffer </span>
	<span class="n">GuestState</span><span class="p">[</span><span class="n">CoreIndex</span><span class="p">].</span><span class="n">PreAllocatedMemoryDetails</span><span class="p">.</span><span class="n">PreAllocatedBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></table></code></div></div><p>Then, we should fill the PML1 with an RWX template and then split our 2 MB page into 4 KB chunks (compute 4 KB physical addresses and fill the <strong>PageFrameNumber</strong>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>	<span class="c1">// Point back to the entry in the dynamic split for easy reference for which entry that dynamic split is for.</span>
	<span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">TargetEntry</span><span class="p">;</span>

	<span class="c1">// Make a template for RWX </span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// Copy the template into all the PML1 entries </span>
	<span class="n">__stosq</span><span class="p">((</span><span class="n">SIZE_T</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">PML1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">EntryTemplate</span><span class="p">.</span><span class="n">Flags</span><span class="p">,</span> <span class="n">VMM_EPT_PML1E_COUNT</span><span class="p">);</span>


	<span class="c1">// Set the page frame numbers for identity mapping.</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">EntryIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML1E_COUNT</span><span class="p">;</span> <span class="n">EntryIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Convert the 2MB page frame number to the 4096 page entry number plus the offset into the frame. </span>
		<span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">PML1</span><span class="p">[</span><span class="n">EntryIndex</span><span class="p">].</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">((</span><span class="n">TargetEntry</span><span class="o">-&gt;</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">SIZE_2_MB</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">EntryIndex</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Finally, create a new PML2 entry (with <strong>LargePage = 0</strong>) and replace it with the previous PML2 entry.</p><p>Also keep the track of allocated memory to de-allocate it when we want to run <strong>vmxoff</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="c1">// Allocate a new pointer which will replace the 2MB entry with a pointer to 512 4096 byte entries. </span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">PML1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="c1">// Add our allocation to the linked list of dynamic splits for later deallocation </span>
	<span class="n">InsertHeadList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EptPageTable</span><span class="o">-&gt;</span><span class="n">DynamicSplitList</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">DynamicSplitList</span><span class="p">);</span>

	<span class="c1">// Now, replace the entry in the page table with our new split pointer.</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">TargetEntry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NewPointer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NewPointer</span><span class="p">));</span>
</pre></table></code></div></div><p>The following function represent the full code for splitting 2 MB pages to 4 KB pages.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre><td class="rouge-code"><pre><span class="cm">/* Split 2MB (LargePage) into 4kb pages */</span>
<span class="n">BOOLEAN</span> <span class="nf">EptSplitLargePage</span><span class="p">(</span><span class="n">PVMM_EPT_PAGE_TABLE</span> <span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">PreAllocatedBuffer</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">CoreIndex</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">PVMM_EPT_DYNAMIC_SPLIT</span> <span class="n">NewSplit</span><span class="p">;</span>
	<span class="n">EPT_PML1_ENTRY</span> <span class="n">EntryTemplate</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">EntryIndex</span><span class="p">;</span>
	<span class="n">PEPT_PML2_ENTRY</span> <span class="n">TargetEntry</span><span class="p">;</span>
	<span class="n">EPT_PML2_POINTER</span> <span class="n">NewPointer</span><span class="p">;</span>

	<span class="c1">// Find the PML2 entry that's currently used</span>
	<span class="n">TargetEntry</span> <span class="o">=</span> <span class="n">EptGetPml2Entry</span><span class="p">(</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetEntry</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"An invalid physical address passed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// If this large page is not marked a large page, that means it's a pointer already.</span>
	<span class="c1">// That page is therefore already split.</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetEntry</span><span class="o">-&gt;</span><span class="n">LargePage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Free previous buffer </span>
	<span class="n">GuestState</span><span class="p">[</span><span class="n">CoreIndex</span><span class="p">].</span><span class="n">PreAllocatedMemoryDetails</span><span class="p">.</span><span class="n">PreAllocatedBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// Allocate the PML1 entries </span>
	<span class="n">NewSplit</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVMM_EPT_DYNAMIC_SPLIT</span><span class="p">)</span><span class="n">PreAllocatedBuffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NewSplit</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to allocate dynamic split memory"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">NewSplit</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_DYNAMIC_SPLIT</span><span class="p">));</span>


	<span class="c1">// Point back to the entry in the dynamic split for easy reference for which entry that dynamic split is for.</span>
	<span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">TargetEntry</span><span class="p">;</span>

	<span class="c1">// Make a template for RWX </span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">EntryTemplate</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// Copy the template into all the PML1 entries </span>
	<span class="n">__stosq</span><span class="p">((</span><span class="n">SIZE_T</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">PML1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">EntryTemplate</span><span class="p">.</span><span class="n">Flags</span><span class="p">,</span> <span class="n">VMM_EPT_PML1E_COUNT</span><span class="p">);</span>


	<span class="c1">// Set the page frame numbers for identity mapping.</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">EntryIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">EntryIndex</span> <span class="o">&lt;</span> <span class="n">VMM_EPT_PML1E_COUNT</span><span class="p">;</span> <span class="n">EntryIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Convert the 2MB page frame number to the 4096 page entry number plus the offset into the frame. </span>
		<span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">PML1</span><span class="p">[</span><span class="n">EntryIndex</span><span class="p">].</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">((</span><span class="n">TargetEntry</span><span class="o">-&gt;</span><span class="n">PageFrameNumber</span> <span class="o">*</span> <span class="n">SIZE_2_MB</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">EntryIndex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Allocate a new pointer which will replace the 2MB entry with a pointer to 512 4096 byte entries. </span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NewPointer</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">PML1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="c1">// Add our allocation to the linked list of dynamic splits for later deallocation </span>
	<span class="n">InsertHeadList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EptPageTable</span><span class="o">-&gt;</span><span class="n">DynamicSplitList</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NewSplit</span><span class="o">-&gt;</span><span class="n">DynamicSplitList</span><span class="p">);</span>

	<span class="c1">// Now, replace the entry in the page table with our new split pointer.</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">TargetEntry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NewPointer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NewPointer</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="applying-the-hook"><span class="mr-2"><strong>Applying the Hook</strong></span><a href="#applying-the-hook" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>EptVmxRootModePageHook</strong> is one of the important parts of the EPT.</p><p>First, we check to prohibit calling this function from vmx root-mode when the pre-allocated buffer isn‚Äôt available.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>	<span class="c1">// Check whether we are in VMX Root Mode or Not </span>
	<span class="n">LogicalCoreIndex</span> <span class="o">=</span> <span class="n">KeGetCurrentProcessorIndex</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">IsOnVmxRootMode</span> <span class="o">&amp;&amp;</span> <span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">PreAllocatedMemoryDetails</span><span class="p">.</span><span class="n">PreAllocatedBuffer</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">HasLaunched</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Then we align the address as the addresses in page tables are aligned.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="n">VirtualTarget</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">TargetFunc</span><span class="p">);</span>

	<span class="n">PhysicalAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="n">VirtualTarget</span><span class="p">);</span>
</pre></table></code></div></div><p>We‚Äôll check about the granularity and split it if it‚Äôs a <strong>LargePage</strong> (more details at the next section - Splitting 2 MB Pages to 4 KB Pages ).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="c1">// Set target buffer</span>
	<span class="n">TargetBuffer</span> <span class="o">=</span> <span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">PreAllocatedMemoryDetails</span><span class="p">.</span><span class="n">PreAllocatedBuffer</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EptSplitLargePage</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">TargetBuffer</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">,</span> <span class="n">LogicalCoreIndex</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Could not split page for the address : 0x%llx"</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Then find the PML1 entry of the requested page and as it‚Äôs already divided into 4 KB pages so PML1 is available.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="c1">// Pointer to the page entry in the page table. </span>
	<span class="n">TargetPage</span> <span class="o">=</span> <span class="n">EptGetPml1Entry</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Ensure the target is valid. </span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetPage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to get PML1 entry of the target address"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Save the original permissions of the page </span>
	<span class="n">OriginalEntry</span> <span class="o">=</span> <span class="o">*</span><span class="n">TargetPage</span><span class="p">;</span>
</pre></table></code></div></div><p>Now, we change the attributes related to the PML1 entry, this the most interesting part of this function, for example, you can disable Write access to a 4 KB page, in our case, I disabled instruction execution (fetch) from the target page.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="cm">/*
	 * Lastly, mark the entry in the table as no execute. This will cause the next time that an instruction is
	 * fetched from this page to cause an EPT violation exit. This will allow us to swap in the fake page with our
	 * hook.
	 */</span>
	<span class="n">OriginalEntry</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">OriginalEntry</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">OriginalEntry</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="c1">// Apply the hook to EPT </span>
	<span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">OriginalEntry</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>
</pre></table></code></div></div><p>If we are in vmx root-mode then the TLB caches have to be invalidated.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="c1">// Invalidate the entry in the TLB caches so it will not conflict with the actual paging structure.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HasLaunched</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Uncomment in order to invalidate all the contexts</span>
		<span class="c1">// LogInfo("INVEPT Results : 0x%x\n", InveptAllContexts());</span>
		<span class="n">Descriptor</span><span class="p">.</span><span class="n">EptPointer</span> <span class="o">=</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>
		<span class="n">Descriptor</span><span class="p">.</span><span class="n">Reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">AsmInvept</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Done ! The hook is applied.</p><h2 id="handling-hooked-pages-vm-exits"><span class="mr-2"><strong>Handling hooked pages‚Äô vm-exits</strong></span><a href="#handling-hooked-pages-vm-exits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>First, we‚Äôre trying to align the Guest Physical Address (remember from the Ept Violation that we read the <strong>GUEST_PHYSICAL_ADDRESS</strong> from Vmcs). This because we‚Äôre only able to find aligned physical addresses from our EPT Table (we don‚Äôt want to iterate over them !).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>	<span class="n">PhysicalAddress</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">GuestPhysicalAddr</span><span class="p">);</span>
</pre></table></code></div></div><p>Now, as I described above, we find the PML1 entry relating to this physical address. We‚Äôre not looking for PML2 that‚Äôs because, if we reached here then we probably split 2 MB pages to 4 KB pages and we have PML1 instead of PML2.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>	<span class="n">TargetPage</span> <span class="o">=</span> <span class="n">EptGetPml1Entry</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Ensure the target is valid. </span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetPage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to get PML1 entry for target address"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Finally, we check if the violation is caused by an <strong>Execute Access</strong> (based on <strong>Exit Qualification</strong>) and the violated page has <strong>Execute Access</strong> to 0, if so, then just make the page‚Äôs entry in PML1 executable and invalidate the cache so that this modification takes effect.</p><p>Don‚Äôt forget to tell our vm-exit handler to avoid skipping the current instruction (avoid adding Instruction Length to Guest RIP) and execute it one more time as the instruction didn‚Äôt execute.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>	<span class="c1">// If the violation was due to trying to execute a non-executable page, that means that the currently</span>
	<span class="c1">// swapped in page is our original RW page. We need to swap in the hooked executable page (fake page)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ViolationQualification</span><span class="p">.</span><span class="n">EptExecutable</span> <span class="o">&amp;&amp;</span> <span class="n">ViolationQualification</span><span class="p">.</span><span class="n">ExecuteAccess</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// InveptAllContexts();</span>
		<span class="n">INVEPT_DESCRIPTOR</span> <span class="n">Descriptor</span><span class="p">;</span>

		<span class="n">Descriptor</span><span class="p">.</span><span class="n">EptPointer</span> <span class="o">=</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>
		<span class="n">Descriptor</span><span class="p">.</span><span class="n">Reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">AsmInvept</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>

		<span class="c1">// Redo the instruction </span>
		<span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IncrementRip</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Set the Execute Access of a page (PFN = 0x%llx) to 1"</span><span class="p">,</span> <span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">PageFrameNumber</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>All in all, we have the following handler.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="cm">/* Check if this exit is due to a violation caused by a currently hooked page. Returns FALSE
 * if the violation was not due to a page hook.
 *
 * If the memory access attempt was RW and the page was marked executable, the page is swapped with
 * the original page.
 *
 * If the memory access attempt was execute and the page was marked not executable, the page is swapped with
 * the hooked page.
 */</span>
<span class="n">BOOLEAN</span> <span class="nf">EptHandlePageHookExit</span><span class="p">(</span><span class="n">VMX_EXIT_QUALIFICATION_EPT_VIOLATION</span> <span class="n">ViolationQualification</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">GuestPhysicalAddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">VirtualTarget</span><span class="p">;</span>

	<span class="n">PEPT_PML1_ENTRY</span> <span class="n">TargetPage</span><span class="p">;</span>


	<span class="cm">/* Translate the page from a physical address to virtual so we can read its memory.
	   This function will return NULL if the physical address was not already mapped in
	   virtual memory.
	*/</span>
	<span class="n">PhysicalAddress</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">GuestPhysicalAddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PhysicalAddress</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Target address could not be mapped to physical memory"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TargetPage</span> <span class="o">=</span> <span class="n">EptGetPml1Entry</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Ensure the target is valid. </span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetPage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to get PML1 entry for target address"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// If the violation was due to trying to execute a non-executable page, that means that the currently</span>
	<span class="c1">// swapped in page is our original RW page. We need to swap in the hooked executable page (fake page)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ViolationQualification</span><span class="p">.</span><span class="n">EptExecutable</span> <span class="o">&amp;&amp;</span> <span class="n">ViolationQualification</span><span class="p">.</span><span class="n">ExecuteAccess</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// InveptAllContexts();</span>
		<span class="n">INVEPT_DESCRIPTOR</span> <span class="n">Descriptor</span><span class="p">;</span>

		<span class="n">Descriptor</span><span class="p">.</span><span class="n">EptPointer</span> <span class="o">=</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>
		<span class="n">Descriptor</span><span class="p">.</span><span class="n">Reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">AsmInvept</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>

		<span class="c1">// Redo the instruction </span>
		<span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IncrementRip</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Set the Execute Access of a page (PFN = 0x%llx) to 1"</span><span class="p">,</span> <span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">PageFrameNumber</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">LogError</span><span class="p">(</span><span class="s">"Invalid page swapping logic in hooked page"</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="invalidating-translations-derived-from-ept-invept"><strong>Invalidating Translations Derived from EPT (INVEPT)</strong></h1><p>Now that we implemented EPT, there is another problem here. It‚Äôs the software‚Äôs responsibility to invalidate the caches. For example, we changed the <strong>Execute access</strong> attribute of a particular page, now we have to tell the CPU that we changed something and it has to invalidate its cache, or in another way, we get EPT Violation for <strong>Execute access</strong> of a special page and now we no longer need these EPT Violations for this page. Hence, we set the <strong>Execute Access</strong> of this page to 1; thus, we have to tell our processor that we changed something in our page table. Are you confused? Let me explain it one more time.</p><p>Imagine we access the physical 0x1000, and it‚Äôll get translated to host physical address 0x1000 (based on 1:1 mapping). Next time, if we access 0x1000, the CPU won‚Äôt send the request to the memory bus but uses cached memory instead. It‚Äôs faster. Now¬†let‚Äôs say we changed the EPT <strong>Physical Address</strong> of a page to point to different EPT PD or change the attributes (<strong>R</strong>ead, <strong>W</strong>rite, E<strong>x</strong>ecute) of one of the EPT tables, now we have to tell the processor that your cache is invalid and that‚Äôs what exactly <strong>INVEPT</strong> performs.</p><p>There is a problem here; we have to separately tell each logical core that it needs to invalidate its EPT cache. In other words, each core has to execute INVEPT on its vmx root-mode. We‚Äôll solve these problems later in this part.</p><p>There are two types of TLB Invalidation for hypervisors.</p><ul><li><p>VMX-specific TLB-management instructions:</p><ul><li><p><strong>INVEPT</strong>¬†- Invalidate cached Extended Page Table (EPT) mappings in the processor to synchronize address translation in virtual machines with memory-resident EPT pages.</p><li><p><strong>INVVPID</strong>¬†- Invalidate cached mappings of address translation based on the Virtual Processor ID (VPID).</p></ul></ul><p>We‚Äôll talk about <strong>INVVPID</strong> in detail in part 8.</p><p>So in case if you wouldn‚Äôt perform INVEPT after changing EPT‚Äôs structures, you would be risking that the CPU would reuse old translations.</p><p>Any change to EPT structure needs INVEPT, but switching EPT (or VMCS) doesn‚Äôt require INVEPT because that translation will be ‚Äútagged‚Äù with the changed EPTP in the cache.</p><p>Now we have two terms here, <strong>Single-Context</strong> and <strong>All-Context</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">enum</span> <span class="n">_INVEPT_TYPE</span>
<span class="p">{</span>
	<span class="n">SINGLE_CONTEXT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">ALL_CONTEXTS</span> <span class="o">=</span> <span class="mh">0x00000002</span>
<span class="p">};</span>
</pre></table></code></div></div><p>And we have a assembly function which generally executes the INVEPT.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="p">;</span> <span class="n">Error</span> <span class="n">codes</span> <span class="o">:</span>
    <span class="n">VMX_ERROR_CODE_SUCCESS</span>              <span class="o">=</span> <span class="mi">0</span>
    <span class="n">VMX_ERROR_CODE_FAILED_WITH_STATUS</span>   <span class="o">=</span> <span class="mi">1</span>
    <span class="n">VMX_ERROR_CODE_FAILED</span>               <span class="o">=</span> <span class="mi">2</span>

<span class="n">AsmInvept</span> <span class="n">PROC</span> <span class="n">PUBLIC</span>

    <span class="n">invept</span>  <span class="n">rcx</span><span class="p">,</span> <span class="n">oword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">jz</span> <span class="err">@</span><span class="n">jz</span>
    <span class="n">jc</span> <span class="err">@</span><span class="n">jc</span>
    <span class="n">xor</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">ret</span>

    <span class="err">@</span><span class="n">jz</span><span class="o">:</span> 
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">VMX_ERROR_CODE_FAILED_WITH_STATUS</span>
    <span class="n">ret</span>

    <span class="err">@</span><span class="n">jc</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">VMX_ERROR_CODE_FAILED</span>
    <span class="n">ret</span>

<span class="n">AsmInvept</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>From the above code, RCX describes the Type (which can be one of the <strong>all-context</strong> and <strong>single-context</strong>), and RDX is the descriptor for INVEPT.</p><p>The following structure is the descriptor for INVEPT as described in Intel SDM.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_INVEPT_DESC</span>
<span class="p">{</span>
	<span class="n">EPTP</span> <span class="n">EptPointer</span><span class="p">;</span>
	<span class="n">UINT64</span>  <span class="n">Reserveds</span><span class="p">;</span>
<span class="p">}</span><span class="n">INVEPT_DESC</span><span class="p">,</span> <span class="o">*</span> <span class="n">PINVEPT_DESC</span><span class="p">;</span>
</pre></table></code></div></div><p><img data-src="../../assets/images/INVEPT-descriptor-definition.png" alt="" data-proofer-ignore></p><p>We‚Äôll use our assembly function in another function called <strong>Invept</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cm">/* Invoke the Invept instruction */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Invept</span><span class="p">(</span><span class="n">UINT32</span> <span class="n">Type</span><span class="p">,</span> <span class="n">INVEPT_DESC</span><span class="o">*</span> <span class="n">Descriptor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Descriptor</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">INVEPT_DESC</span> <span class="n">ZeroDescriptor</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
		<span class="n">Descriptor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ZeroDescriptor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">AsmInvept</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">Descriptor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It‚Äôs time to see what are so called ‚Äú<strong>All-Context</strong>‚Äúand ‚Äú<strong>Single-Context</strong>‚Äù.</p><h2 id="invalidating-all-contexts"><span class="mr-2"><strong>Invalidating All Contexts</strong></span><a href="#invalidating-all-contexts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>All-Context</strong> means that you invalidate all EPT-derived translations. (for every-VM).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cm">/* Invalidates all contexts in ept cache table */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">InveptAllContexts</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">Invept</span><span class="p">(</span><span class="n">ALL_CONTEXTS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Note: For every-VM, I mean every VM for a particular logical core; each core can have multiple VMCSs and EPT tables and switches between them. It doesn‚Äôt relate to the EPT table on other cores.</p><h2 id="invalidating-single-context"><span class="mr-2"><strong>Invalidating Single Context</strong></span><a href="#invalidating-single-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>Single-Context</strong> means that you invalidate all EPT-derived translations based on a single EPTP (in short: for a single VM in a logical core).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/* Invalidates a single context in ept cache table */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">InveptSingleContext</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">EptPointer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INVEPT_DESC</span> <span class="n">Descriptor</span> <span class="o">=</span> <span class="p">{</span> <span class="n">EptPointer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">Invept</span><span class="p">(</span><span class="n">SINGLE_CONTEXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="broadcasting-invept-to-all-logical-cores-simultaneously"><span class="mr-2"><strong>Broadcasting Invept to all logical cores simultaneously</strong></span><a href="#broadcasting-invept-to-all-logical-cores-simultaneously" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Let say you have two cores and 1 EPTP. At some point you change EPT on core one; thus you have to invalidate EPT on all cores at that point. If you remember from the previous section, we have to notify all cores to invalidate their EPT caches using something like <strong>KeIpiGenericCall</strong>, and the problem is you can‚Äôt call <strong>KeIpiGenericCall</strong> from VM-exit for apparent reasons - you shouldn‚Äôt call any NT APIs in Vm-exit. Calling this API from Vm-exit likely causes deadlock.</p><p>We can get around this by modifying APIC and creating our custom IPI call routine. We‚Äôll come across APIC virtualization in the future parts. Still, for now, if we want to change EPT for all cores, then we can call <strong>KeIpiGenericCall</strong> from regular kernel-mode (not vmx root-mode) and in that callback we perform Vmcall to tell our processor to invalidate its cache in vmx root-mode.</p><p>It‚Äôs because if we don‚Äôt immediately invalidate EPT, then we might lose some EPT Violations. This is because each logical core will have a different memory view.</p><p>If you remember from the above sections (<strong>EptPageHook</strong>), we‚Äôd checked whether the core is already on vmx operation (<strong>vmlaunch</strong> is executed). If it launched, then we used Vmcall to tell the processor about modifying EPT Table from the vmx root-mode. Right after returning from Vmcall, we called <strong>HvNotifyAllToInvalidateEpt</strong> to tell all the cores about new invalidation in their EPT caches (remember, we‚Äôre not on vmx root-mode anymore, we‚Äôre in vmx non-root mode so we can use NT APIs as it‚Äôs a regular kernel function).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">HasLaunched</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_EXEC_HOOK_PAGE</span><span class="p">,</span> <span class="n">TargetFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Hook applied from VMX Root Mode"</span><span class="p">);</span>

			<span class="c1">// Now we have to notify all the core to invalidate their EPT</span>
			<span class="n">HvNotifyAllToInvalidateEpt</span><span class="p">();</span>

			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</pre></table></code></div></div><p><strong>HvNotifyAllToInvalidateEpt</strong>, on the other hand, uses <strong>KeIpiGenericCall,</strong> and this function broadcasts <strong>HvInvalidateEptByVmcall</strong> on all the logical cores and also pass our current EPTP to this function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/* Notify all core to invalidate their EPT */</span>
<span class="n">VOID</span> <span class="nf">HvNotifyAllToInvalidateEpt</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Let's notify them all</span>
	<span class="n">KeIpiGenericCall</span><span class="p">(</span><span class="n">HvInvalidateEptByVmcall</span><span class="p">,</span> <span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>HvInvalidateEptByVmcall</strong> decides whether the caller needs an <strong>all-contexts</strong> invalidation or a <strong>single-context</strong> invalidation, and based on that, it calls the Vmcall with adequate Vmcall number. Note that our hypervisor doesn‚Äôt have multiple EPTPs, so it‚Äôs always a <strong>single-context</strong> Vmcall.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cm">/* Invalidate EPT using Vmcall (should be called from Vmx non root mode) */</span>
<span class="n">VOID</span> <span class="nf">HvInvalidateEptByVmcall</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">Context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Context</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// We have to invalidate all contexts</span>
		<span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_INVEPT_ALL_CONTEXT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// We have to invalidate all contexts</span>
		<span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_INVEPT_SINGLE_CONTEXT</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Finally, Vmcall handler calls <strong>InveptAllContexts</strong> or <strong>HvInvalidateEptByVmcall</strong> based on <strong>Vmcall number</strong> in vmx root-mode.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">VMCALL_INVEPT_SINGLE_CONTEXT</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">c</span><span class="p">(</span><span class="n">OptionalParam1</span><span class="p">);</span>
		<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">VMCALL_INVEPT_ALL_CONTEXT</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="n">InveptAllContexts</span><span class="p">();</span>
		<span class="n">VmcallStatus</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>The last thing is you can‚Äôt execute <strong>INVEPT</strong> in vmx non-root mode as it causes a Vm-exit with <strong>EXIT_REASON_INVEPT</strong> (0x32) and it doesn‚Äôt have any effect.</p><p>That‚Äôs it all for INVEPT.</p><p><img data-src="../../assets/images/anime-snowman.jpg" alt="Anime :)" data-proofer-ignore></p><h1 id="fixing-previous-design-issues"><strong>Fixing Previous Design Issues</strong></h1><p>The rest of the topic is nothing new. We want to improve our hypervisor and fix some issues from the previous parts and also support some new features and defeat some deadlocks and synchronization problems that exist in our previous parts.</p><h2 id="support-to-more-than-64-logical-cores"><span class="mr-2"><strong>Support to more than 64 logical cores</strong></span><a href="#support-to-more-than-64-logical-cores" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Previous versions of Hypervisor From Scratch has the problem of not supporting more than 32 cores (32*2 logical cores). This is because we used <strong>KeSetSystemAffinityThread,</strong> and it gives a <strong>KAFFINITY</strong> as its argument, and it‚Äôs a 64 Bit long variable mask.</p><p>We used <strong>KeSetSystemAffinityThread</strong> when we broadcast <strong>Vmptrld</strong>, <strong>Vmclear</strong>, VMCS Setup (<strong>Vmwrite</strong>), <strong>Vmlaunch</strong>, and <strong>Vmxoff</strong> to all cores.</p><p>The best approach to run on all logical cores is letting Windows (API) execute them on each core simultaneously. This involves raising IRQL on each core.</p><p>We have different options here; first, we can use <strong>KeGenericCallDpc</strong>. It‚Äôs an undocumented function which schedules CPU-specific DPCs on all CPUs.</p><p>The definition of <strong>KeGenericCallDpc</strong> is as bellow.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">KeGenericCallDpc</span><span class="p">(</span>
	<span class="n">_In_</span> <span class="n">PKDEFERRED_ROUTINE</span> <span class="n">Routine</span><span class="p">,</span>
	<span class="n">_In_opt_</span> <span class="n">PVOID</span> <span class="n">Context</span>
<span class="p">);</span>
</pre></table></code></div></div><p>The first argument is the address of the <strong>target function,</strong> which we want to execute on each core, and <strong>context</strong> is an optional parameter to this function.</p><p>In the <strong>target function</strong>, we call <strong>KeSignalCallDpcSynchronize</strong> and <strong>KeSignalCallDpcDone</strong> to avoid synchronization problems so that all the cores finish at the same time.</p><p><strong>KeSignalCallDpcSynchronize</strong> waits for all DPCs to synchronize at that point (where we call <strong>KeSignalCallDpcSynchronize</strong>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">LOGICAL</span>
<span class="nf">KeSignalCallDpcSynchronize</span><span class="p">(</span>
	<span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">SystemArgument2</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Finally, <strong>KeSignalCallDpcDone</strong> marks the DPC as being complete.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">KeSignalCallDpcDone</span><span class="p">(</span>
	<span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">SystemArgument1</span>
<span class="p">);</span>
</pre></table></code></div></div><p>The above two functions have to be executed as the last step (when everything completes) in the <strong>target function</strong>.</p><p>Another option is using <strong><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-keipigenericcall">KeIpiGenericCall</a></strong>, this routine causes the specified function to run on all processors simultaneously, and it‚Äôs documented. I used the first approach in Hypervisor From Scratch, and these updates are applied to both the initialization phase and the <strong>Vmxoff</strong> phase.</p><h2 id="synchronization-problem-in-exiting-vmx"><span class="mr-2"><strong>Synchronization problem in exiting VMX</strong></span><a href="#synchronization-problem-in-exiting-vmx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>As we now support more than 64 logical cores using DPCs, and as most of the functions are executed simultaneously, we have some problems with our previously designed routines. For example, in the previous parts, I used <strong>gGuestRSP</strong> and <strong>gGuestRIP</strong> to return to the former state. Using one global variable on all cores causes errors as one core might save its RIP and RSP (core 1), then other core (core 2) keeps the same data in these variables, When the first core (core 1) tries to restore the state, it‚Äôs the state of second core (core 2), and you‚Äôll see a BSOD :D .</p><p>In order to solve this problem, we have to store a per-core structure which saves the Guest RIP and Guest RSP. The following structure is used for this purpose.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_VMX_VMXOFF_STATE</span>
<span class="p">{</span>
	<span class="n">BOOLEAN</span> <span class="n">IsVmxoffExecuted</span><span class="p">;</span>					<span class="c1">// Shows whether the VMXOFF executed or not</span>
	<span class="n">UINT64</span>  <span class="n">GuestRip</span><span class="p">;</span>							<span class="c1">// Rip address of guest to return</span>
	<span class="n">UINT64</span>  <span class="n">GuestRsp</span><span class="p">;</span>							<span class="c1">// Rsp address of guest to return</span>

<span class="p">}</span> <span class="n">VMX_VMXOFF_STATE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PVMX_VMXOFF_STATE</span><span class="p">;</span>
</pre></table></code></div></div><p>We add the above structure to <strong>VIRTUAL_MACHINE_STATE</strong> as it‚Äôs a per-core structure.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_VIRTUAL_MACHINE_STATE</span>
<span class="p">{</span>
<span class="p">...</span>
	<span class="n">VMX_VMXOFF_STATE</span> <span class="n">VmxoffState</span><span class="p">;</span>									<span class="c1">// Shows the vmxoff state of the guest</span>
<span class="p">...</span>
<span class="p">}</span> <span class="n">VIRTUAL_MACHINE_STATE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PVIRTUAL_MACHINE_STATE</span><span class="p">;</span>
</pre></table></code></div></div><p>We need to broadcast <strong>Vmxoff</strong> to all of the logical cores. This is done by using the <strong>HvTerminateVmx</strong>; this function is called once and broadcast <strong>HvDpcBroadcastTerminateGuest</strong> to all logical cores and de-allocates (free) all the EPT related tables and pre-allocated buffers.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cm">/* Terminate Vmx on all logical cores. */</span>
<span class="n">VOID</span> <span class="nf">HvTerminateVmx</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Broadcast to terminate Vmx</span>
	<span class="n">KeGenericCallDpc</span><span class="p">(</span><span class="n">HvDpcBroadcastTerminateGuest</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

	<span class="cm">/* De-allocatee global variables */</span>

	<span class="c1">// Free each split </span>
	<span class="n">FOR_EACH_LIST_ENTRY</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">DynamicSplitList</span><span class="p">,</span> <span class="n">VMM_EPT_DYNAMIC_SPLIT</span><span class="p">,</span> <span class="n">Split</span><span class="p">)</span>
		<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">Split</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
	<span class="n">FOR_EACH_LIST_ENTRY_END</span><span class="p">();</span>

	<span class="c1">// Free Identity Page Table</span>
	<span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">);</span>

	<span class="c1">// Free GuestState</span>
	<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">GuestState</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>

	<span class="c1">// Free EptState</span>
	<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">EptState</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>

<span class="p">}</span>
</pre></table></code></div></div><p><strong>HvDpcBroadcastTerminateGuest</strong> is responsible for synchronizing DPCs and calling a VMX function call <strong>VmxTerminate</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cm">/* The broadcast function which terminate the guest. */</span>
<span class="n">VOID</span> <span class="nf">HvDpcBroadcastTerminateGuest</span><span class="p">(</span><span class="k">struct</span> <span class="n">_KDPC</span><span class="o">*</span> <span class="n">Dpc</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">DeferredContext</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">SystemArgument1</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">SystemArgument2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Terminate Vmx using Vmcall</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VmxTerminate</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"There were an error terminating Vmx"</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// Wait for all DPCs to synchronize at this point</span>
	<span class="n">KeSignalCallDpcSynchronize</span><span class="p">(</span><span class="n">SystemArgument2</span><span class="p">);</span>

	<span class="c1">// Mark the DPC as being complete</span>
	<span class="n">KeSignalCallDpcDone</span><span class="p">(</span><span class="n">SystemArgument1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>VmxTerminate</strong> de-allocates per-core allocated regions like the Vmxon region, Vmcs region, Vmm Stack, and Msr Bitmap. As we implemented our Vmcall mechanism, we can use Vmcall to request a <strong>vmxoff</strong> from the vmx root mode (instead of what we‚Äôve done in the previous version with CPUID Handler). So it executes <strong>AsmVmxVmcall</strong> with <strong>VMCALL_VMXOFF</strong> on each core, and each core will run <strong>vmxoff</strong> separately.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cm">/* Broadcast to terminate VMX on all logical cores */</span>
<span class="n">BOOLEAN</span> <span class="nf">VmxTerminate</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">CurrentCoreIndex</span><span class="p">;</span>
	<span class="n">NTSTATUS</span> <span class="n">Status</span><span class="p">;</span>

	<span class="c1">// Get the current core index</span>
	<span class="n">CurrentCoreIndex</span> <span class="o">=</span> <span class="n">KeGetCurrentProcessorNumber</span><span class="p">();</span>

	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Terminating VMX on logical core %d"</span><span class="p">,</span> <span class="n">CurrentCoreIndex</span><span class="p">);</span>

	<span class="c1">// Execute Vmcall to to turn off vmx from Vmx root mode</span>
	<span class="n">Status</span> <span class="o">=</span> <span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_VMXOFF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Free the destination memory</span>
	<span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentCoreIndex</span><span class="p">].</span><span class="n">VmxonRegionVirtualAddress</span><span class="p">);</span>
	<span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentCoreIndex</span><span class="p">].</span><span class="n">VmcsRegionVirtualAddress</span><span class="p">);</span>
	<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentCoreIndex</span><span class="p">].</span><span class="n">VmmStack</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
	<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentCoreIndex</span><span class="p">].</span><span class="n">MsrBitmapVirtualAddress</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">Status</span> <span class="o">==</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Our Vmcall handler calls <strong>VmxVmxoff,</strong> and as this function is executed under vmx root-mode, so it‚Äôs allowed to run <strong>VMXOFF</strong>. This function also saves the <strong>GuestRip</strong> and <strong>GuestRsp</strong> into the per-core <strong>VMX_VMXOFF_STATE</strong> structure. This is where we solved the problem as we‚Äôre not using a shared global variable anymore. It also sets <strong>IsVmxoffExecuted,</strong> which indicates whether the logical core is on VMX operation or it left the VMX operation by executing <strong>VMXOFF</strong>.</p><p>The <strong>VmxVmxoff</strong> is implemented like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="cm">/* Prepare and execute Vmxoff instruction */</span>
<span class="n">VOID</span> <span class="nf">VmxVmxoff</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">CurrentProcessorIndex</span><span class="p">;</span>
	<span class="n">UINT64</span> <span class="n">GuestRSP</span><span class="p">;</span> 	<span class="c1">// Save a pointer to guest rsp for times that we want to return to previous guest stateS</span>
	<span class="n">UINT64</span> <span class="n">GuestRIP</span><span class="p">;</span> 	<span class="c1">// Save a pointer to guest rip for times that we want to return to previous guest state</span>
	<span class="n">UINT64</span> <span class="n">GuestCr3</span><span class="p">;</span>
	<span class="n">UINT64</span> <span class="n">ExitInstructionLength</span><span class="p">;</span>


	<span class="c1">// Initialize the variables</span>
	<span class="n">ExitInstructionLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">GuestRIP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">GuestRSP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">CurrentProcessorIndex</span> <span class="o">=</span> <span class="n">KeGetCurrentProcessorNumber</span><span class="p">();</span>

	<span class="cm">/*
	According to SimpleVisor :
		Our callback routine may have interrupted an arbitrary user process,
		and therefore not a thread running with a system-wide page directory.
		Therefore if we return back to the original caller after turning off
		VMX, it will keep our current "host" CR3 value which we set on entry
		to the PML4 of the SYSTEM process. We want to return back with the
		correct value of the "guest" CR3, so that the currently executing
		process continues to run with its expected address space mappings.
	*/</span>

	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestCr3</span><span class="p">);</span>
	<span class="n">__writecr3</span><span class="p">(</span><span class="n">GuestCr3</span><span class="p">);</span>

	<span class="c1">// Read guest rsp and rip</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestRIP</span><span class="p">);</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestRSP</span><span class="p">);</span>

	<span class="c1">// Read instruction length</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitInstructionLength</span><span class="p">);</span>
	<span class="n">GuestRIP</span> <span class="o">+=</span> <span class="n">ExitInstructionLength</span><span class="p">;</span>

	<span class="c1">// Set the previous registe states</span>
	<span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">VmxoffState</span><span class="p">.</span><span class="n">GuestRip</span> <span class="o">=</span> <span class="n">GuestRIP</span><span class="p">;</span>
	<span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">VmxoffState</span><span class="p">.</span><span class="n">GuestRsp</span> <span class="o">=</span> <span class="n">GuestRSP</span><span class="p">;</span>

	<span class="c1">// Notify the Vmexit handler that VMX already turned off</span>
	<span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">VmxoffState</span><span class="p">.</span><span class="n">IsVmxoffExecuted</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="c1">// Execute Vmxoff</span>
	<span class="n">__vmx_off</span><span class="p">();</span>

<span class="p">}</span>
</pre></table></code></div></div><p>As we return to vm-exit handler, we check whether we left the VMX opeation or not.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">VmxoffState</span><span class="p">.</span><span class="n">IsVmxoffExecuted</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>We also define two other functions called ‚Äú<strong>HvReturnStackPointerForVmxoff</strong>‚Äù and ‚Äú<strong>HvReturnInstructionPointerForVmxoff</strong>‚Äù, which find the logical core index and returns the corresponding stack pointer and RIP to return.</p><p><strong>HvReturnStackPointerForVmxoff</strong> is :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cm">/* Returns the stack pointer, to change in the case of Vmxoff */</span>
<span class="n">UINT64</span> <span class="nf">HvReturnStackPointerForVmxoff</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">VmxoffState</span><span class="p">.</span><span class="n">GuestRsp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And <strong>HvReturnInstructionPointerForVmxoff</strong> is:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cm">/* Returns the instruction pointer, to change in the case of Vmxoff */</span>
<span class="n">UINT64</span> <span class="nf">HvReturnInstructionPointerForVmxoff</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">VmxoffState</span><span class="p">.</span><span class="n">GuestRip</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Eventually, when we detect that we left the vmx operation, instead of executing <strong>VMRESUME</strong> we‚Äôll run <strong>AsmVmxoffHandler</strong>, this function calls the <strong>HvReturnStackPointerForVmxoff</strong> and <strong>HvReturnInstructionPointerForVmxoff</strong> and puts the value of RSP and RIP after the general-purpose registers thus when we restore the general-purpose registers, we can pop the RSP from the stack and return to the previous address (<strong>ret</strong>) and continue normal execution.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre>
<span class="n">AsmVmxoffHandler</span> <span class="n">PROC</span>
    
    <span class="n">sub</span> <span class="n">rsp</span><span class="p">,</span> <span class="mo">020</span><span class="n">h</span>       <span class="p">;</span> <span class="n">shadow</span> <span class="n">space</span>
    <span class="n">call</span> <span class="n">HvReturnStackPointerForVmxoff</span>
    <span class="n">add</span> <span class="n">rsp</span><span class="p">,</span> <span class="mo">020</span><span class="n">h</span>       <span class="p">;</span> <span class="n">remove</span> <span class="k">for</span> <span class="n">shadow</span> <span class="n">space</span>

    <span class="n">mov</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">088</span><span class="n">h</span><span class="p">],</span> <span class="n">rax</span>  <span class="p">;</span> <span class="n">now</span><span class="p">,</span> <span class="n">rax</span> <span class="n">contains</span> <span class="n">rsp</span>

    <span class="n">sub</span> <span class="n">rsp</span><span class="p">,</span> <span class="mo">020</span><span class="n">h</span>       <span class="p">;</span> <span class="n">shadow</span> <span class="n">space</span>
    <span class="n">call</span> <span class="n">HvReturnInstructionPointerForVmxoff</span>
    <span class="n">add</span> <span class="n">rsp</span><span class="p">,</span> <span class="mo">020</span><span class="n">h</span>       <span class="p">;</span> <span class="n">remove</span> <span class="k">for</span> <span class="n">shadow</span> <span class="n">space</span>

    <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rsp</span>        <span class="p">;</span> <span class="n">save</span> <span class="n">current</span> <span class="n">rsp</span>

    <span class="n">mov</span> <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">088</span><span class="n">h</span><span class="p">]</span> <span class="p">;</span> <span class="n">read</span> <span class="n">rsp</span> <span class="n">again</span>

    <span class="n">mov</span> <span class="n">rsp</span><span class="p">,</span> <span class="n">rbx</span>

    <span class="n">push</span> <span class="n">rax</span>            <span class="p">;</span> <span class="n">push</span> <span class="n">the</span> <span class="k">return</span> <span class="n">address</span> <span class="n">as</span> <span class="n">we</span> <span class="n">changed</span> <span class="n">the</span> <span class="n">stack</span><span class="p">,</span> <span class="n">we</span> <span class="n">push</span>
                        <span class="p">;</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">new</span> <span class="n">stack</span>

    <span class="n">mov</span> <span class="n">rsp</span><span class="p">,</span> <span class="n">rdx</span>        <span class="p">;</span> <span class="n">restore</span> <span class="n">previous</span> <span class="n">rsp</span>
                        
    <span class="n">sub</span> <span class="n">rbx</span><span class="p">,</span><span class="mi">08</span><span class="n">h</span>         <span class="p">;</span> <span class="n">we</span> <span class="n">push</span> <span class="n">sth</span><span class="p">,</span> <span class="n">so</span> <span class="n">we</span> <span class="n">have</span> <span class="n">to</span> <span class="n">add</span> <span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">+</span><span class="mi">8</span> <span class="n">from</span> <span class="n">previous</span> <span class="n">stack</span>
                        <span class="p">;</span> <span class="n">also</span> <span class="n">rbx</span> <span class="n">already</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">rsp</span>
    <span class="n">mov</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">088</span><span class="n">h</span><span class="p">],</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">move</span> <span class="n">the</span> <span class="n">new</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">stack</span>

	<span class="n">RestoreState</span><span class="o">:</span>

	<span class="n">pop</span> <span class="n">rax</span>
    <span class="n">pop</span> <span class="n">rcx</span>
    <span class="n">pop</span> <span class="n">rdx</span>
    <span class="n">pop</span> <span class="n">rbx</span>
    <span class="n">pop</span> <span class="n">rbp</span>		         <span class="p">;</span> <span class="n">rsp</span>
    <span class="n">pop</span> <span class="n">rbp</span>
    <span class="n">pop</span> <span class="n">rsi</span>
    <span class="n">pop</span> <span class="n">rdi</span> 
    <span class="n">pop</span> <span class="n">r8</span>
    <span class="n">pop</span> <span class="n">r9</span>
    <span class="n">pop</span> <span class="n">r10</span>
    <span class="n">pop</span> <span class="n">r11</span>
    <span class="n">pop</span> <span class="n">r12</span>
    <span class="n">pop</span> <span class="n">r13</span>
    <span class="n">pop</span> <span class="n">r14</span>
    <span class="n">pop</span> <span class="n">r15</span>

    <span class="n">popfq</span>

	<span class="n">pop</span>		<span class="n">rsp</span>     <span class="p">;</span> <span class="n">restore</span> <span class="n">rsp</span>
	<span class="n">ret</span>             <span class="p">;</span> <span class="n">jump</span> <span class="n">back</span> <span class="n">to</span> <span class="n">where</span> <span class="n">we</span> <span class="n">called</span> <span class="n">Vmcall</span>

<span class="n">AsmVmxoffHandler</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>As you can see, we no longer have the problem of using a global variable among all the cores.</p><h2 id="the-issues-relating-to-the-meltdown-mitigation"><span class="mr-2"><strong>The issues relating to the Meltdown mitigation</strong></span><a href="#the-issues-relating-to-the-meltdown-mitigation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>As you know, <strong>EXIT_REASON_CR_ACCESS</strong> is one of the reasons that might cause VM-Exit (Especially if you‚Äôre subject to 1-setting of CRs in your VMCS). Hypervisors used to save all the general-purpose registers every time a VM-Exit occurs and then restore it at the next VMRESUME.</p><p>In the previous versions of our driver, we ignored RSP and save some trash instead of it, that‚Äôs because RSP of guest is already saved in <strong>GUEST_RSP</strong> in VMCS. After <strong>VMRESUME</strong>, it‚Äôs loaded automatically, and you know, our current RSP is invalid (it‚Äôs host RSP).</p><p>After meltdown mitigation, Windows uses <strong>MOV CR3, RSP</strong>, and as we saved trash instead of RSP, then you change <strong>CR3</strong> to an invalid value, and it silently crashes with <em>TRIPLE FAULT</em> VM-Exit. It won‚Äôt give you the exact error.</p><p><img data-src="../../assets/images/rsp-problem-1.png" alt="" data-proofer-ignore></p><p>For fixing this issue, we add the following code to <strong>HvHandleControlRegisterAccess,</strong> so each time when a vm-exit occurs, we change the RSP to the correct value.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>	<span class="cm">/* Because its RSP and as we didn't save RSP correctly (because of pushes) so we have make it points to the GUEST_RSP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CrExitQualification</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">Register</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestRsp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">RegPtr</span> <span class="o">=</span> <span class="n">GuestRsp</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Previously, this was mentioned by <a href="https://twitter.com/aionescu/status/1148309739136311296">Alex</a>, for more information, you can read <a href="https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/">this</a> article.</p><h1 id="some-tips-for-debugging-hypervisors"><strong>Some tips for debugging hypervisors</strong></h1><p>Always try to test your hypervisor in a uni-core system. If it works then, you can check it on a multi-core, so when something doesn‚Äôt work on multi-core and works on uni-core, then know that it‚Äôs a synchronization problem.</p><p>Don‚Äôt try to call Nt functions in Vmx root mode. Most of NT functions are not suitable to run in a high IRQL, so if you use it, it leads to weird behavior and crashes the whole or system is halted.</p><p>For more information, I really recommend reading Hyperplatform‚Äôs User Document (<a href="https://tandasat.github.io/HyperPlatform/userdocument/">4.4.¬†Coding Tips</a>).</p><h1 id="lets-test-it"><strong>Let‚Äôs Test it!</strong></h1><p>Let‚Äôs see how we can test our hypervisor,</p><h2 id="how-to-test"><span class="mr-2"><strong>How to test?</strong></span><a href="#how-to-test" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In order to test our new hypervisor, we have two scenarios, and the following codes show how we test our hypervisor, the codes for tests are available at (<strong>Ept.c</strong> and <strong>HypervisorRoutines.c</strong>).</p><p>In the first scenario, we want to test page hook (<strong>EptPageHook</strong>) before executing <strong>vmlaunch</strong>, which means that Ept is initialized, and then we want to put the hook before entering VMX. (the test code is on <strong>Ept.c</strong>)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="c1">///////////////////////// Example Test /////////////////////////</span>
	 <span class="n">EptPageHook</span><span class="p">(</span><span class="n">ExAllocatePoolWithTag</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
	<span class="c1">///////////////////////////////////////////////////////////////</span>
</pre></table></code></div></div><p>The above function puts hook on the execution of a page containing a function (in this case <strong>ExAllocatePoolWithTag</strong>).</p><p>The second scenario is we want to test both VMCALL and <strong>EptPageHook</strong> after our hypervisor is loaded, and we‚Äôre in Vmx non-root mode (the test code is on <strong>HypervisorRoutines.c</strong>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="c1">//  Check if everything is ok then return true otherwise false</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AsmVmxVmcall</span><span class="p">(</span><span class="n">VMCALL_TEST</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x333</span><span class="p">,</span> <span class="mh">0x4444</span><span class="p">)</span> <span class="o">==</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">///////////////// Test Hook after Vmx is launched /////////////////</span>
		<span class="n">EptPageHook</span><span class="p">(</span><span class="n">ExAllocatePoolWithTag</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="c1">///////////////////////////////////////////////////////////////////</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, it first tests the <strong>Vmcall</strong> using <strong>VMCALL_TEST</strong> and then puts the hook to a function (in this case <strong>ExAllocatePoolWithTag</strong>).</p><h2 id="demo"><span class="mr-2"><strong>Demo</strong></span><a href="#demo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>First, we load our hypervisor driver,</p><p><img data-src="../../assets/images/hvfs-part7-demo1.png" alt="Driver is loaded an Hv started" data-proofer-ignore></p><p>For the first scenario, you can see that we successfully notified about the execution of <strong>ExAllocatePoolWith</strong> tag after <strong>vmlaunch</strong> executed, and <strong>Guest Rip</strong> is equal to the address of <strong>ExAllocatePoolWithTag</strong> and <strong>EptHandleEptViolation</strong> is responsible for handling Ept violations.</p><p><img data-src="../../assets/images/hvfs-part7-demo2.png" alt="Ept Hook Before Vmlaunch" data-proofer-ignore></p><p>In the second testing scenario, you can see that our VMCALL is successfully executed (green line), and we notified about the execution of a page, but wait, we put our <strong>Execute Access</strong> hook on <strong>ExAllocatePoolWithTag</strong>, but the <strong>Guest Rip</strong> is equal to <strong>ExFreePool</strong>, Why?</p><p>It turns out that <strong>ExAllocatePoolWithTag</strong> and <strong>ExFreePool</strong> are both on the same page, and <strong>ExFreePool</strong> is executed earlier than <strong>ExAllocatePoolWithTag,</strong> so we get the execution of this function.</p><p><img data-src="../../assets/images/hvfs-part7-demo3.png" alt="Ept Hook after Vmlaunch" data-proofer-ignore></p><p>The above test results show the importance of checking Guest Rip in the EPT violation handler. We‚Äôll talk about it in the next part.</p><p>Finally, you can see the following picture which shows whether our hook successfully applied or not.</p><p><img data-src="../../assets/images/hvfs-part7-demo4.png" alt="Ept hook applied from Vmx Root Mode" data-proofer-ignore></p><h1 id="discussion"><strong>Discussion</strong></h1><p>This part is added to answer to questions about EPT, we‚Äôll discuss different approaches and pros and cons of them. Thanks to Petr for answering these questions.</p><p><strong>1. Why there are limitations on calling NT functions in VMX Root Mode?</strong></p><p>It is because of paging and high IRQL. The reason is what explained <a href="https://stackoverflow.com/questions/18764211/why-we-can-access-memory-from-non-paged-pool-at-or-above-dispatch-level">here</a> for the high IRQL and as we‚Äôre in a high IRQL in Vmx root mode then some pages(paged pools) might be paged-out.</p><p>The hypervisor can use a completely different address space than the NT kernel, I believe this is what regular hypervisors like Hyper-V/XEN do. They don‚Äôt use ‚Äú<strong>identity EPT mapping</strong>‚Äù, therefore VA 0x10000 in VMX-root mode does not point to the same physical memory as 0x10000 in VMX non-root mode.</p><p>For example, let‚Äôs pick an NT function that can be called at HIGH_IRQL (<strong>MmGetPhysicalAddress</strong>). Let‚Äôs imagine this function is on virtual address 0x1234, but this virtual address points to that function in VMX non-root, in ntoskrnl address space.</p><p>The real question should be: ‚ÄúWhy can I call some NT functions in VMX-root mode‚Äù the answer is that you set <strong>HOST_CR3</strong> in VMCS to be the same as CR3 of the NT main System process, therefore hypervisor in vmx root-mode share the same memory view as VMX non-root mode.</p><p>It is important to know this, in practice for self-virtualizing hypervisors (like hyperplatform/hvpp), you don‚Äôt care, because as I said your <strong>HOST_CR3</strong> is the same as NT‚Äôs <strong>CR3</strong>, therefore you can touch whatever memory you want.</p><p>If you happened to work on HyperV or XEN, you don‚Äôt have the same luxury. the hypervisor memory address space is not mapped at all in the virtualized OS (that‚Äôs quite the point of virtualization).</p><p><strong>2. Why we shouldn‚Äôt modify EPT in VMX Non-Root?</strong></p><p>In the ideal world, no memory of the hypervisor should be visible from the virtualized OS (you cant see XEN internals from the virtualized OS for example).</p><p>in hyperplatform/hvpp, you can see the memory of the hypervisor. Why? This time it‚Äôs not because of <strong>HOST_CR3</strong> but because of identity EPT mapping - you set EPT tables in such a way, that the virtualized OS can see even the memory of the hypervisor itself.</p><p>My point is - in the ideal world you shouldn‚Äôt even see the EPT structures from within the VMX non-root mode, imagine it this way, can you modify regular page-tables from user-mode?</p><p>The answer is it depends. In reality? No. Why? because the page-tables are in kernel memory that is inaccessible from the user-mode. That‚Äôs the whole point of memory protection. Could you set page tables in such a way that it would be possible to modify them from user-mode? Yes, but it doesn‚Äôt mean you should though. This is sort of a security thing.</p><p>There‚Äôs one even more important reason: caches</p><p>Now you might have tried it and it worked most of the time in your case but that doesn‚Äôt mean it‚Äôs the correct approach.</p><p><strong>3. What are the advantages of having EPT table for each processor separately?</strong></p><p>When you change EPT structures and you want that change to be synced across CPUs, you have to perform IPI (<strong>KeIpiGenericCall</strong>) from within VMX root mode to flush caches on all CPUs.</p><p>In an ideal world, you would call <strong>KeIpiGenericCall</strong> from VMX-root mode. but you can‚Äôt - you‚Äôll fastly end up in a deadlock. You‚Äôd need to implement your own IPI mechanism and set correctly APIC for VMX-root mode.</p><p>Now this can be done - but it would be non-trivial to implement.</p><p>When you have multiple EPTs for each CPU, you don‚Äôt have to do IPIs, each core manages its own EPT.</p><p>Now they won‚Äôt be 100% synced all the time, but if the EPT handler logic is the same for each core and doesn‚Äôt change over time, it doesn‚Äôt matter.</p><h1 id="conclusion"><strong>Conclusion</strong></h1><p>We come to the end of this part. I believe EPT is the most important feature that can be used by researchers, security programs and game hackers as it gives a unique ability to monitor the operating system and user-mode applications. In the next part, we‚Äôll be using EPT and implement hidden hook mechanisms, which commonly used among hypervisors. Also, we‚Äôll improve our hypervisor by using WPP Tracing instead of using DbgPrint, event injection, and a mechanism to talk from Vmx root-mode to Vmx non-root mode and finally we‚Äôll see how to use Virtual Processor Identifier (VPID). Feel free to use the comments below to ask questions or ask for clarification.</p><p>See you guys in the next part.</p><p>The 8th part is available <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-8/">here</a>.</p><p><img data-src="../../assets/images/anime-girl-walking-moon.jpeg" alt="Animmmmeee :)" data-proofer-ignore></p><h1 id="references"><strong>References</strong></h1><p>[1] Memory type range register - (<a href="https://en.wikipedia.org/wiki/Memory_type_range_register">https://en.wikipedia.org/wiki/Memory_type_range_register</a>)<br /> [2] KVA Shadow: Mitigating Meltdown on Windows - (<a href="https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/">https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/</a>)<br /> [3] How to Implement a software-based SMEP(Supervisor Mode Execution Protection) with Virtualization/Hypervisor Technology - (<a href="http://hypervsir.blogspot.com/2014/11/how-to-implement-software-based.html">http://hypervsir.blogspot.com/2014/11/how-to-implement-software-based.html</a>)<br /> [4] Vol 3A ‚Äì Chapter 11 ‚Äì (11.11.3 Example Base and Mask Calculations) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [5] x86 Paging Tutorial - (<a href="https://cirosantilli.com/x86-paging">https://cirosantilli.com/x86-paging</a>)<br /> [6] OSDev notes 2: Memory management - (<a href="http://ethv.net/workshops/osdev/notes/notes-2">http://ethv.net/workshops/osdev/notes/notes-2</a>)<br /> [7] Vol 3A ‚Äì Chapter 11 ‚Äì (11.11 MEMORY TYPE RANGE REGISTERS (MTRRS)) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [8] Vol 3A ‚Äì Chapter 11 ‚Äì (11.12 PAGE ATTRIBUTE TABLE (PAT)) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [9] HyperPlatform User Document - (<a href="https://software.intel.com/en-us/articles/intel-sdm"></a><a href="https://tandasat.github.io/HyperPlatform/userdocument/">https://tandasat.github.io/HyperPlatform/userdocument/</a>)<br /> [10] Vol 3C ‚Äì Chapter 34‚Äì (34.15.2 SMM VM Exits) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [11] Vol 3C ‚Äì Chapter 34‚Äì (34.15.6 Activating the Dual-Monitor Treatment) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [12] Windows Hotpatching: A Walkthrough - (<a href="https://software.intel.com/en-us/articles/intel-sdm"></a><a href="https://jpassing.com/2011/05/03/windows-hotpatching-a-walkthrough/">https://jpassing.com/2011/05/03/windows-hotpatching-a-walkthrough/</a>)<br /> [13] Vol 3C ‚Äì Chapter 28‚Äì (28.2.3.1 EPT Misconfigurations) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [14] Vol 3C ‚Äì Chapter 28‚Äì (28.2.3.2 EPT Violations) - (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [15] R.I.P ROP: CET Internals in Windows 20H1 - (<a href="http://windows-internals.com/cet-on-windows/">http://windows-internals.com/cet-on-windows</a>)<br /> [16] Inside Windows Page Frame Number (PFN) Part 1 - (<a href="http://windows-internals.com/cet-on-windows/"></a><a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part1/">https://rayanfam.com/topics/inside-windows-page-frame-number-part1</a>)<br /> [17] Inside Windows Page Frame Number (PFN) Part 2 - (<a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part2/">https://rayanfam.com/topics/inside-windows-page-frame-number-part2</a>)<br /> [18] why we can access memory from non paged pool at or above DISPATCH LEVEL - (<a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part2/"></a><a href="https://stackoverflow.com/questions/18764211/why-we-can-access-memory-from-non-paged-pool-at-or-above-dispatch-level">https://stackoverflow.com/questions/18764211/why-we-can-access-memory-from-non-paged-pool-at-or-above-dispatch-level</a>)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cpu/'>cpu</a>, <a href='/categories/hypervisor/'>hypervisor</a>, <a href='/categories/tutorials/'>tutorials</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hypervisor/" class="post-tag no-text-decoration" >hypervisor</a> <a href="/tags/2mb-ept/" class="post-tag no-text-decoration" >2mb-ept</a> <a href="/tags/4kb-ept/" class="post-tag no-text-decoration" >4kb-ept</a> <a href="/tags/ept-hook/" class="post-tag no-text-decoration" >ept-hook</a> <a href="/tags/ept-monitoring/" class="post-tag no-text-decoration" >ept-monitoring</a> <a href="/tags/ept-table/" class="post-tag no-text-decoration" >ept-table</a> <a href="/tags/extended-page-table/" class="post-tag no-text-decoration" >extended-page-table</a> <a href="/tags/extended-page-table-pointer/" class="post-tag no-text-decoration" >extended-page-table-pointer</a> <a href="/tags/hidden-hook/" class="post-tag no-text-decoration" >hidden-hook</a> <a href="/tags/hypervisor-tutorial-part-7/" class="post-tag no-text-decoration" >hypervisor-tutorial-part-7</a> <a href="/tags/intel-vt-x-paging/" class="post-tag no-text-decoration" >intel-vt-x-paging</a> <a href="/tags/invalidate-ept/" class="post-tag no-text-decoration" >invalidate-ept</a> <a href="/tags/invept/" class="post-tag no-text-decoration" >invept</a> <a href="/tags/memory-type-range-register/" class="post-tag no-text-decoration" >memory-type-range-register</a> <a href="/tags/mmu-virtualization/" class="post-tag no-text-decoration" >mmu-virtualization</a> <a href="/tags/mtrr/" class="post-tag no-text-decoration" >mtrr</a> <a href="/tags/second-level-address-translation/" class="post-tag no-text-decoration" >second-level-address-translation</a> <a href="/tags/slat/" class="post-tag no-text-decoration" >slat</a> <a href="/tags/vmcall/" class="post-tag no-text-decoration" >vmcall</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Hypervisor From Scratch ‚Äì Part 7: Using EPT &amp; Page-Level Monitoring Features - Rayanfam Blog&amp;url=https://rayanfam.com/topics/hypervisor-from-scratch-part-7/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Hypervisor From Scratch ‚Äì Part 7: Using EPT &amp; Page-Level Monitoring Features - Rayanfam Blog&amp;u=https://rayanfam.com/topics/hypervisor-from-scratch-part-7/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://rayanfam.com/topics/hypervisor-from-scratch-part-7/&amp;text=Hypervisor From Scratch ‚Äì Part 7: Using EPT &amp; Page-Level Monitoring Features - Rayanfam Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/topics/hypervisor-from-scratch-part-1/">Hypervisor From Scratch - Part 1: Basic Concepts & Configure Testing Environment</a><li><a href="/topics/hypervisor-from-scratch-part-2/">Hypervisor From Scratch ‚Äì Part 2: Entering VMX Operation</a><li><a href="/topics/hypervisor-from-scratch-part-5/">Hypervisor From Scratch ‚Äì Part 5: Setting up VMCS & Running Guest Code</a><li><a href="/topics/hypervisor-from-scratch-part-6/">Hypervisor From Scratch ‚Äì Part 6: Virtualizing An Already Running System</a><li><a href="/topics/hypervisor-from-scratch-part-7/">Hypervisor From Scratch ‚Äì Part 7: Using EPT & Page-Level Monitoring Features</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/topics/hypervisor-from-scratch-part-4/"><div class="card-body"> <em class="timeago small" data-ts="1538697600" > 2018-10-05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch ‚Äì Part 4: Address Translation Using Extended Page Table (EPT)</h3><div class="text-muted small"><p> If you‚Äôre looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It‚Äôs a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-8/"><div class="card-body"> <em class="timeago small" data-ts="1585008000" > 2020-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch ‚Äì Part 8: How To Do Magic With Hypervisor!</h3><div class="text-muted small"><p> If you‚Äôre looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It‚Äôs a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-5/"><div class="card-body"> <em class="timeago small" data-ts="1544918400" > 2018-12-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch ‚Äì Part 5: Setting up VMCS & Running Guest Code</h3><div class="text-muted small"><p> If you‚Äôre looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It‚Äôs a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/topics/reversing-windows-internals-part1/" class="btn btn-outline-primary" prompt="Older"><p>Reversing Windows Internals (Part 1) - Digging Into Handles, Callbacks & ObjectTypes</p></a> <a href="/topics/hypervisor-from-scratch-part-8/" class="btn btn-outline-primary" prompt="Newer"><p>Hypervisor From Scratch ‚Äì Part 8: How To Do Magic With Hypervisor!</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://rayanfam.com/topics/hypervisor-from-scratch-part-7/'; this.page.identifier = '/topics/hypervisor-from-scratch-part-7/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://rayanfam.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> ¬© 2024 <a href="https://github.com/rayanfam">Rayanfam Blog</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-P6M1BDG57Z"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-P6M1BDG57Z'); }); </script>
