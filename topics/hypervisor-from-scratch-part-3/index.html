<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine" /><meta name="author" content="Sina Karvandi" /><meta property="og:locale" content="en" /><meta name="description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><meta property="og:description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><link rel="canonical" href="https://rayanfam.com/topics/hypervisor-from-scratch-part-3/" /><meta property="og:url" content="https://rayanfam.com/topics/hypervisor-from-scratch-part-3/" /><meta property="og:site_name" content="Rayanfam Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-09-15T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine" /><meta name="twitter:site" content="@Intel80x86" /><meta name="twitter:creator" content="@Sina Karvandi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sina Karvandi"},"dateModified":"2024-07-13T13:14:26+00:00","datePublished":"2018-09-15T00:00:00+00:00","description":"We write about Windows Internals, Hypervisors, Linux, and Networks.","headline":"Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine","mainEntityOfPage":{"@type":"WebPage","@id":"https://rayanfam.com/topics/hypervisor-from-scratch-part-3/"},"url":"https://rayanfam.com/topics/hypervisor-from-scratch-part-3/"}</script><title>Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine | Rayanfam Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Rayanfam Blog"><meta name="application-name" content="Rayanfam Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/images/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Rayanfam Blog</a></div><div class="site-subtitle font-italic">An aggressive out-of-order, superscalar blog...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tutorials/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TUTORIALS</span> </a><li class="nav-item"> <a href="/tools/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TOOLS & SCRIPTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/rayanfam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Intel80x86" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sina','rayanfam.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Intel80x86">Sina Karvandi</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1536969600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2018-09-15 </em> </span> <span> Updated <em class="timeago" data-ts="1720876466" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-07-13 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4753 words"> <em>26 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="../../assets/images/hypervisor-from-scratch-3-cover.png" alt="" data-proofer-ignore></p><p><strong>If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out <a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and reversing applications. A free and comprehensive tutorial on hypervisor-based reverse engineering is available at <a href="https://ost2.fyi/dbg3301">OpenSecurityTraining2’s website</a> (<em>preferred</em>) and <a href="https://www.youtube.com/playlist?list=PLUFkSN0XLZ-kF1f143wlw8ujlH2A45nZY">YouTube</a>, which demonstrates numerous practical examples on how to utilize hypervisors for reverse engineering.</strong></p><h2 id="introduction"><span class="mr-2"><strong>Introduction</strong></span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>This is the third part of the tutorial “<strong>Hypervisor From Scratch</strong>”. In this part, we’ll continue our journey toward learning hypervisors and how to start creating our custom VMM. In the previous part, we learned how to make WDK drivers that handle user-mode requests and enable the VMX bit in our processor. In this part, we extend our driver and add VMX functionalities to our VMM. At last, we use different VT-x instructions in the VMM.</p><h2 id="table-of-contents"><span class="mr-2"><strong>Table of Contents</strong></span><a href="#table-of-contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><strong>Introduction</strong><li><strong>Table of Contents</strong><li><strong>Overview</strong><li><strong>Interacting with the driver from user-mode</strong><ul><li>Buffer Descriptions for I/O Control Codes<li>METHOD_BUFFERED<li>METHOD_IN_DIRECT and METHOD_OUT_DIRECT<li>METHOD_NIETHER<li>IOCTL Structure<li>IOCTL Dispatcher</ul><li><strong>Per Processor Configuration</strong><ul><li>Setting Affinity</ul><li><strong>Converting physical and virtual addresses</strong><li><strong>Check VMX support in the kernel</strong><li><strong>VMXON Region</strong><ul><li>Allocating VMXON Region</ul><li><strong>Virtual-Machine Control Data Structures (VMCS)</strong><ul><li>Initializing VMCS Region</ul><li><strong>VMXOFF Instruction</strong><li><strong>Testing VMM</strong><li><strong>Conclusion</strong><li><strong>References</strong></ul><h2 id="overview"><span class="mr-2"><strong>Overview</strong></span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In this part, we demonstrate how to interact with VMM from Windows user-mode (<strong>IOCTL Dispatcher</strong>), then we solve the problems with the affinity and running code in a particular core. Finally, we get familiar with initializing <strong>VMXON Regions</strong> and <strong>VMCS Regions</strong>, then we load our hypervisor into each core and implement our custom functions to work with hypervisor instructions and many more things related to Virtual-Machine Control Data Structures (<strong>VMCS</strong>).</p><p>Some of the implementations are derived from <a href="https://github.com/DarthTon/HyperBone">HyperBone</a> (Minimalistic VT-X hypervisor with hooks), <a href="https://github.com/tandasat/HyperPlatform">HyperPlatform</a> by <a href="https://github.com/tandasat">Satoshi Tanda</a> and <a href="https://github.com/wbenny/hvpp">hvpp</a> which is amazing work by my friend <a href="https://twitter.com/PetrBenes">Petr Beneš</a>.</p><p>The full source code of this tutorial is available on :</p><p>[<a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch">https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a>]</p><h2 id="interacting-with-the-driver-from-user-mode"><span class="mr-2"><strong>Interacting with the driver from user-mode</strong></span><a href="#interacting-with-the-driver-from-user-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The most important function for us in IRP MJ functions is <strong>DrvIoctlDispatcher</strong> or (IRP_MJ_DEVICE_CONTROL) Major Function, and that’s because this function can be called from user-mode with a particular IOCTL number, which means we can have a special code in our driver and implement a unique functionality corresponding this code, then by knowing the code (from user-mode) we can ask our driver to perform the request, so this way we can request a certain functionality from the kernel.</p><h3 id="buffer-descriptions-for-io-control-codes"><span class="mr-2"><strong>Buffer Descriptions for I/O Control Codes</strong></span><a href="#buffer-descriptions-for-io-control-codes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>As explained above, IOCTL codes request a certain functionality from the kernel-mode. It’s clear that in most cases, we need to transfer a buffer (structure) to the kernel, which shows different details about our request. Thus, we need to copy the buffer from the user-mode and pass it to the kernel-mode routines.</p><p>There are several methods in which Windows copies the buffer of the user-mode codes to the kernel for dispatching IOCTs.</p><ul><li>METHOD_BUFFERED<li>METHOD_IN_DIRECT<li>METHOD_OUT_DIRECT<li>METHOD_NIETHER</ul><p>The difference is where buffers transfer between user-mode and kernel-mode. Let’s see each of them in detail.</p><h3 id="method_buffered"><span class="mr-2"><strong>METHOD_BUFFERED</strong></span><a href="#method_buffered" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>For METHOD_BUFFERED, the pointer to the user-mode buffer is available at <strong>Irp-&gt;AssociatedIrp.SystemBuffer</strong>, and we can put the output buffer to the same address (<strong>Irp-&gt;AssociatedIrp.SystemBuffer</strong>).</p><p>This method is typically used for transferring small amounts of data per request. Most I/O control codes for device and intermediate drivers use this type as Windows copies the user-mode buffer to the kernel-mode and the kernel-mode buffer to the user-mode.</p><h3 id="method_in_direct-and-method_out_direct"><span class="mr-2"><strong>METHOD_IN_DIRECT and METHOD_OUT_DIRECT</strong></span><a href="#method_in_direct-and-method_out_direct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>For these methods, the pointer to the user-mode buffer is available at <strong>Irp-&gt;AssociatedIrp.SystemBuffer</strong>.</p><p>This type is generally used for reading or writing large amounts of data that must be transferred fast as it won’t copy the data and instead shares the pages.</p><p>The METHOD_IN_DIRECT is specified if the caller pass data to the driver, and the METHOD_OUT_DIRECT is selected if the caller will receive data from the driver.</p><h3 id="method_niether"><span class="mr-2"><strong>METHOD_NIETHER</strong></span><a href="#method_niether" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The input buffer address is specified by <strong>Parameters.DeviceIoControl.Type3InputBuffer</strong> in the driver’s <strong>IO_STACK_LOCATION</strong> structure, and the output buffer(to the user-mode) is specified by <strong>Irp-&gt;UserBuffer</strong>.</p><p>This method is neither buffered nor direct I/O. The I/O manager does not provide any system buffers, and the IRP provides the user-mode virtual addresses of the input and output buffers without validating or mapping them.</p><h3 id="ioctl-structure"><span class="mr-2"><strong>IOCTL Structure</strong></span><a href="#ioctl-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>We should specify all of the above transferring types into the following structure.</p><p><img data-src="../../assets/images/ioctl-structure.png" alt="" data-proofer-ignore></p><p>There is a convention for defining IOCTLs as mentioned <a href="https://www.codeproject.com/Articles/9575/Driver-Development-Part-2-Introduction-to-Implemen">here</a>. The IOCTL is a 32-bit number. The first two low bits represent the “transfer type”, which can be METHOD_OUT_DIRECT, METHOD_IN_DIRECT, METHOD_BUFFERED, or METHOD_NEITHER.</p><p>The next set of bits from 2 to 13 define the “Function Code”. The high bit is referred to as the “custom bit”. This is used to determine user-defined IOCTLs versus system defined. This means that function codes 0x800 and greater are customs defined for Windows Messages.</p><p>The next two bits define the access required to issue the IOCTL. This is how the I/O Manager can reject IOCTL requests if the handle has not been opened with the correct access. The access types are such as FILE_READ_DATA, FILE_WRITE_DATA, etc.</p><p>The last bits represent the device type the IOCTLs are written for. The high bit again represents user-defined values.</p><p>We can use the following defined macro to create our IOCTL code.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define IOCTL_Device_Function CTL_CODE(DeviceType, Function, Method, Access)
</span></pre></table></code></div></div><p>For example, the following IOCTL code can be defined.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#define IOCTL_TEST \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
</span></pre></table></code></div></div><h3 id="ioctl-dispatcher"><span class="mr-2"><strong>IOCTL Dispatcher</strong></span><a href="#ioctl-dispatcher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Now let’s implement our functions for dispatching IOCTL codes.</p><p>Note that the <strong>PAGED_CODE()</strong> macro ensures that the calling thread runs at an IRQL low enough to permit paging, this macro is used to ensure that paging is enabled, for example, the current execution is not at DISPATCH_LEVEL. Don’t worry; we’ll discuss IRQL in detail in the future parts.</p><p>The next step is to check the input buffer and the output buffer’s length. We’ll check it because we need to ensure that the user provides a buffer for the kernel and expects a buffer to be received. The following code gets the input and output buffer length from the <strong>IO_STACK_LOCATION</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>    <span class="n">IrpStack</span>     <span class="o">=</span> <span class="n">IoGetCurrentIrpStackLocation</span><span class="p">(</span><span class="n">Irp</span><span class="p">);</span>
    <span class="n">InBufLength</span>  <span class="o">=</span> <span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">InputBufferLength</span><span class="p">;</span>
    <span class="n">OutBufLength</span> <span class="o">=</span> <span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">OutputBufferLength</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InBufLength</span> <span class="o">||</span> <span class="n">OutBufLength</span> <span class="o">&lt;</span> <span class="n">DataLen</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NtStatus</span> <span class="o">=</span> <span class="n">STATUS_INVALID_PARAMETER</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">End</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>Then we have to use the switch-case through the IOCTL code.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre>  <span class="k">switch</span> <span class="p">(</span><span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">IoControlCode</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">IOCTL_SIOCTL_METHOD_BUFFERED</span><span class="p">:</span>

        <span class="p">...</span>
        
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">IOCTL_SIOCTL_METHOD_NEITHER</span><span class="p">:</span>

        <span class="p">...</span>
        
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">IOCTL_SIOCTL_METHOD_IN_DIRECT</span><span class="p">:</span>

        <span class="p">...</span>
        
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">IOCTL_SIOCTL_METHOD_OUT_DIRECT</span><span class="p">:</span>
    
        <span class="p">...</span>
        
        <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>

        <span class="c1">//</span>
        <span class="c1">// The specified I/O control code is unrecognized by this driver.</span>
        <span class="c1">//</span>
        <span class="n">NtStatus</span> <span class="o">=</span> <span class="n">STATUS_INVALID_DEVICE_REQUEST</span><span class="p">;</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"ERROR: unrecognized IOCTL %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                 <span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">IoControlCode</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>The <strong>PrintIrpInfo</strong> is like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">VOID</span> <span class="nf">PrintIrpInfo</span><span class="p">(</span><span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PIO_STACK_LOCATION</span>  <span class="n">IrpStack</span><span class="p">;</span>
    <span class="n">IrpStack</span> <span class="o">=</span> <span class="n">IoGetCurrentIrpStackLocation</span><span class="p">(</span><span class="n">Irp</span><span class="p">);</span>

    <span class="n">PAGED_CODE</span><span class="p">();</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Irp-&gt;AssociatedIrp.SystemBuffer = 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">AssociatedIrp</span><span class="p">.</span><span class="n">SystemBuffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Irp-&gt;UserBuffer = 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">UserBuffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">IrpStack-&gt;Parameters.DeviceIoControl.Type3InputBuffer = 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">Type3InputBuffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">IrpStack-&gt;Parameters.DeviceIoControl.InputBufferLength = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">InputBufferLength</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">IrpStack-&gt;Parameters.DeviceIoControl.OutputBufferLength = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">OutputBufferLength</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If you remember from the <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-2/">previous part</a> where we created a handle (HANDLE) using <code class="language-c highlighter-rouge"><span class="n">CreateFile</span></code>, now we can use the <code class="language-c highlighter-rouge"><span class="n">DeviceIoControl</span></code> with the previous handle and call <code class="language-c highlighter-rouge"><span class="n">DrvIoctlDispatcher</span></code> or (<strong>IRP_MJ_DEVICE_CONTROL</strong>) along with our provided buffer in the kernel.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>    <span class="kt">char</span>  <span class="n">OutputBuffer</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
    <span class="kt">char</span>  <span class="n">InputBuffer</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">BytesReturned</span><span class="p">;</span>
    <span class="n">BOOL</span>  <span class="n">Result</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Performing METHOD_BUFFERED</span>
    <span class="c1">//</span>
    <span class="n">StringCbCopy</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">),</span> <span class="s">"This String is from User Application; using METHOD_BUFFERED"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Calling DeviceIoControl METHOD_BUFFERED:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">OutputBuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OutputBuffer</span><span class="p">));</span>

    <span class="n">Result</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">Handle</span><span class="p">,</span>
                             <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">IOCTL_SIOCTL_METHOD_BUFFERED</span><span class="p">,</span>
                             <span class="o">&amp;</span><span class="n">InputBuffer</span><span class="p">,</span>
                             <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="o">&amp;</span><span class="n">OutputBuffer</span><span class="p">,</span>
                             <span class="k">sizeof</span><span class="p">(</span><span class="n">OutputBuffer</span><span class="p">),</span>
                             <span class="o">&amp;</span><span class="n">BytesReturned</span><span class="p">,</span>
                             <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Result</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error in DeviceIoControl : %d"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"    OutBuffer (%d): %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">BytesReturned</span><span class="p">,</span> <span class="n">OutputBuffer</span><span class="p">);</span>
</pre></table></code></div></div><p>For further reading, there is an old, yet great topic <a href="https://www.codeproject.com/Articles/9575/Driver-Development-Part-2-Introduction-to-Implemen">here</a> which describes the different types of IOCTL dispatching.</p><p>We’re done with WDK basics! It’s time to see how we can use Windows to build our VMM.</p><p><img data-src="../../assets/images/anime-girl-blue-moon.jpg" alt="" data-proofer-ignore></p><hr /><h2 id="per-processor-configuration"><span class="mr-2"><strong>Per Processor Configuration</strong></span><a href="#per-processor-configuration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Affinity to a special logical processor is one of the main considerations when working with the hypervisor.</p><p>In my <strong>Intel Core i7 6820HQ</strong>, I have four physical cores, and each core can run two threads simultaneously (due to the hyper-threading); thus, we have eight logical processors and, of course, eight sets of all the registers (including general purpose registers and MSR registers) and more importantly, eight sets of VMCSs and VMXON Regions, etc. so we should configure our VMM to work on eight logical processors.</p><h3 id="setting-affinity"><span class="mr-2"><strong>Setting Affinity</strong></span><a href="#setting-affinity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>To get the count of logical processors, we can use <code class="language-c highlighter-rouge"><span class="n">KeQueryActiveProcessorCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code>. Then we should pass a <strong>KAFFINITY</strong> mask to the <code class="language-c highlighter-rouge"><span class="n">KeSetSystemAffinityThread</span></code>, which sets the system affinity of the current thread.</p><p><strong>KAFFINITY</strong> mask can be configured using a simple power function:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">MathPower</span><span class="p">(</span><span class="kt">int</span> <span class="n">Base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Exponent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">Result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Exponent</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Result</span> <span class="o">*=</span> <span class="n">Base</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Exponent</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Exponent</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Base</span> <span class="o">*=</span> <span class="n">Base</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>After that, we should use the following code to change the affinity of the processor and run our code in all the logical cores separately:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>    <span class="n">KAFFINITY</span> <span class="n">AffinityMask</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KeQueryActiveProcessors</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AffinityMask</span> <span class="o">=</span> <span class="n">MathPower</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">KeSetSystemAffinityThread</span><span class="p">(</span><span class="n">AffinityMask</span><span class="p">);</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"====================================================="</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"Current thread is executing in %d th logical processor."</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

        <span class="c1">// run code here</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>This way, we can run our codes in the different logical cores. Now, let’s see other essential functionalities we need for our hypervisor.</p><h2 id="converting-physical-and-virtual-addresses"><span class="mr-2"><strong>Converting physical and virtual addresses</strong></span><a href="#converting-physical-and-virtual-addresses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>VMXON Regions and VMCS Regions (see below) use the physical address as the operand to VMXON and VMPTRLD instructions, so we should create functions to convert Virtual Address to Physical address:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">UINT64</span>
<span class="nf">VirtualToPhysicalAddress</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">Va</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">MmGetPhysicalAddress</span><span class="p">(</span><span class="n">Va</span><span class="p">).</span><span class="n">QuadPart</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And as long as we can’t directly use physical addresses for our modifications in protected-mode, we have to convert Physical addresses to Virtual addresses too.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">UINT64</span>
<span class="nf">PhysicalToVirtualAddress</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">Pa</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">PhysicalAddr</span><span class="p">;</span>
    <span class="n">PhysicalAddr</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="n">Pa</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">MmGetVirtualForPhysical</span><span class="p">(</span><span class="n">PhysicalAddr</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="check-vmx-support-in-the-kernel"><span class="mr-2"><strong>Check VMX support in the kernel</strong></span><a href="#check-vmx-support-in-the-kernel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In the previous part, we query about the presence of hypervisor from user-mode, but we should also consider checking about hypervisor from kernel-mode too. This reduces the possibility of getting kernel errors in the future, or there might be something that disables the hypervisor using the <strong>lock bit</strong>. By the way, the following code checks <strong>IA32_FEATURE_CONTROL</strong> MSR (MSR address 3AH) to see if the <strong>lock bit</strong> is set or not.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">IsVmxSupported</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">CPUID</span> <span class="n">Data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">//</span>
    <span class="c1">// Check for the VMX bit</span>
    <span class="c1">//</span>
    <span class="n">__cpuid</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">Data</span><span class="p">.</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

    <span class="n">IA32_FEATURE_CONTROL_MSR</span> <span class="n">Control</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Control</span><span class="p">.</span><span class="n">All</span>                      <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_FEATURE_CONTROL</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// BIOS lock check</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Control</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">Lock</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Control</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">Lock</span>        <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="n">Control</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">EnableVmxon</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="n">__writemsr</span><span class="p">(</span><span class="n">MSR_IA32_FEATURE_CONTROL</span><span class="p">,</span> <span class="n">Control</span><span class="p">.</span><span class="n">All</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Control</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">EnableVmxon</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMX locked off in BIOS"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The structures used in the above function are declared like this:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">union</span> <span class="n">_IA32_FEATURE_CONTROL_MSR</span>
<span class="p">{</span>
    <span class="n">ULONG64</span> <span class="n">All</span><span class="p">;</span>
    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="n">ULONG64</span> <span class="n">Lock</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>                <span class="c1">// [0]</span>
        <span class="n">ULONG64</span> <span class="n">EnableSMX</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>           <span class="c1">// [1]</span>
        <span class="n">ULONG64</span> <span class="n">EnableVmxon</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1">// [2]</span>
        <span class="n">ULONG64</span> <span class="n">Reserved2</span> <span class="o">:</span> <span class="mi">5</span><span class="p">;</span>           <span class="c1">// [3-7]</span>
        <span class="n">ULONG64</span> <span class="n">EnableLocalSENTER</span> <span class="o">:</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// [8-14]</span>
        <span class="n">ULONG64</span> <span class="n">EnableGlobalSENTER</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// [15]</span>
        <span class="n">ULONG64</span> <span class="n">Reserved3a</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>         <span class="c1">//</span>
        <span class="n">ULONG64</span> <span class="n">Reserved3b</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>         <span class="c1">// [16-63]</span>
    <span class="p">}</span> <span class="n">Fields</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IA32_FEATURE_CONTROL_MSR</span><span class="p">,</span> <span class="o">*</span><span class="n">PIA32_FEATURE_CONTROL_MSR</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_CPUID</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">eax</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ebx</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ecx</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">edx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CPUID</span><span class="p">,</span> <span class="o">*</span><span class="n">PCPUID</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="vmxon-region"><span class="mr-2"><strong>VMXON Region</strong></span><a href="#vmxon-region" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Several regions are used in the VMX to handle the virtual machine state. In this part, we will walk through the VMXON Region and the VMCS Region.</p><p>Before executing VMXON, we should allocate a naturally aligned 4-KByte region of memory that our logical processor will use it to support VMX operation. This region is called the <strong>VMXON Region</strong>. The address of the VMXON Region (the VMXON pointer) is provided in an operand to VMXON instruction.</p><p>A VMM should use different VMXON Regions for each logical processor; otherwise, the behavior is “undefined”.</p><p>Please note that VMX operation requires that the following bits be 1 in VMX operation: CR0.PE, CR0.NE, CR0.PG, and CR4.VMXE. The restrictions on CR0.PE and CR0.PG implies that VMX operation is supported only in paged protected-mode. Therefore, the guest software cannot be run in unpaged protected-mode or in real-address mode.</p><p>Now that we are configuring the hypervisor, we should have a global variable that describes the state of our virtual machine. The following structure is created for this purpose. We currently have two fields called (<strong>VMXON_REGION</strong> and <strong>VMCS_REGION</strong>), but we will add new fields and enhance this structure in the future.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_VIRTUAL_MACHINE_STATE</span>
<span class="p">{</span>
    <span class="n">UINT64</span> <span class="n">VmxonRegion</span><span class="p">;</span> <span class="c1">// VMXON region</span>
    <span class="n">UINT64</span> <span class="n">VmcsRegion</span><span class="p">;</span>  <span class="c1">// VMCS region</span>
<span class="p">}</span> <span class="n">VIRTUAL_MACHINE_STATE</span><span class="p">,</span> <span class="o">*</span><span class="n">PVIRTUAL_MACHINE_STATE</span><span class="p">;</span>
</pre></table></code></div></div><p>And, of course, a global variable:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="n">VIRTUAL_MACHINE_STATE</span><span class="o">*</span> <span class="n">g_GuestState</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="allocating-vmxon-region"><span class="mr-2"><strong>Allocating VMXON Region</strong></span><a href="#allocating-vmxon-region" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The following function (in “<strong>Memory.c</strong>”) to allocate VMXON Region and execute VMXON instruction using the allocated region’s pointer.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">AllocateVmxonRegion</span><span class="p">(</span><span class="n">IN</span> <span class="n">VIRTUAL_MACHINE_STATE</span> <span class="o">*</span> <span class="n">GuestState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// at IRQL &gt; DISPATCH_LEVEL memory allocation routines don't work</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">KeGetCurrentIrql</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">DISPATCH_LEVEL</span><span class="p">)</span>
        <span class="n">KeRaiseIrqlToDpcLevel</span><span class="p">();</span>

    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">PhysicalMax</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">PhysicalMax</span><span class="p">.</span><span class="n">QuadPart</span>         <span class="o">=</span> <span class="n">MAXULONG64</span><span class="p">;</span>

    <span class="kt">int</span>    <span class="n">VMXONSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">VMXON_SIZE</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="o">*</span> <span class="n">Buffer</span>    <span class="o">=</span> <span class="n">MmAllocateContiguousMemory</span><span class="p">(</span><span class="n">VMXONSize</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span><span class="p">,</span> <span class="n">PhysicalMax</span><span class="p">);</span> <span class="c1">// Allocating a 4-KByte Contigous Memory region</span>

    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">Highest</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">Lowest</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Highest</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// BYTE* Buffer = MmAllocateContiguousMemorySpecifyCache(VMXONSize + ALIGNMENT_PAGE_SIZE, Lowest, Highest, Lowest, MmNonCached);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Error : Couldn't Allocate Buffer for VMXON Region."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// ntStatus = STATUS_INSUFFICIENT_RESOURCES;</span>
    <span class="p">}</span>
    <span class="n">UINT64</span> <span class="n">PhysicalBuffer</span> <span class="o">=</span> <span class="n">VirtualToPhysicalAddress</span><span class="p">(</span><span class="n">Buffer</span><span class="p">);</span>

    <span class="c1">// zero-out memory</span>
    <span class="n">RtlSecureZeroMemory</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">VMXONSize</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span><span class="p">);</span>
    <span class="n">UINT64</span> <span class="n">AlignedPhysicalBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)(</span><span class="n">PhysicalBuffer</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">UINT64</span> <span class="n">AlignedVirtualBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)(</span><span class="n">Buffer</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Virtual allocated buffer for VMXON at %llx"</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Virtual aligned allocated buffer for VMXON at %llx"</span><span class="p">,</span> <span class="n">AlignedVirtualBuffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Aligned physical buffer allocated for VMXON at %llx"</span><span class="p">,</span> <span class="n">AlignedPhysicalBuffer</span><span class="p">);</span>

    <span class="c1">// get IA32_VMX_BASIC_MSR RevisionId</span>

    <span class="n">IA32_VMX_BASIC_MSR</span> <span class="n">basic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">basic</span><span class="p">.</span><span class="n">All</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_BASIC</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] MSR_IA32_VMX_BASIC (MSR 0x480) Revision Identifier %llx"</span><span class="p">,</span> <span class="n">basic</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">RevisionIdentifier</span><span class="p">);</span>

    <span class="c1">// Changing Revision Identifier</span>
    <span class="o">*</span><span class="p">(</span><span class="n">UINT64</span> <span class="o">*</span><span class="p">)</span><span class="n">AlignedVirtualBuffer</span> <span class="o">=</span> <span class="n">basic</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">RevisionIdentifier</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">__vmx_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlignedPhysicalBuffer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Status</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMXON failed with status %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_GuestState</span><span class="o">-&gt;</span><span class="n">VmxonRegion</span> <span class="o">=</span> <span class="n">AlignedPhysicalBuffer</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Let’s explain the above function. In the above function, we used <code class="language-c highlighter-rouge"><span class="n">MmAllocateContiguousMemory</span></code> to allocate a contiguous and aligned page. We can also use <code class="language-c highlighter-rouge"><span class="n">MmAllocateContiguousMemorySpecifyCache</span></code> to specify the cache type for the allocated memory.</p><p>You can read <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_memory_caching_type">this</a> link to learn about different types of memory caches.</p><p>To ensure proper behavior in VMX operation, we should maintain the VMCS region and related structures in writeback cacheable memory. Alternatively, we may map any of these regions or structures with the UC (uncached) memory type. Doing so is strongly discouraged unless necessary as it will cause the performance of transitions using those structures to suffer significantly.</p><p>Writeback is a storage method in which data is written into the cache every time a change occurs but is written into the corresponding location in the main memory only at specified intervals or under certain conditions. Being cachable or not cachable can be determined from the <strong>cache disable bit</strong> in paging structures (PTE) and in the Memory type range register (MTRR), which is described thoroughly in the 7th part of this series.</p><p>By the way, we allocated 8192 bytes because there is no guarantee that Windows allocates the aligned memory so that we can find a piece of 4096 bytes aligned in 8196 bytes. (by aligning, I mean the physical address should be divisible by 4096 without any reminder).</p><p>In my experience, the <strong>MmAllocateContiguousMemory</strong> allocation is always aligned. Maybe it is because every page in PFN is allocated by 4096 bytes, and as long as we need 4096 bytes, thus it’s aligned.</p><p>If you are interested in Page Frame Number (PFN), you can read <a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part1/">Inside Windows Page Frame Number (PFN) – Part 1</a> and <a href="https://rayanfam.com/topics/inside-windows-page-frame-number-part2/">Inside Windows Page Frame Number (PFN) – Part 2</a>.</p><p>Now we should convert the allocated memory address to its physical address and make sure it’s aligned.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">PhysicalMax</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">PhysicalMax</span><span class="p">.</span><span class="n">QuadPart</span>         <span class="o">=</span> <span class="n">MAXULONG64</span><span class="p">;</span>

    <span class="kt">int</span>    <span class="n">VMXONSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">VMXON_SIZE</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="o">*</span> <span class="n">Buffer</span>    <span class="o">=</span> <span class="n">MmAllocateContiguousMemory</span><span class="p">(</span><span class="n">VMXONSize</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span><span class="p">,</span> <span class="n">PhysicalMax</span><span class="p">);</span> <span class="c1">// Allocating a 4-KByte Contigous Memory region</span>
</pre></table></code></div></div><p>Memory that <code class="language-c highlighter-rouge"><span class="n">MmAllocateContiguousMemory</span></code> allocates is uninitialized. The kernel-mode driver must first set this memory to zero, and we use <code class="language-c highlighter-rouge"><span class="n">RtlSecureZeroMemory</span></code> for this purpose.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>    <span class="n">UINT64</span> <span class="n">PhysicalBuffer</span> <span class="o">=</span> <span class="n">VirtualToPhysicalAddress</span><span class="p">(</span><span class="n">Buffer</span><span class="p">);</span>

    <span class="c1">// zero-out memory</span>
    <span class="n">RtlSecureZeroMemory</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">VMXONSize</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span><span class="p">);</span>
    <span class="n">UINT64</span> <span class="n">AlignedPhysicalBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)(</span><span class="n">PhysicalBuffer</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">UINT64</span> <span class="n">AlignedVirtualBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)(</span><span class="n">Buffer</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Virtual allocated buffer for VMXON at %llx"</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Virtual aligned allocated buffer for VMXON at %llx"</span><span class="p">,</span> <span class="n">AlignedVirtualBuffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Aligned physical buffer allocated for VMXON at %llx"</span><span class="p">,</span> <span class="n">AlignedPhysicalBuffer</span><span class="p">);</span>
</pre></table></code></div></div><p>From Intel’s manual (24.11.5 VMXON Region ):</p><blockquote><p>Before executing VMXON, software should write the VMCS revision identifier to the VMXON region. (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON region; bit 31 should be cleared to 0.)</p><p>It need not initialize the VMXON region in any other way. Software should use a separate region for each logical processor and should not access or modify the VMXON region of a logical processor between the execution of VMXON and VMXOFF on that logical processor. Doing otherwise may lead to unpredictable behavior.</p></blockquote><p>So let’s get the Revision Identifier from <strong>IA32_VMX_BASIC_MSR</strong> and write it to the VMXON Region.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="c1">// get IA32_VMX_BASIC_MSR RevisionId</span>

    <span class="n">IA32_VMX_BASIC_MSR</span> <span class="n">basic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">basic</span><span class="p">.</span><span class="n">All</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_BASIC</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] MSR_IA32_VMX_BASIC (MSR 0x480) Revision Identifier %llx"</span><span class="p">,</span> <span class="n">basic</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">RevisionIdentifier</span><span class="p">);</span>

    <span class="c1">// Changing Revision Identifier</span>
    <span class="o">*</span><span class="p">(</span><span class="n">UINT64</span> <span class="o">*</span><span class="p">)</span><span class="n">AlignedVirtualBuffer</span> <span class="o">=</span> <span class="n">basic</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">RevisionIdentifier</span><span class="p">;</span>
</pre></table></code></div></div><p>The last part is used for executing VMXON instruction.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">__vmx_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlignedPhysicalBuffer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Status</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMXON failed with status %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_GuestState</span><span class="o">-&gt;</span><span class="n">VmxonRegion</span> <span class="o">=</span> <span class="n">AlignedPhysicalBuffer</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>__vmx_on</strong> is the intrinsic function for executing VMXON. The status code shows different meanings.</p><div class="table-wrapper"><table><thead><tr><th>Value<th>Meaning<tbody><tr><td>0<td>The operation succeeded.<tr><td>1<td>The operation failed with extended status available in the <code class="language-c highlighter-rouge"><span class="n">VM</span><span class="o">-</span><span class="n">instruction</span> <span class="n">error</span> <span class="n">field</span></code> of the current VMCS.<tr><td>2<td>The operation failed without status available.</table></div><p>If we set the VMXON Region using VMXON and it fails, then the status is equal to 1. If there isn’t any VMCS, the status is equal to 2, and if the operation was successful, the status is zero. We get errors if we execute the above code twice without executing VMXOFF.</p><p>Now, the VMXON Region is ready, and we’re good to go.</p><hr /><h2 id="virtual-machine-control-data-structures-vmcs"><span class="mr-2"><strong>Virtual-Machine Control Data Structures (VMCS)</strong></span><a href="#virtual-machine-control-data-structures-vmcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>A logical processor uses virtual-machine control data structure (VMCS) while it’s in VMX operation. These manage transitions into and out of VMX non-root operation (VM entries and VM exits) as well as processor behavior in VMX non-root operation. This structure is manipulated by VMCLEAR, VMPTRLD, VMREAD, and VMWRITE instructions.</p><p><img data-src="../../assets/images/vmx-lifecycle.png" alt="VMX Life cycle" data-proofer-ignore></p><p>The above picture illustrates the lifecycle of VMX operation in the VMCS Region.</p><h3 id="initializing-vmcs-region"><span class="mr-2"><strong>Initializing VMCS Region</strong></span><a href="#initializing-vmcs-region" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>A VMM should use different VMCS Regions, so we need to set logical processor affinity and run our initialization routine multiple times.</p><p>The location where the VMCS located is called the “VMCS Region”.</p><p>VMCS Region is a</p><ul><li>4 Kbyte (bits 11:0 must be zero)<li>Must be aligned to the 4KB boundary</ul><p>This pointer must not set bits beyond the processor’s physical-address width (we can determine a processor’s physical-address width by executing CPUID with 80000008H in EAX. The physical-address width is returned in bits 7:0 of EAX.)</p><p>There might be several VMCSs simultaneously in a processor, but just one of them is currently active, and the VMLAUNCH, VMREAD, VMRESUME, and VMWRITE instructions operate only on the current VMCS.</p><p>Using VMPTRLD sets the current VMCS on a logical processor.</p><p>The memory operand of the VMCLEAR instruction is also the address of a VMCS. After executing the instruction, VMCS is neither active nor current on the logical processor. If the VMCS had been current on the logical processor, the logical processor no longer has a current VMCS.</p><p>VMPTRST is responsible to give the current VMCS pointer it stores the value FFFFFFFFFFFFFFFFH if there is no current VMCS.</p><p>The launching state of a VMCS determines which VM-entry instruction should be used with that VMCS. The VMLAUNCH instruction requires a VMCS whose launch state is “clear”; the VMRESUME instruction requires a VMCS whose launch state is “launched”. A logical processor maintains a VMCS’s launch state in the corresponding VMCS region.</p><p>If the launch state of the current VMCS is “clear”, successful execution of the VMLAUNCH instruction changes the launch state to “launched”.</p><p>The memory operand of the VMCLEAR instruction is the address of a VMCS. After execution of the instruction, the launch state of that VMCS is “clear”.</p><p>There are no other ways to modify the launch state of a VMCS (it cannot be modified using VMWRITE), and there is no direct way to discover it (it cannot be read using VMREAD).</p><p>The following picture illustrates the contents of a VMCS Region.</p><p><img data-src="../../assets/images/init-VMCS-structure.png" alt="VMCS Region" data-proofer-ignore></p><p>The following code is responsible for allocating VMCS Region :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">AllocateVmcsRegion</span><span class="p">(</span><span class="n">IN</span> <span class="n">VIRTUAL_MACHINE_STATE</span> <span class="o">*</span> <span class="n">GuestState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// at IRQL &gt; DISPATCH_LEVEL memory allocation routines don't work</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">KeGetCurrentIrql</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">DISPATCH_LEVEL</span><span class="p">)</span>
        <span class="n">KeRaiseIrqlToDpcLevel</span><span class="p">();</span>

    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">PhysicalMax</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">PhysicalMax</span><span class="p">.</span><span class="n">QuadPart</span>         <span class="o">=</span> <span class="n">MAXULONG64</span><span class="p">;</span>

    <span class="kt">int</span>    <span class="n">VMCSSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">VMCS_SIZE</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="o">*</span> <span class="n">Buffer</span>   <span class="o">=</span> <span class="n">MmAllocateContiguousMemory</span><span class="p">(</span><span class="n">VMCSSize</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span><span class="p">,</span> <span class="n">PhysicalMax</span><span class="p">);</span> <span class="c1">// Allocating a 4-KByte Contigous Memory region</span>

    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">Highest</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">Lowest</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Highest</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// BYTE* Buffer = MmAllocateContiguousMemorySpecifyCache(VMXONSize + ALIGNMENT_PAGE_SIZE, Lowest, Highest, Lowest, MmNonCached);</span>

    <span class="n">UINT64</span> <span class="n">PhysicalBuffer</span> <span class="o">=</span> <span class="n">VirtualToPhysicalAddress</span><span class="p">(</span><span class="n">Buffer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Error : Couldn't Allocate Buffer for VMCS Region."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// ntStatus = STATUS_INSUFFICIENT_RESOURCES;</span>
    <span class="p">}</span>
    <span class="c1">// zero-out memory</span>
    <span class="n">RtlSecureZeroMemory</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">VMCSSize</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span><span class="p">);</span>
    <span class="n">UINT64</span> <span class="n">AlignedPhysicalBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)(</span><span class="n">PhysicalBuffer</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">UINT64</span> <span class="n">AlignedVirtualBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)(</span><span class="n">Buffer</span> <span class="o">+</span> <span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGNMENT_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Virtual allocated buffer for VMCS at %llx"</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Virtual aligned allocated buffer for VMCS at %llx"</span><span class="p">,</span> <span class="n">AlignedVirtualBuffer</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Aligned physical buffer allocated for VMCS at %llx"</span><span class="p">,</span> <span class="n">AlignedPhysicalBuffer</span><span class="p">);</span>

    <span class="c1">// get IA32_VMX_BASIC_MSR RevisionId</span>

    <span class="n">IA32_VMX_BASIC_MSR</span> <span class="n">basic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">basic</span><span class="p">.</span><span class="n">All</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_BASIC</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] MSR_IA32_VMX_BASIC (MSR 0x480) Revision Identifier %llx"</span><span class="p">,</span> <span class="n">basic</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">RevisionIdentifier</span><span class="p">);</span>

    <span class="c1">// Changing Revision Identifier</span>
    <span class="o">*</span><span class="p">(</span><span class="n">UINT64</span> <span class="o">*</span><span class="p">)</span><span class="n">AlignedVirtualBuffer</span> <span class="o">=</span> <span class="n">basic</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">RevisionIdentifier</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">__vmx_vmptrld</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlignedPhysicalBuffer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Status</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMCS failed with status %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_GuestState</span><span class="o">-&gt;</span><span class="n">VmcsRegion</span> <span class="o">=</span> <span class="n">AlignedPhysicalBuffer</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The above code is exactly the same as VMXON Region except for <strong>__vmx_vmptrld</strong> instead of <strong>__vmx_on</strong>, <strong>__vmx_vmptrld</strong> is the intrinsic function for VMPTRLD instruction.</p><p>In VMCS, we should find the <strong>Revision Identifier</strong> from <strong>MSR_IA32_VMX_BASIC</strong> and write it in VMCS Region before executing VMPTRLD.</p><p>The MSR_IA32_VMX_BASIC is defined as below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">union</span> <span class="n">_IA32_VMX_BASIC_MSR</span>
<span class="p">{</span>
    <span class="n">ULONG64</span> <span class="n">All</span><span class="p">;</span>
    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="n">ULONG32</span> <span class="n">RevisionIdentifier</span> <span class="o">:</span> <span class="mi">31</span><span class="p">;</span>   <span class="c1">// [0-30]</span>
        <span class="n">ULONG32</span> <span class="n">Reserved1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>             <span class="c1">// [31]</span>
        <span class="n">ULONG32</span> <span class="n">RegionSize</span> <span class="o">:</span> <span class="mi">12</span><span class="p">;</span>           <span class="c1">// [32-43]</span>
        <span class="n">ULONG32</span> <span class="n">RegionClear</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>           <span class="c1">// [44]</span>
        <span class="n">ULONG32</span> <span class="n">Reserved2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>             <span class="c1">// [45-47]</span>
        <span class="n">ULONG32</span> <span class="n">SupportedIA64</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1">// [48]</span>
        <span class="n">ULONG32</span> <span class="n">SupportedDualMoniter</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// [49]</span>
        <span class="n">ULONG32</span> <span class="n">MemoryType</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>            <span class="c1">// [50-53]</span>
        <span class="n">ULONG32</span> <span class="n">VmExitReport</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// [54]</span>
        <span class="n">ULONG32</span> <span class="n">VmxCapabilityHint</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">// [55]</span>
        <span class="n">ULONG32</span> <span class="n">Reserved3</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>             <span class="c1">// [56-63]</span>
    <span class="p">}</span> <span class="n">Fields</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IA32_VMX_BASIC_MSR</span><span class="p">,</span> <span class="o">*</span><span class="n">PIA32_VMX_BASIC_MSR</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="vmxoff-instruction"><span class="mr-2"><strong>VMXOFF Instruction</strong></span><a href="#vmxoff-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>After configuring the above regions, now it’s time to think about <strong>DrvClose</strong> when the user-mode application no longer maintains the handle to the driver. At this time, we should terminate VMX and free every memory that we allocated before.</p><p>The following function is responsible for executing VMXOFF and then calling <strong>MmFreeContiguousMemory</strong> to free the allocated memory :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">TerminateVmx</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[*] Terminating VMX...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">KAFFINITY</span> <span class="n">AffinityMask</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ProcessorCounts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AffinityMask</span> <span class="o">=</span> <span class="n">MathPower</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">KeSetSystemAffinityThread</span><span class="p">(</span><span class="n">AffinityMask</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">Current thread is executing in %d th logical processor."</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

        <span class="n">__vmx_off</span><span class="p">();</span>
        <span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">PhysicalToVirtualAddress</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmxonRegion</span><span class="p">));</span>
        <span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">PhysicalToVirtualAddress</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmcsRegion</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMX Operation turned off successfully. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Remember to convert VMXON and VMCS Regions to virtual addresses because <strong>MmFreeContiguousMemory</strong> accepts virtual addresses; otherwise, it leads to a BSOD.</p><p>Ok, It’s almost done!</p><h2 id="testing-vmm"><span class="mr-2"><strong>Testing VMM</strong></span><a href="#testing-vmm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="../../assets/images/anime-girl-sitting.jpg" alt="" data-proofer-ignore></p><p>Let’s create a test case for our code, first a function for initiating VMXON and VMCS Regions through all logical processors.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="n">VIRTUAL_MACHINE_STATE</span> <span class="o">*</span> <span class="n">g_GuestState</span><span class="p">;</span>
<span class="kt">int</span>                     <span class="n">ProcessorCounts</span><span class="p">;</span>

<span class="n">BOOLEAN</span>
<span class="nf">InitializeVmx</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsVmxSupported</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMX is not supported in this machine !"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ProcessorCounts</span> <span class="o">=</span> <span class="n">KeQueryActiveProcessorCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">g_GuestState</span>    <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span>
                                         <span class="k">sizeof</span><span class="p">(</span><span class="n">VIRTUAL_MACHINE_STATE</span><span class="p">)</span> <span class="o">*</span> <span class="n">ProcessorCounts</span><span class="p">,</span>
                                         <span class="n">POOLTAG</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">=====================================================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">KAFFINITY</span> <span class="n">AffinityMask</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ProcessorCounts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AffinityMask</span> <span class="o">=</span> <span class="n">MathPower</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

        <span class="n">KeSetSystemAffinityThread</span><span class="p">(</span><span class="n">AffinityMask</span><span class="p">);</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">Current thread is executing in %d th logical processor."</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

        <span class="c1">//</span>
        <span class="c1">// Enabling VMX Operation</span>
        <span class="c1">//</span>
        <span class="n">AsmEnableVmxOperation</span><span class="p">();</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMX Operation Enabled Successfully !"</span><span class="p">);</span>

        <span class="n">AllocateVmxonRegion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">AllocateVmcsRegion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMCS Region is allocated at  ===============&gt; %llx"</span><span class="p">,</span> <span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmcsRegion</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMXON Region is allocated at ===============&gt; %llx"</span><span class="p">,</span> <span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmxonRegion</span><span class="p">);</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">=====================================================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The above function should be called from IRP MJ CREATE, so let’s modify our <strong>DrvCreate</strong> to :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">NTSTATUS</span> <span class="nf">DrvCreate</span><span class="p">(</span><span class="n">IN</span> <span class="n">PDEVICE_OBJECT</span> <span class="n">DeviceObject</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] DrvCreate Called !"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">InitializeVmx</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMX Initiated Successfully."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And modify <strong>DrvClose</strong> to :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">NTSTATUS</span>
<span class="nf">DrvClose</span><span class="p">(</span><span class="n">IN</span> <span class="n">PDEVICE_OBJECT</span> <span class="n">DeviceObject</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] DrvClose Called !"</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// executing VMXOFF on every logical processor</span>
    <span class="c1">//</span>
    <span class="n">TerminateVmx</span><span class="p">();</span>

    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span>      <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now, run the code. In the case of creating the handle (You can see that our regions were allocated successfully).</p><p><img data-src="../../assets/images/VMXON-and-VMCS.png" alt="VMX Regions" data-proofer-ignore></p><p>And when we call <strong>CloseHandle</strong> from user mode:</p><p><img data-src="../../assets/images/terminate-vmx.png" alt="VMXOFF" data-proofer-ignore></p><h2 id="conclusion"><span class="mr-2"><strong>Conclusion</strong></span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In this part, we learned about different types of IOCTL Dispatching. We saw different functions in Windows to manage our VMM, and we initialized the VMXON Regions and VMCS Regions, then terminated them.</p><p>In the future, we’ll focus on Exteneded Page Table (EPT), VMCS, and different actions that can be performed in VMCS Regions to control our guest software.</p><p>The fourth part is also available [here].(https://rayanfam.com/topics/hypervisor-from-scratch-part-4/).</p><p>Note: Remember that hypervisors change over time because new features are added to the operating systems or new technologies are used. For example, updates to Meltdown &amp; Spectre have made a lot of changes to the hypervisors. So, if you want to use Hypervisor From Scratch in your projects, research, or whatever, you should use the <a href="https://github.com/HyperDbg/HyperDbg"><strong>HyperDbg</strong></a> drivers. <strong>HyperDbg</strong> is actively maintained, stable, and reliable, ensuring you avoid the errors and instability problems that can arise from using older parts of the tutorial series.</p><h2 id="references"><span class="mr-2"><strong>References</strong></span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>[1] Intel® 64 and IA-32 architectures software developer’s manual combined volumes 3 (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)</p><p>[2] Windows Driver Samples (<a href="https://github.com/Microsoft/Windows-driver-samples">https://github.com/Microsoft/Windows-driver-samples</a>)</p><p>[3] Driver Development Part 2: Introduction to Implementing IOCTLs (<a href="https://www.codeproject.com/Articles/9575/Driver-Development-Part-2-Introduction-to-Implemen">https://www.codeproject.com/Articles/9575/Driver-Development-Part-2-Introduction-to-Implemen</a>)</p><p>[3] Hyperplatform (<a href="https://github.com/tandasat/HyperPlatform">https://github.com/tandasat/HyperPlatform</a>)</p><p>[4] PAGED_CODE macro (<a href="https://technet.microsoft.com/en-us/ff558773(v=vs.96)">https://technet.microsoft.com/en-us/ff558773(v=vs.96)</a>)</p><p>[5] HVPP (<a href="https://github.com/wbenny/hvpp">https://github.com/wbenny/hvpp</a>)</p><p>[6] HyperBone Project (<a href="https://github.com/DarthTon/HyperBone">https://github.com/DarthTon/HyperBone</a>)</p><p>[7] Memory Caching Types (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_memory_caching_type">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_memory_caching_type)</a></p><p>[8] What is writeback cache? (<a href="https://whatis.techtarget.com/definition/write-back">https://whatis.techtarget.com/definition/write-back</a>)</p><p>[9] Buffer Descriptions for I/O Control Codes (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes</a>)</p><p>[10] Defining I/O Control Codes (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes</a>)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cpu/'>cpu</a>, <a href='/categories/hypervisor/'>hypervisor</a>, <a href='/categories/tutorials/'>tutorials</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hypervisor/" class="post-tag no-text-decoration" >hypervisor</a> <a href="/tags/creating-vmm/" class="post-tag no-text-decoration" >creating-vmm</a> <a href="/tags/initiating-vmx-operation/" class="post-tag no-text-decoration" >initiating-vmx-operation</a> <a href="/tags/irp-mj-device-control/" class="post-tag no-text-decoration" >irp_mj_device_control</a> <a href="/tags/method-buffered/" class="post-tag no-text-decoration" >method_buffered</a> <a href="/tags/method-in-direct/" class="post-tag no-text-decoration" >method_in_direct</a> <a href="/tags/method-niether/" class="post-tag no-text-decoration" >method_niether</a> <a href="/tags/method-out-direct/" class="post-tag no-text-decoration" >method_out_direct</a> <a href="/tags/vmcs/" class="post-tag no-text-decoration" >vmcs</a> <a href="/tags/vmcs-region/" class="post-tag no-text-decoration" >vmcs-region</a> <a href="/tags/vmm/" class="post-tag no-text-decoration" >vmm</a> <a href="/tags/vmx-operation/" class="post-tag no-text-decoration" >vmx-operation</a> <a href="/tags/vmxon/" class="post-tag no-text-decoration" >vmxon</a> <a href="/tags/vmxon-region/" class="post-tag no-text-decoration" >vmxon-region</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine - Rayanfam Blog&amp;url=https://rayanfam.com/topics/hypervisor-from-scratch-part-3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine - Rayanfam Blog&amp;u=https://rayanfam.com/topics/hypervisor-from-scratch-part-3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://rayanfam.com/topics/hypervisor-from-scratch-part-3/&amp;text=Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine - Rayanfam Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/topics/hypervisor-from-scratch-part-1/">Hypervisor From Scratch - Part 1: Basic Concepts & Configure Testing Environment</a><li><a href="/topics/hypervisor-from-scratch-part-2/">Hypervisor From Scratch – Part 2: Entering VMX Operation</a><li><a href="/topics/hypervisor-from-scratch-part-5/">Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</a><li><a href="/topics/hypervisor-from-scratch-part-6/">Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</a><li><a href="/topics/hypervisor-from-scratch-part-7/">Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/topics/hypervisor-from-scratch-part-5/"><div class="card-body"> <em class="timeago small" data-ts="1544918400" > 2018-12-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-6/"><div class="card-body"> <em class="timeago small" data-ts="1551052800" > 2019-02-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-7/"><div class="card-body"> <em class="timeago small" data-ts="1579478400" > 2020-01-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/topics/using-intels-streaming-simd-extensions-3-monitormwait-as-a-kernel-debugging-trick/" class="btn btn-outline-primary" prompt="Older"><p>Using Intel's Streaming SIMD Extensions 3 (MONITOR MWAIT) As A Kernel Debugging Trick</p></a> <a href="/topics/hypervisor-from-scratch-part-4/" class="btn btn-outline-primary" prompt="Newer"><p>Hypervisor From Scratch – Part 4: Address Translation Using Extended Page Table (EPT)</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://rayanfam.com/topics/hypervisor-from-scratch-part-3/'; this.page.identifier = '/topics/hypervisor-from-scratch-part-3/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://rayanfam.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/rayanfam">Rayanfam Blog</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-P6M1BDG57Z"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-P6M1BDG57Z'); }); </script>
