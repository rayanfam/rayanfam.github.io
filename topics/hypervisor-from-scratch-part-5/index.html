<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Hypervisor From Scratch – Part 5: Setting up VMCS &amp; Running Guest Code" /><meta name="author" content="Sina Karvandi" /><meta property="og:locale" content="en" /><meta name="description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><meta property="og:description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><link rel="canonical" href="https://rayanfam.com/topics/hypervisor-from-scratch-part-5/" /><meta property="og:url" content="https://rayanfam.com/topics/hypervisor-from-scratch-part-5/" /><meta property="og:site_name" content="Rayanfam Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-12-16T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Hypervisor From Scratch – Part 5: Setting up VMCS &amp; Running Guest Code" /><meta name="twitter:site" content="@Intel80x86" /><meta name="twitter:creator" content="@Sina Karvandi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sina Karvandi"},"dateModified":"2024-07-13T13:14:26+00:00","datePublished":"2018-12-16T00:00:00+00:00","description":"We write about Windows Internals, Hypervisors, Linux, and Networks.","headline":"Hypervisor From Scratch – Part 5: Setting up VMCS &amp; Running Guest Code","mainEntityOfPage":{"@type":"WebPage","@id":"https://rayanfam.com/topics/hypervisor-from-scratch-part-5/"},"url":"https://rayanfam.com/topics/hypervisor-from-scratch-part-5/"}</script><title>Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code | Rayanfam Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Rayanfam Blog"><meta name="application-name" content="Rayanfam Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/images/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Rayanfam Blog</a></div><div class="site-subtitle font-italic">An aggressive out-of-order, superscalar blog...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tutorials/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TUTORIALS</span> </a><li class="nav-item"> <a href="/tools/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TOOLS & SCRIPTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/rayanfam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Intel80x86" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sina','rayanfam.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Intel80x86">Sina Karvandi</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1544918400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2018-12-16 </em> </span> <span> Updated <em class="timeago" data-ts="1720876466" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-07-13 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7037 words"> <em>39 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="../../assets/images/hypervisor-from-scratch-part-5-cover.png" alt="" data-proofer-ignore></p><p><strong>If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out <a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and reversing applications. A free and comprehensive tutorial on hypervisor-based reverse engineering is available at <a href="https://ost2.fyi/dbg3301">OpenSecurityTraining2’s website</a> (<em>preferred</em>) and <a href="https://www.youtube.com/playlist?list=PLUFkSN0XLZ-kF1f143wlw8ujlH2A45nZY">YouTube</a>, which demonstrates numerous practical examples on how to utilize hypervisors for reverse engineering.</strong></p><h2 id="introduction"><span class="mr-2"><strong>Introduction</strong></span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hello and welcome to the fifth part of the “<strong>Hypervisor From Scratch</strong>” tutorial series. Today we will spend our time studying different parts of Virtual Machine Control Structure (VMCS), implementing additional VMX instructions, creating a restore point, setting different VMCS control structures, and at last, we execute <strong>VMLAUNCH</strong> and enter the hardware virtualization world!</p><h2 id="table-of-contents"><span class="mr-2"><strong>Table of contents</strong></span><a href="#table-of-contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><strong>Introduction</strong><li><strong>Table of contents</strong><li><strong>Overview</strong><li><strong>VMX Instructions</strong><ul><li>VMPTRST<li>VMCLEAR<li>VMPTRLD</ul><li><strong>Enhancing VM State Structure</strong><li><strong>Preparing to launch VM</strong><li><strong>Saving a return point</strong><li><strong>Returning to the previous state</strong><li><strong>VMLAUNCH Instruction</strong><li><strong>VMX Controls</strong><ul><li>VM-Execution Controls<li>VM-entry Control Bits<li>VM-exit Control Bits<li>PIN-Based Execution Control</ul><li><strong>Configuring VMCS</strong><ul><li>Gathering machine state for VMCS<li>Setting up VMCS<li>Checking VMCS layout</ul><li><strong>VM-Exit Handler</strong><ul><li>Resume to next instruction</ul><li><strong>VMRESUME Instruction</strong><li><strong>Let’s Test it!</strong><li><strong>Conclusion</strong><li><strong>References</strong></ul><h2 id="overview"><span class="mr-2"><strong>Overview</strong></span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Most of this topic is derived from <strong>Chapter 24 – (VIRTUAL MACHINE CONTROL STRUCTURES) &amp; Chapter 26</strong> – (<strong>VM ENTRIES</strong>) available at Intel 64 and IA-32 architectures software developer’s manual (Intel SDM) combined volumes 3.</p><p>This part is highly inspired by <a href="https://github.com/rohaaan/hypervisor-for-beginners">Hypervisor For Beginner</a>.</p><p>Before reading the rest of this part, make sure to read the <a href="https://rayanfam.com/tutorials">previous parts</a> as it gives you the necessary knowledge to understand the rest of this topic thoroughly.</p><p>The full source code of this tutorial is available on GitHub :</p><p>[<a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch">https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a>]</p><p>Note: Remember that hypervisors change over time because new features are added to the operating systems or new technologies are used. For example, updates to Meltdown &amp; Spectre have made a lot of changes to the hypervisors. So, if you want to use Hypervisor From Scratch in your projects, research, or whatever, you should use the <a href="https://github.com/HyperDbg/HyperDbg"><strong>HyperDbg</strong></a> drivers. <strong>HyperDbg</strong> is actively maintained, stable, and reliable, ensuring you avoid the errors and instability problems that can arise from using older parts of the tutorial series.</p><p><img data-src="../../assets/images/anime-girl-in-city.png" alt="" data-proofer-ignore></p><h2 id="vmx-instructions"><span class="mr-2"><strong>VMX Instructions</strong></span><a href="#vmx-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-3">part 3</a>, we implemented <strong>VMXOFF</strong> function now let’s implement other VMX instructions function. I also make some changes in calling <strong>VMXON</strong> and <strong>VMPTRLD</strong> functions to make it more modular.</p><h3 id="vmptrst"><span class="mr-2"><strong>VMPTRST</strong></span><a href="#vmptrst" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>VMPTRST</strong> instruction stores the current-VMCS pointer into a specified memory address. The operand of this instruction is always 64 bits, and it’s always a location in memory.</p><p>The following function is the implementation of <strong>VMPTRST</strong>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">UINT64</span>
<span class="nf">VmptrstInstruction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PHYSICAL_ADDRESS</span> <span class="n">vmcspa</span><span class="p">;</span>
    <span class="n">vmcspa</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmptrst</span><span class="p">((</span><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vmcspa</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMPTRST %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">vmcspa</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="vmclear"><span class="mr-2"><strong>VMCLEAR</strong></span><a href="#vmclear" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This instruction applies to the VMCS, where the VMCS region resides at the physical address contained in the instruction operand. The instruction ensures that VMCS data for that VMCS (some of these data may be currently maintained on the processor) are copied to the VMCS region in memory. It also initializes some parts of the VMCS region (for example, it sets the launch state of that VMCS to clear).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">ClearVmcsState</span><span class="p">(</span><span class="n">VIRTUAL_MACHINE_STATE</span> <span class="o">*</span> <span class="n">GuestState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Clear the state of the VMCS to inactive</span>
    <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">__vmx_vmclear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GuestState</span><span class="o">-&gt;</span><span class="n">VmcsRegion</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMCS VMCLAEAR Status is : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Otherwise, terminate the VMX</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMCS failed to clear with status %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="n">__vmx_off</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="vmptrld"><span class="mr-2"><strong>VMPTRLD</strong></span><a href="#vmptrld" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This instruction marks the current-VMCS pointer valid and loads it with the physical address in the instruction operand. The instruction fails if its operand is not properly aligned, sets unsupported physical-address bits, or is equal to the <strong>VMXON</strong> pointer. In addition, this instruction fails if the 32 bits in memory referenced by the operand do not match the VMCS revision identifier supported by the processor.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">LoadVmcs</span><span class="p">(</span><span class="n">VIRTUAL_MACHINE_STATE</span> <span class="o">*</span> <span class="n">GuestState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">__vmx_vmptrld</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GuestState</span><span class="o">-&gt;</span><span class="n">VmcsRegion</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMCS failed with status %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In order to implement <strong>VMRESUME</strong>, you need to know about some VMCS fields, so the explanation of the <strong>VMRESUME</strong> instruction is left after we implement <strong>VMLAUNCH</strong>. (Later in this topic)</p><h2 id="enhancing-vm-state-structure"><span class="mr-2"><strong>Enhancing VM State Structure</strong></span><a href="#enhancing-vm-state-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>As I told you earlier, we need a structure to save the state of our virtual machine in each core separately. The following structure is used in the newest version of our hypervisor. We will describe each field in the rest of this topic.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_VIRTUAL_MACHINE_STATE</span>
<span class="p">{</span>
    <span class="n">UINT64</span> <span class="n">VmxoRegion</span><span class="p">;</span>        <span class="c1">// VMXON region</span>
    <span class="n">UINT64</span> <span class="n">VmcsRegion</span><span class="p">;</span>        <span class="c1">// VMCS region</span>
    <span class="n">UINT64</span> <span class="n">Eptp</span><span class="p">;</span>              <span class="c1">// Extended-Page-Table Pointer</span>
    <span class="n">UINT64</span> <span class="n">VmmStack</span><span class="p">;</span>          <span class="c1">// Stack for VMM in VM-Exit State</span>
    <span class="n">UINT64</span> <span class="n">MsrBitmap</span><span class="p">;</span>         <span class="c1">// MSR Bitmap Virtual Address</span>
    <span class="n">UINT64</span> <span class="n">MsrBitmapPhysical</span><span class="p">;</span> <span class="c1">// MSR Bitmap Physical Address</span>

<span class="p">}</span> <span class="n">VIRTUAL_MACHINE_STATE</span><span class="p">,</span> <span class="o">*</span><span class="n">PVIRTUAL_MACHINE_STATE</span><span class="p">;</span>
</pre></table></code></div></div><p>Note that it’s not the final <strong>VIRTUAL_MACHINE_STATE</strong> structure; we’ll enhance it in the future.</p><h2 id="preparing-to-launch-vm"><span class="mr-2"><strong>Preparing to launch VM</strong></span><a href="#preparing-to-launch-vm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In this part, we’re just trying to enhance our hypervisor driver. In the future parts, we will add some user-mode interactions with our driver but for now, let’s start with modifying our <strong>DriverEntry</strong> as it’s the first function that executes when our driver is loaded.</p><p>Besides all the preparation from <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-2/">part 2</a>, we added the following lines to use our <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-2/">part 4</a> (EPT) structures:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>        <span class="c1">//</span>
        <span class="c1">// Initiating EPTP and VMX</span>
        <span class="c1">//</span>
        <span class="n">PEPTP</span> <span class="n">EPTP</span> <span class="o">=</span> <span class="n">InitializeEptp</span><span class="p">();</span>

        <span class="n">InitiateVmx</span><span class="p">();</span>
</pre></table></code></div></div><p>We also added an export to a global variable called “<strong>g_VirtualGuestMemoryAddress</strong>” that holds the address of where our guest code starts.</p><p>Now let’s fill our allocated pages with <strong>\xf4</strong>, which is the hex representation of the <strong>HLT</strong> instruction. I choose <strong>HLT</strong> because, with some special configuration (described below), it’ll cause VM-exit and return the code to the host handler; so, it would be an excellent example for this part.</p><p>After that, we start creating a function called <code class="language-c highlighter-rouge"><span class="n">LaunchVm</span></code>, which is responsible for running our virtual machine on a specific core. We will only test our hypervisor in the <strong>0th</strong> logical processor in this part. In the future part, we’ll extend our hypervisor to virtualize the entire system.</p><p>Keep in mind that every logical core has its own VMCS, and if we want our guest code to run in other logical processors, we should configure each of them separately.</p><p>To run our codes in a certain logical core, we should set the affinity by using the Windows <strong>KeSetSystemAffinityThread</strong> function and choose the specific core’s <strong>VIRTUAL_MACHINE_STATE</strong> as each core has its own separate VMXON and VMCS regions.</p><p>The following code describes how we can run our code in different logical cores.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">LaunchVm</span><span class="p">(</span><span class="kt">int</span> <span class="n">ProcessorID</span><span class="p">,</span> <span class="n">PEPTP</span> <span class="n">EPTP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">======================== Launching VM =============================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">KAFFINITY</span> <span class="n">AffinityMask</span><span class="p">;</span>
    <span class="n">AffinityMask</span> <span class="o">=</span> <span class="n">MathPower</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ProcessorID</span><span class="p">);</span>
    <span class="n">KeSetSystemAffinityThread</span><span class="p">(</span><span class="n">AffinityMask</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*]</span><span class="se">\t\t</span><span class="s">Current thread is executing in %d th logical processor.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ProcessorID</span><span class="p">);</span>

    <span class="n">PAGED_CODE</span><span class="p">();</span>

<span class="p">...</span>
</pre></table></code></div></div><p>Now that we can specify a core number and execute codes in the target core, it’s time should allocate a specific <strong>stack</strong> so that whenever a VM-exit occurs, we can save the registers and call other host functions in vmx-root mode.</p><p>A quick reminder, whenever a vm-exit occurs, the host handler is called in vmx-root mode. When we run the <strong>VMRESUME</strong> instruction, the processor switches to the VMX non-root; thus, every kernel-mode driver and user-mode application are running in <strong>VMX non-root</strong> mode. Only the portion of our driver responsible for handling the host is executed in the VMX root-mode.</p><p>Here we need a stack for host routines. We have two options, the first option is using the current <strong>RSP</strong>, and the second one is using a separated stack. We used a separate location for the stack instead of using the current <strong>RSP</strong> of the driver, but you can use the current stack (RSP) too.</p><p>The following lines are written for allocating and zeroing the stack of our VM-exit handler.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Allocate stack for the VM Exit Handler</span>
    <span class="c1">//</span>
    <span class="n">UINT64</span> <span class="n">VMM_STACK_VA</span>                <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="n">VMM_STACK_SIZE</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
    <span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span> <span class="o">=</span> <span class="n">VMM_STACK_VA</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Error in allocating VMM Stack.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span><span class="p">,</span> <span class="n">VMM_STACK_SIZE</span><span class="p">);</span>
</pre></table></code></div></div><p>Same as above, we’ll allocate a page for the MSR Bitmap and add it to <strong>GuestState</strong>. I’ll describe them later in this topic.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Allocate memory for MSRBitMap</span>
    <span class="c1">//</span>
    <span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">MsrBitmap</span> <span class="o">=</span> <span class="n">MmAllocateNonCachedMemory</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span> <span class="c1">// should be aligned</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">MsrBitmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Error in allocating MSRBitMap.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">MsrBitmap</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">MsrBitmapPhysical</span> <span class="o">=</span> <span class="n">VirtualToPhysicalAddress</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">MsrBitmap</span><span class="p">);</span>
</pre></table></code></div></div><p>The next step is clearing the VMCS state and loading it as the current VMCS in the specific processor (in our case, the 0th logical processor).</p><p>The <code class="language-c highlighter-rouge"><span class="n">ClearVmcsState</span></code> and <code class="language-c highlighter-rouge"><span class="n">LoadVmcs</span></code> functions are used as described above:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Clear the VMCS State</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ClearVmcsState</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">]))</span>
    <span class="p">{</span>
        <span class="k">goto</span> <span class="n">ErrorReturn</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">// Load VMCS (Set the Current VMCS)</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LoadVmcs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">]))</span>
    <span class="p">{</span>
        <span class="k">goto</span> <span class="n">ErrorReturn</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>Now it’s time to set up VMCS. We will thoroughly discuss how to configure the VMCS later in this topic, but for now, assume that there is a function called <code class="language-c highlighter-rouge"><span class="n">SetupVmcs</span></code>, which configures the VMCS structure.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Setting up VMCS.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">SetupVmcs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">],</span> <span class="n">EPTP</span><span class="p">);</span>
</pre></table></code></div></div><p>The last step is to execute the <strong>VMLAUNCH</strong> instruction. Yet we shouldn’t forget to save the current state of the stack (<strong>RSP</strong> &amp; <strong>RBP</strong> registers). It’s because after executing the <strong>VMLAUNCH</strong> instruction, the <strong>RIP</strong> register is changed to the <strong>GUEST_RIP</strong>; thus, we need to save the previous system state so we can return to the normal system routines after returning from VM functions. If we leave the driver with the wrong <strong>RSP</strong> &amp; <strong>RBP</strong> registers, we’ll see a BSOD. For this purpose, the <code class="language-c highlighter-rouge"><span class="n">AsmSaveStateForVmxoff</span></code> function is used.</p><h2 id="saving-a-return-point"><span class="mr-2"><strong>Saving a return point</strong></span><a href="#saving-a-return-point" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For <code class="language-c highlighter-rouge"><span class="n">AsmSaveStateForVmxoff</span></code>, we declare two global variables called <strong>g_StackPointerForReturning</strong>, and <strong>g_BasePointerForReturning</strong>. There is no need to save the <strong>RIP</strong> register as the stack’s return address is always available. Just EXTERN it in the assembly file :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">EXTERN</span> <span class="n">g_StackPointerForReturning</span><span class="o">:</span><span class="n">QWORD</span>
<span class="n">EXTERN</span> <span class="n">g_BasePointerForReturning</span><span class="o">:</span><span class="n">QWORD</span>
</pre></table></code></div></div><p>The implementation of <code class="language-c highlighter-rouge"><span class="n">AsmSaveStateForVmxoff</span></code> :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">AsmSaveStateForVmxoff</span> <span class="n">PROC</span> <span class="n">PUBLIC</span>

	<span class="n">MOV</span> <span class="n">g_StackPointerForReturning</span><span class="p">,</span> <span class="n">RSP</span>
	<span class="n">MOV</span> <span class="n">g_BasePointerForReturning</span><span class="p">,</span> <span class="n">RBP</span>

	<span class="n">RET</span>

<span class="n">AsmSaveStateForVmxoff</span> <span class="n">ENDP</span> 
</pre></table></code></div></div><h2 id="returning-to-the-previous-state"><span class="mr-2"><strong>Returning to the previous state</strong></span><a href="#returning-to-the-previous-state" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>That last step in our hypervisor is returning to the previous system state and turning off the hypervisor.</p><p>We previously saved the system state. Now, we can restore it (<strong>RSP</strong>and <strong>RBP</strong> registers) and clear the stack position.</p><p>Before that, the <strong>VMXOFF</strong> instruction is executed to turn off the hypervisor.</p><p>Take a look at the following code.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="n">AsmVmxoffAndRestoreState</span> <span class="n">PROC</span> <span class="n">PUBLIC</span>

	<span class="n">VMXOFF</span>  <span class="p">;</span> <span class="n">turn</span> <span class="n">it</span> <span class="n">off</span> <span class="n">before</span> <span class="n">existing</span>
	
	<span class="n">MOV</span> <span class="n">RSP</span><span class="p">,</span> <span class="n">g_StackPointerForReturning</span>
	<span class="n">MOV</span> <span class="n">RBP</span><span class="p">,</span> <span class="n">g_BasePointerForReturning</span>
	
	<span class="p">;</span> <span class="n">make</span> <span class="n">rsp</span> <span class="n">point</span> <span class="n">to</span> <span class="n">a</span> <span class="n">correct</span> <span class="k">return</span> <span class="n">point</span>
	<span class="n">ADD</span> <span class="n">RSP</span><span class="p">,</span> <span class="mi">8</span>
	
	<span class="p">;</span> <span class="k">return</span> <span class="n">True</span>

	<span class="n">XOR</span> <span class="n">RAX</span><span class="p">,</span> <span class="n">RAX</span>
	<span class="n">MOV</span> <span class="n">RAX</span><span class="p">,</span> <span class="mi">1</span>
	
	<span class="p">;</span> <span class="k">return</span> <span class="n">section</span>
	
	<span class="n">MOV</span>     <span class="n">RBX</span><span class="p">,</span> <span class="p">[</span><span class="n">RSP</span><span class="o">+</span><span class="mi">28</span><span class="n">h</span><span class="o">+</span><span class="mi">8</span><span class="n">h</span><span class="p">]</span>
	<span class="n">MOV</span>     <span class="n">RSI</span><span class="p">,</span> <span class="p">[</span><span class="n">RSP</span><span class="o">+</span><span class="mi">28</span><span class="n">h</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span>
	<span class="n">ADD</span>     <span class="n">RSP</span><span class="p">,</span> <span class="mo">020</span><span class="n">h</span>
	<span class="n">POP</span>     <span class="n">RDI</span>
	
	<span class="n">RET</span>
	
<span class="n">AsmVmxoffAndRestoreState</span> <span class="n">ENDP</span> 
</pre></table></code></div></div><p>At last, we need to precisely clear the stack. Previously we called the <code class="language-c highlighter-rouge"><span class="n">LaunchVm</span></code> function and ended up in a new <strong>RIP</strong>. To continue the execution normally, we need to clear the stack and return to the location where we called the <code class="language-c highlighter-rouge"><span class="n">LaunchVm</span></code> function. Therefore, in the last part of the above assembly code, which is the “return section”, I used IDA Pro to see the disassembly of the <code class="language-c highlighter-rouge"><span class="n">LaunchVm</span></code>, so we can see how this function clears the stack, and we perform the same so we can return the previous system state gracefully. Hence, the “return section” is copied from the disassemblies of the <code class="language-c highlighter-rouge"><span class="n">LaunchVm</span></code> in IDA Pro.</p><p><img data-src="../../assets/images/launch-vm-return.png" alt="LaunchVm Return Frame" data-proofer-ignore></p><h2 id="vmlaunch-instruction"><span class="mr-2"><strong>VMLAUNCH Instruction</strong></span><a href="#vmlaunch-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>It’s time to talk about the <strong>VMLAUNCH</strong> instruction.</p><p>Take a look at the following code.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmlaunch</span><span class="p">();</span>

    <span class="c1">//</span>
    <span class="c1">// if VMLAUNCH succeeds will never be here!</span>
    <span class="c1">//</span>
    <span class="n">ULONG64</span> <span class="n">ErrorCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ErrorCode</span><span class="p">);</span>
    <span class="n">__vmx_off</span><span class="p">();</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMLAUNCH Error : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="p">);</span>
    <span class="n">DbgBreakPoint</span><span class="p">();</span>
</pre></table></code></div></div><p>The <code class="language-c highlighter-rouge"><span class="n">__vmx_vmlaunch</span><span class="p">()</span></code> is the intrinsic function for the <strong>VMLAUNCH</strong> instruction and <code class="language-c highlighter-rouge"><span class="n">__vmx_vmread</span></code> is for the <strong>VMREAD</strong> instruction.</p><p>As the comment describes, if <strong>VMLAUNCH</strong> succeeds, we’ll never execute the other lines. If there is an error in the state of VMCS (which is a common problem), we have to run <strong>VMREAD ** and read the error code from the **VM_INSTRUCTION_ERROR</strong> field of VMCS. It’s also necessary to run VMXOFF to turn off the hypervisor in the case of an error, and finally, we can print the error code.</p><p><strong>DbgBreakPoint</strong> is just a debug breakpoint (int 3), and it can be helpful only if we’re working on a remote kernel WinDbg Debugger. It’s clear that you can’t test it in your local debugging system because executing an <strong>int 3</strong> in the kernel will freeze your system as long as there is no debugger to catch it, so it’s highly recommended to create a remote Kernel Debugging machine and test your codes for possible errors.</p><p>You can also use VMware Workstation’s nested-virtualization to create a remote kernel debugging connection. Intel doesn’t have such a thing as “nested-virtualization” but provides some hardware facilities so vendors can support and implement nested virtualization on their own. For example, you can test your driver on VMware Workstation with nested-virtualization support (I also explained how to debug your hypervisor driver on VMware in the first part.) However, supporting Hyper-V nested virtualization needs extra things to be considered in implementing a hypervisor, so we can’t test our driver on Hyper-V nested virtualization, at least for this part. I’ll explain Hyper-V support in the 8th part.</p><p>The drivers are tested on both physical machines and VMware Workstation’s nested-virtualization.</p><p>Now it’s time to read some theories before digging into the configuration of the VMCS.</p><h2 id="vmx-controls"><span class="mr-2"><strong>VMX Controls</strong></span><a href="#vmx-controls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Let’s talk about different controls in VMCS that govern the guest’s behavior. We will use some of these bits in this part, and some will be used in future parts. So, don’t worry about it. Just take a look at the descriptions of these bits and be aware of them.</p><h3 id="vm-execution-controls"><span class="mr-2"><strong>VM-Execution Controls</strong></span><a href="#vm-execution-controls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>In order to control our guest features, we have to set some fields in our VMCS. The following tables represent the Primary Processor-Based VM-Execution Controls and the Secondary Processor-Based VM-Execution Controls.</p><p><img data-src="../../assets/images/primary-processor-based-vm-execution-controls-fields.png" alt="Primary-Processor-Based-VM-Execution-Controls" data-proofer-ignore></p><p>We define the above table like this:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#define CPU_BASED_VIRTUAL_INTR_PENDING        0x00000004
#define CPU_BASED_USE_TSC_OFFSETING           0x00000008
#define CPU_BASED_HLT_EXITING                 0x00000080
#define CPU_BASED_INVLPG_EXITING              0x00000200
#define CPU_BASED_MWAIT_EXITING               0x00000400
#define CPU_BASED_RDPMC_EXITING               0x00000800
#define CPU_BASED_RDTSC_EXITING               0x00001000
#define CPU_BASED_CR3_LOAD_EXITING            0x00008000
#define CPU_BASED_CR3_STORE_EXITING           0x00010000
#define CPU_BASED_CR8_LOAD_EXITING            0x00080000
#define CPU_BASED_CR8_STORE_EXITING           0x00100000
#define CPU_BASED_TPR_SHADOW                  0x00200000
#define CPU_BASED_VIRTUAL_NMI_PENDING         0x00400000
#define CPU_BASED_MOV_DR_EXITING              0x00800000
#define CPU_BASED_UNCOND_IO_EXITING           0x01000000
#define CPU_BASED_ACTIVATE_IO_BITMAP          0x02000000
#define CPU_BASED_MONITOR_TRAP_FLAG           0x08000000
#define CPU_BASED_ACTIVATE_MSR_BITMAP         0x10000000
#define CPU_BASED_MONITOR_EXITING             0x20000000
#define CPU_BASED_PAUSE_EXITING               0x40000000
#define CPU_BASED_ACTIVATE_SECONDARY_CONTROLS 0x80000000
</span></pre></table></code></div></div><p>In the earlier versions of VMX, there was nothing like Secondary Processor-Based VM-Execution Controls. Now, if we want to use the secondary table, we have to set the 31st bit of the first table; otherwise, it’s like the secondary table field with zeros.</p><p><img data-src="../../assets/images/secondary-processor-based-vm-execution-controls-fields.png" alt="Secondary-Processor-Based-VM-Execution-Controls" data-proofer-ignore></p><p>The definition of the above table is this (we ignore some bits, you can define them if you want to use them in your hypervisor):</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define CPU_BASED_CTL2_ENABLE_EPT            0x2
#define CPU_BASED_CTL2_RDTSCP                0x8
#define CPU_BASED_CTL2_ENABLE_VPID            0x20
#define CPU_BASED_CTL2_UNRESTRICTED_GUEST    0x80
#define CPU_BASED_CTL2_ENABLE_VMFUNC        0x2000
</span></pre></table></code></div></div><h3 id="vm-entry-control-bits"><span class="mr-2"><strong>VM-entry Control Bits</strong></span><a href="#vm-entry-control-bits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The VM-entry controls constitute a 32-bit vector that governs the basic operation of VM entries.</p><p><img data-src="../../assets/images/vm-entry-controls-fields.png" alt="VM-Entry-Controls" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// VM-entry Control Bits </span>
<span class="cp">#define VM_ENTRY_IA32E_MODE             0x00000200
#define VM_ENTRY_SMM                    0x00000400
#define VM_ENTRY_DEACT_DUAL_MONITOR     0x00000800
#define VM_ENTRY_LOAD_GUEST_PAT         0x00004000
</span></pre></table></code></div></div><h3 id="vm-exit-control-bits"><span class="mr-2"><strong>VM-exit Control Bits</strong></span><a href="#vm-exit-control-bits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The VM-exit controls constitute a 32-bit vector that governs the essential operation of VM-exits.</p><p><img data-src="../../assets/images/vm-exit-controls-fields.png" alt="VM-Exit-Controls" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// VM-exit Control Bits </span>
<span class="cp">#define VM_EXIT_IA32E_MODE              0x00000200
#define VM_EXIT_ACK_INTR_ON_EXIT        0x00008000
#define VM_EXIT_SAVE_GUEST_PAT          0x00040000
#define VM_EXIT_LOAD_HOST_PAT           0x00080000
</span></pre></table></code></div></div><h3 id="pin-based-execution-control"><span class="mr-2"><strong>PIN-Based Execution Control</strong></span><a href="#pin-based-execution-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The pin-based VM-execution controls constitute a 32-bit vector that governs the handling of asynchronous events (for example, interrupts). We’ll use it in the future parts, but for now, let’s define it in our hypervisor.</p><p><img data-src="../../assets/images/pin-based-vm-execution-controls-fields.png" alt="Pin-Based-VM-Execution-Controls" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define PIN_BASED_VM_EXECUTION_CONTROLS_EXTERNAL_INTERRUPT        0x00000001
#define PIN_BASED_VM_EXECUTION_CONTROLS_NMI_EXITING               0x00000008
#define PIN_BASED_VM_EXECUTION_CONTROLS_VIRTUAL_NMI               0x00000020
#define PIN_BASED_VM_EXECUTION_CONTROLS_ACTIVE_VMX_TIMER          0x00000040
#define PIN_BASED_VM_EXECUTION_CONTROLS_PROCESS_POSTED_INTERRUPTS 0x00000080
</span></pre></table></code></div></div><h2 id="configuring-vmcs"><span class="mr-2"><strong>Configuring VMCS</strong></span><a href="#configuring-vmcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that we have a basic idea about some of the VMCS fields and controls, it’s time to configure the VMCS structure fully to make our virtualized guest ready.</p><h3 id="gathering-machine-state-for-vmcs"><span class="mr-2"><strong>Gathering machine state for VMCS</strong></span><a href="#gathering-machine-state-for-vmcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>In order to configure our <strong>Guest-State</strong> and <strong>Host-State</strong>, we need to have details about the current system state, e.g., <strong>G</strong>lobal <strong>D</strong>escriptor <strong>T</strong>able Address (GDT), <strong>I</strong>nterrupt <strong>D</strong>escriptor <strong>T</strong>able (IDT) Address and read all the Segment Registers.</p><p>These functions describe how all of these registers and segments can be gathered.</p><p>GDT Base :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">GetGdtBase</span> <span class="n">PROC</span>

	<span class="n">LOCAL</span>	<span class="n">GDTR</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">:</span><span class="n">BYTE</span>
	<span class="n">SGDT</span>	<span class="n">GDTR</span>
	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="n">GDTR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

	<span class="n">RET</span>

<span class="n">GetGdtBase</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>CS segment register:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetCs</span> <span class="n">PROC</span>

	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">CS</span>
	<span class="n">RET</span>

<span class="n">GetCs</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>DS segment register:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetDs</span> <span class="n">PROC</span>

	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">DS</span>
	<span class="n">RET</span>

<span class="n">GetDs</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>ES segment register:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetEs</span> <span class="n">PROC</span>

	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">ES</span>
	<span class="n">RET</span>

<span class="n">GetEs</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>SS segment register:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetSs</span> <span class="n">PROC</span>

	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">SS</span>
	<span class="n">RET</span>

<span class="n">GetSs</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>FS segment register:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetFs</span> <span class="n">PROC</span>

	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">FS</span>
	<span class="n">RET</span>

<span class="n">GetFs</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>GS segment register:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetGs</span> <span class="n">PROC</span>

	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">GS</span>
	<span class="n">RET</span>

<span class="n">GetGs</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>LDT:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetLdtr</span> <span class="n">PROC</span>

	<span class="n">SLDT</span>	<span class="n">RAX</span>
	<span class="n">RET</span>

<span class="n">GetLdtr</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>TR (task register):</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GetTr</span> <span class="n">PROC</span>

	<span class="n">STR</span>		<span class="n">RAX</span>
	<span class="n">RET</span>

<span class="n">GetTr</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>Interrupt Descriptor Table:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">GetIdtBase</span> <span class="n">PROC</span>

	<span class="n">LOCAL</span>	<span class="n">IDTR</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">:</span><span class="n">BYTE</span>
	
	<span class="n">SIDT</span>	<span class="n">IDTR</span>
	<span class="n">MOV</span>		<span class="n">RAX</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="n">IDTR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="n">RET</span>

<span class="n">GetIdtBase</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>GDT Limit:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">GetGdtLimit</span> <span class="n">PROC</span>

	<span class="n">LOCAL</span>	<span class="n">GDTR</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">:</span><span class="n">BYTE</span>

	<span class="n">SGDT</span>	<span class="n">GDTR</span>
	<span class="n">MOV</span>		<span class="n">AX</span><span class="p">,</span> <span class="n">WORD</span> <span class="n">PTR</span> <span class="n">GDTR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="n">RET</span>

<span class="n">GetGdtLimit</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>IDT Limit:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">GetIdtLimit</span> <span class="n">PROC</span>

	<span class="n">LOCAL</span>	<span class="n">IDTR</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">:</span><span class="n">BYTE</span>
	
	<span class="n">SIDT</span>	<span class="n">IDTR</span>
	<span class="n">MOV</span>		<span class="n">AX</span><span class="p">,</span> <span class="n">WORD</span> <span class="n">PTR</span> <span class="n">IDTR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="n">RET</span>

<span class="n">GetIdtLimit</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>RFLAGS:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">GetRflags</span> <span class="n">PROC</span>

	<span class="n">PUSHFQ</span>
	<span class="n">POP</span>		<span class="n">RAX</span>
	<span class="n">RET</span>

<span class="n">GetRflags</span> <span class="n">ENDP</span>
</pre></table></code></div></div><h3 id="setting-up-vmcs"><span class="mr-2"><strong>Setting up VMCS</strong></span><a href="#setting-up-vmcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Let’s get down to business (we have a long way to go).</p><p>This section starts with defining a function called <code class="language-c highlighter-rouge"><span class="n">SetupVmcs</span></code>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">SetupVmcs</span><span class="p">(</span><span class="n">VIRTUAL_MACHINE_STATE</span> <span class="o">*</span> <span class="n">GuestState</span><span class="p">,</span> <span class="n">PEPTP</span> <span class="n">EPTP</span><span class="p">);</span>
</pre></table></code></div></div><p>This function is responsible for configuring all of the options related to VMCS and, of course, the Guest &amp; Host state.</p><p>Configuring and modifying VMCS is done by using a special instruction called “<strong>VMWRITE</strong>”.</p><p><strong>VMWRITE</strong> writes the contents of a primary source operand (register or memory) to a specified field in a VMCS. In VMX-root operation, the instruction writes to the current VMCS. If executed in VMX non-root operation, the instruction writes to the VMCS referenced by the VMCS link pointer field in the current VMCS.</p><p>The VMCS field is specified by the VMCS-field encoding contained in the register secondary source operand.</p><p>The following <strong>enum</strong> contains most of the VMCS fields needed for <strong>VMWRITE</strong> &amp; <strong>VMREAD</strong> instructions. (newer processors add newer fields.)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">VMCS_FIELDS</span> <span class="p">{</span>
    <span class="n">GUEST_ES_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000800</span><span class="p">,</span>
    <span class="n">GUEST_CS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000802</span><span class="p">,</span>
    <span class="n">GUEST_SS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000804</span><span class="p">,</span>
    <span class="n">GUEST_DS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000806</span><span class="p">,</span>
    <span class="n">GUEST_FS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000808</span><span class="p">,</span>
    <span class="n">GUEST_GS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x0000080a</span><span class="p">,</span>
    <span class="n">GUEST_LDTR_SELECTOR</span> <span class="o">=</span> <span class="mh">0x0000080c</span><span class="p">,</span>
    <span class="n">GUEST_TR_SELECTOR</span> <span class="o">=</span> <span class="mh">0x0000080e</span><span class="p">,</span>
    <span class="n">HOST_ES_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c00</span><span class="p">,</span>
    <span class="n">HOST_CS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c02</span><span class="p">,</span>
    <span class="n">HOST_SS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c04</span><span class="p">,</span>
    <span class="n">HOST_DS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c06</span><span class="p">,</span>
    <span class="n">HOST_FS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c08</span><span class="p">,</span>
    <span class="n">HOST_GS_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c0a</span><span class="p">,</span>
    <span class="n">HOST_TR_SELECTOR</span> <span class="o">=</span> <span class="mh">0x00000c0c</span><span class="p">,</span>
    <span class="n">IO_BITMAP_A</span> <span class="o">=</span> <span class="mh">0x00002000</span><span class="p">,</span>
    <span class="n">IO_BITMAP_A_HIGH</span> <span class="o">=</span> <span class="mh">0x00002001</span><span class="p">,</span>
    <span class="n">IO_BITMAP_B</span> <span class="o">=</span> <span class="mh">0x00002002</span><span class="p">,</span>
    <span class="n">IO_BITMAP_B_HIGH</span> <span class="o">=</span> <span class="mh">0x00002003</span><span class="p">,</span>
    <span class="n">MSR_BITMAP</span> <span class="o">=</span> <span class="mh">0x00002004</span><span class="p">,</span>
    <span class="n">MSR_BITMAP_HIGH</span> <span class="o">=</span> <span class="mh">0x00002005</span><span class="p">,</span>
    <span class="n">VM_EXIT_MSR_STORE_ADDR</span> <span class="o">=</span> <span class="mh">0x00002006</span><span class="p">,</span>
    <span class="n">VM_EXIT_MSR_STORE_ADDR_HIGH</span> <span class="o">=</span> <span class="mh">0x00002007</span><span class="p">,</span>
    <span class="n">VM_EXIT_MSR_LOAD_ADDR</span> <span class="o">=</span> <span class="mh">0x00002008</span><span class="p">,</span>
    <span class="n">VM_EXIT_MSR_LOAD_ADDR_HIGH</span> <span class="o">=</span> <span class="mh">0x00002009</span><span class="p">,</span>
    <span class="n">VM_ENTRY_MSR_LOAD_ADDR</span> <span class="o">=</span> <span class="mh">0x0000200a</span><span class="p">,</span>
    <span class="n">VM_ENTRY_MSR_LOAD_ADDR_HIGH</span> <span class="o">=</span> <span class="mh">0x0000200b</span><span class="p">,</span>
    <span class="n">TSC_OFFSET</span> <span class="o">=</span> <span class="mh">0x00002010</span><span class="p">,</span>
    <span class="n">TSC_OFFSET_HIGH</span> <span class="o">=</span> <span class="mh">0x00002011</span><span class="p">,</span>
    <span class="n">VIRTUAL_APIC_PAGE_ADDR</span> <span class="o">=</span> <span class="mh">0x00002012</span><span class="p">,</span>
    <span class="n">VIRTUAL_APIC_PAGE_ADDR_HIGH</span> <span class="o">=</span> <span class="mh">0x00002013</span><span class="p">,</span>
    <span class="n">VMFUNC_CONTROLS</span> <span class="o">=</span> <span class="mh">0x00002018</span><span class="p">,</span>
    <span class="n">VMFUNC_CONTROLS_HIGH</span> <span class="o">=</span> <span class="mh">0x00002019</span><span class="p">,</span>
    <span class="n">EPT_POINTER</span> <span class="o">=</span> <span class="mh">0x0000201A</span><span class="p">,</span>
    <span class="n">EPT_POINTER_HIGH</span> <span class="o">=</span> <span class="mh">0x0000201B</span><span class="p">,</span>
    <span class="n">EPTP_LIST</span> <span class="o">=</span> <span class="mh">0x00002024</span><span class="p">,</span>
    <span class="n">EPTP_LIST_HIGH</span> <span class="o">=</span> <span class="mh">0x00002025</span><span class="p">,</span>
    <span class="n">GUEST_PHYSICAL_ADDRESS</span> <span class="o">=</span> <span class="mh">0x2400</span><span class="p">,</span>
    <span class="n">GUEST_PHYSICAL_ADDRESS_HIGH</span> <span class="o">=</span> <span class="mh">0x2401</span><span class="p">,</span>
    <span class="n">VMCS_LINK_POINTER</span> <span class="o">=</span> <span class="mh">0x00002800</span><span class="p">,</span>
    <span class="n">VMCS_LINK_POINTER_HIGH</span> <span class="o">=</span> <span class="mh">0x00002801</span><span class="p">,</span>
    <span class="n">GUEST_IA32_DEBUGCTL</span> <span class="o">=</span> <span class="mh">0x00002802</span><span class="p">,</span>
    <span class="n">GUEST_IA32_DEBUGCTL_HIGH</span> <span class="o">=</span> <span class="mh">0x00002803</span><span class="p">,</span>
    <span class="n">PIN_BASED_VM_EXEC_CONTROL</span> <span class="o">=</span> <span class="mh">0x00004000</span><span class="p">,</span>
    <span class="n">CPU_BASED_VM_EXEC_CONTROL</span> <span class="o">=</span> <span class="mh">0x00004002</span><span class="p">,</span>
    <span class="n">EXCEPTION_BITMAP</span> <span class="o">=</span> <span class="mh">0x00004004</span><span class="p">,</span>
    <span class="n">PAGE_FAULT_ERROR_CODE_MASK</span> <span class="o">=</span> <span class="mh">0x00004006</span><span class="p">,</span>
    <span class="n">PAGE_FAULT_ERROR_CODE_MATCH</span> <span class="o">=</span> <span class="mh">0x00004008</span><span class="p">,</span>
    <span class="n">CR3_TARGET_COUNT</span> <span class="o">=</span> <span class="mh">0x0000400a</span><span class="p">,</span>
    <span class="n">VM_EXIT_CONTROLS</span> <span class="o">=</span> <span class="mh">0x0000400c</span><span class="p">,</span>
    <span class="n">VM_EXIT_MSR_STORE_COUNT</span> <span class="o">=</span> <span class="mh">0x0000400e</span><span class="p">,</span>
    <span class="n">VM_EXIT_MSR_LOAD_COUNT</span> <span class="o">=</span> <span class="mh">0x00004010</span><span class="p">,</span>
    <span class="n">VM_ENTRY_CONTROLS</span> <span class="o">=</span> <span class="mh">0x00004012</span><span class="p">,</span>
    <span class="n">VM_ENTRY_MSR_LOAD_COUNT</span> <span class="o">=</span> <span class="mh">0x00004014</span><span class="p">,</span>
    <span class="n">VM_ENTRY_INTR_INFO_FIELD</span> <span class="o">=</span> <span class="mh">0x00004016</span><span class="p">,</span>
    <span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span> <span class="o">=</span> <span class="mh">0x00004018</span><span class="p">,</span>
    <span class="n">VM_ENTRY_INSTRUCTION_LEN</span> <span class="o">=</span> <span class="mh">0x0000401a</span><span class="p">,</span>
    <span class="n">TPR_THRESHOLD</span> <span class="o">=</span> <span class="mh">0x0000401c</span><span class="p">,</span>
    <span class="n">SECONDARY_VM_EXEC_CONTROL</span> <span class="o">=</span> <span class="mh">0x0000401e</span><span class="p">,</span>
    <span class="n">VM_INSTRUCTION_ERROR</span> <span class="o">=</span> <span class="mh">0x00004400</span><span class="p">,</span>
    <span class="n">VM_EXIT_REASON</span> <span class="o">=</span> <span class="mh">0x00004402</span><span class="p">,</span>
    <span class="n">VM_EXIT_INTR_INFO</span> <span class="o">=</span> <span class="mh">0x00004404</span><span class="p">,</span>
    <span class="n">VM_EXIT_INTR_ERROR_CODE</span> <span class="o">=</span> <span class="mh">0x00004406</span><span class="p">,</span>
    <span class="n">IDT_VECTORING_INFO_FIELD</span> <span class="o">=</span> <span class="mh">0x00004408</span><span class="p">,</span>
    <span class="n">IDT_VECTORING_ERROR_CODE</span> <span class="o">=</span> <span class="mh">0x0000440a</span><span class="p">,</span>
    <span class="n">VM_EXIT_INSTRUCTION_LEN</span> <span class="o">=</span> <span class="mh">0x0000440c</span><span class="p">,</span>
    <span class="n">VMX_INSTRUCTION_INFO</span> <span class="o">=</span> <span class="mh">0x0000440e</span><span class="p">,</span>
    <span class="n">GUEST_ES_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004800</span><span class="p">,</span>
    <span class="n">GUEST_CS_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004802</span><span class="p">,</span>
    <span class="n">GUEST_SS_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004804</span><span class="p">,</span>
    <span class="n">GUEST_DS_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004806</span><span class="p">,</span>
    <span class="n">GUEST_FS_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004808</span><span class="p">,</span>
    <span class="n">GUEST_GS_LIMIT</span> <span class="o">=</span> <span class="mh">0x0000480a</span><span class="p">,</span>
    <span class="n">GUEST_LDTR_LIMIT</span> <span class="o">=</span> <span class="mh">0x0000480c</span><span class="p">,</span>
    <span class="n">GUEST_TR_LIMIT</span> <span class="o">=</span> <span class="mh">0x0000480e</span><span class="p">,</span>
    <span class="n">GUEST_GDTR_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004810</span><span class="p">,</span>
    <span class="n">GUEST_IDTR_LIMIT</span> <span class="o">=</span> <span class="mh">0x00004812</span><span class="p">,</span>
    <span class="n">GUEST_ES_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x00004814</span><span class="p">,</span>
    <span class="n">GUEST_CS_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x00004816</span><span class="p">,</span>
    <span class="n">GUEST_SS_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x00004818</span><span class="p">,</span>
    <span class="n">GUEST_DS_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x0000481a</span><span class="p">,</span>
    <span class="n">GUEST_FS_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x0000481c</span><span class="p">,</span>
    <span class="n">GUEST_GS_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x0000481e</span><span class="p">,</span>
    <span class="n">GUEST_LDTR_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x00004820</span><span class="p">,</span>
    <span class="n">GUEST_TR_AR_BYTES</span> <span class="o">=</span> <span class="mh">0x00004822</span><span class="p">,</span>
    <span class="n">GUEST_INTERRUPTIBILITY_INFO</span> <span class="o">=</span> <span class="mh">0x00004824</span><span class="p">,</span>
    <span class="n">GUEST_ACTIVITY_STATE</span> <span class="o">=</span> <span class="mh">0x00004826</span><span class="p">,</span>
    <span class="n">GUEST_SM_BASE</span> <span class="o">=</span> <span class="mh">0x00004828</span><span class="p">,</span>
    <span class="n">GUEST_SYSENTER_CS</span> <span class="o">=</span> <span class="mh">0x0000482A</span><span class="p">,</span>
    <span class="n">HOST_IA32_SYSENTER_CS</span> <span class="o">=</span> <span class="mh">0x00004c00</span><span class="p">,</span>
    <span class="n">CR0_GUEST_HOST_MASK</span> <span class="o">=</span> <span class="mh">0x00006000</span><span class="p">,</span>
    <span class="n">CR4_GUEST_HOST_MASK</span> <span class="o">=</span> <span class="mh">0x00006002</span><span class="p">,</span>
    <span class="n">CR0_READ_SHADOW</span> <span class="o">=</span> <span class="mh">0x00006004</span><span class="p">,</span>
    <span class="n">CR4_READ_SHADOW</span> <span class="o">=</span> <span class="mh">0x00006006</span><span class="p">,</span>
    <span class="n">CR3_TARGET_VALUE0</span> <span class="o">=</span> <span class="mh">0x00006008</span><span class="p">,</span>
    <span class="n">CR3_TARGET_VALUE1</span> <span class="o">=</span> <span class="mh">0x0000600a</span><span class="p">,</span>
    <span class="n">CR3_TARGET_VALUE2</span> <span class="o">=</span> <span class="mh">0x0000600c</span><span class="p">,</span>
    <span class="n">CR3_TARGET_VALUE3</span> <span class="o">=</span> <span class="mh">0x0000600e</span><span class="p">,</span>
    <span class="n">EXIT_QUALIFICATION</span> <span class="o">=</span> <span class="mh">0x00006400</span><span class="p">,</span>
    <span class="n">GUEST_LINEAR_ADDRESS</span> <span class="o">=</span> <span class="mh">0x0000640a</span><span class="p">,</span>
    <span class="n">GUEST_CR0</span> <span class="o">=</span> <span class="mh">0x00006800</span><span class="p">,</span>
    <span class="n">GUEST_CR3</span> <span class="o">=</span> <span class="mh">0x00006802</span><span class="p">,</span>
    <span class="n">GUEST_CR4</span> <span class="o">=</span> <span class="mh">0x00006804</span><span class="p">,</span>
    <span class="n">GUEST_ES_BASE</span> <span class="o">=</span> <span class="mh">0x00006806</span><span class="p">,</span>
    <span class="n">GUEST_CS_BASE</span> <span class="o">=</span> <span class="mh">0x00006808</span><span class="p">,</span>
    <span class="n">GUEST_SS_BASE</span> <span class="o">=</span> <span class="mh">0x0000680a</span><span class="p">,</span>
    <span class="n">GUEST_DS_BASE</span> <span class="o">=</span> <span class="mh">0x0000680c</span><span class="p">,</span>
    <span class="n">GUEST_FS_BASE</span> <span class="o">=</span> <span class="mh">0x0000680e</span><span class="p">,</span>
    <span class="n">GUEST_GS_BASE</span> <span class="o">=</span> <span class="mh">0x00006810</span><span class="p">,</span>
    <span class="n">GUEST_LDTR_BASE</span> <span class="o">=</span> <span class="mh">0x00006812</span><span class="p">,</span>
    <span class="n">GUEST_TR_BASE</span> <span class="o">=</span> <span class="mh">0x00006814</span><span class="p">,</span>
    <span class="n">GUEST_GDTR_BASE</span> <span class="o">=</span> <span class="mh">0x00006816</span><span class="p">,</span>
    <span class="n">GUEST_IDTR_BASE</span> <span class="o">=</span> <span class="mh">0x00006818</span><span class="p">,</span>
    <span class="n">GUEST_DR7</span> <span class="o">=</span> <span class="mh">0x0000681a</span><span class="p">,</span>
    <span class="n">GUEST_RSP</span> <span class="o">=</span> <span class="mh">0x0000681c</span><span class="p">,</span>
    <span class="n">GUEST_RIP</span> <span class="o">=</span> <span class="mh">0x0000681e</span><span class="p">,</span>
    <span class="n">GUEST_RFLAGS</span> <span class="o">=</span> <span class="mh">0x00006820</span><span class="p">,</span>
    <span class="n">GUEST_PENDING_DBG_EXCEPTIONS</span> <span class="o">=</span> <span class="mh">0x00006822</span><span class="p">,</span>
    <span class="n">GUEST_SYSENTER_ESP</span> <span class="o">=</span> <span class="mh">0x00006824</span><span class="p">,</span>
    <span class="n">GUEST_SYSENTER_EIP</span> <span class="o">=</span> <span class="mh">0x00006826</span><span class="p">,</span>
    <span class="n">HOST_CR0</span> <span class="o">=</span> <span class="mh">0x00006c00</span><span class="p">,</span>
    <span class="n">HOST_CR3</span> <span class="o">=</span> <span class="mh">0x00006c02</span><span class="p">,</span>
    <span class="n">HOST_CR4</span> <span class="o">=</span> <span class="mh">0x00006c04</span><span class="p">,</span>
    <span class="n">HOST_FS_BASE</span> <span class="o">=</span> <span class="mh">0x00006c06</span><span class="p">,</span>
    <span class="n">HOST_GS_BASE</span> <span class="o">=</span> <span class="mh">0x00006c08</span><span class="p">,</span>
    <span class="n">HOST_TR_BASE</span> <span class="o">=</span> <span class="mh">0x00006c0a</span><span class="p">,</span>
    <span class="n">HOST_GDTR_BASE</span> <span class="o">=</span> <span class="mh">0x00006c0c</span><span class="p">,</span>
    <span class="n">HOST_IDTR_BASE</span> <span class="o">=</span> <span class="mh">0x00006c0e</span><span class="p">,</span>
    <span class="n">HOST_IA32_SYSENTER_ESP</span> <span class="o">=</span> <span class="mh">0x00006c10</span><span class="p">,</span>
    <span class="n">HOST_IA32_SYSENTER_EIP</span> <span class="o">=</span> <span class="mh">0x00006c12</span><span class="p">,</span>
    <span class="n">HOST_RSP</span> <span class="o">=</span> <span class="mh">0x00006c14</span><span class="p">,</span>
    <span class="n">HOST_RIP</span> <span class="o">=</span> <span class="mh">0x00006c16</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><p>OK, let’s continue with our configuration.</p><p>The next step is configuring <strong>host</strong> Segment Registers.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_ES_SELECTOR</span><span class="p">,</span> <span class="n">GetEs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_CS_SELECTOR</span><span class="p">,</span> <span class="n">GetCs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_SS_SELECTOR</span><span class="p">,</span> <span class="n">GetSs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_DS_SELECTOR</span><span class="p">,</span> <span class="n">GetDs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_FS_SELECTOR</span><span class="p">,</span> <span class="n">GetFs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_GS_SELECTOR</span><span class="p">,</span> <span class="n">GetGs</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_TR_SELECTOR</span><span class="p">,</span> <span class="n">GetTr</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">);</span>
</pre></table></code></div></div><p>Keep in mind that those fields that start with “<strong>HOST_</strong>” are related to the state in which the hypervisor sets whenever a VM-exit occurs, and those which begin with “<strong>GUEST_</strong>” are related to the state in which the hypervisor sets for guest when a <strong>VMLAUNCH</strong> executed.</p><p>The purpose of <code class="language-c highlighter-rouge"><span class="o">&amp;</span> <span class="mh">0xF8</span></code> is that Intel mentioned that the three less significant bits must be cleared; otherwise, it leads to an error as the <strong>VMLAUNCH</strong> is executed with an <em>Invalid Host State</em> error.</p><p>Next, we set the <code class="language-c highlighter-rouge"><span class="n">VMCS_LINK_POINTER</span></code>, which should be ‘0xffffffffffffffff’. As we don’t have an additional VMCS. This field is mainly used for hypervisors that want to implement a nested-virtualization behavior (like VMware Nested Virtualization or KVM’s nVMX).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Setting the link pointer to the required value for 4KB VMCS</span>
    <span class="c1">//</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VMCS_LINK_POINTER</span><span class="p">,</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">);</span>
</pre></table></code></div></div><p>The rest of this topic intends to virtualize the machine’s current state, so the guest and host configurations must be the same.</p><p>Let’s configure <strong>GUEST_IA32_DEBUGCTL</strong>. This field works the same as the <strong>IA32_DEBUGCTL</strong> MSR in a physical machine, and we can use it if we want to use separate <strong>IA32_DEBUGCTL</strong> for each guest. It provides bit field controls to enable debug trace interrupts, debug trace stores, trace messages enable, single stepping on branches, last branch record recording, and control freezing of LBR stack.</p><p>We don’t use it in our hypervisor, but we should configure it to the current machine’s <strong>MSR_IA32_DEBUGCTL</strong>. We use <code class="language-c highlighter-rouge"><span class="n">__readmsr</span><span class="p">()</span></code> intrinsic to read this MSR (RDMSR) and put the value of the physical machine to the guest’s <code class="language-c highlighter-rouge"><span class="n">GUEST_IA32_DEBUGCTL</span></code>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_IA32_DEBUGCTL</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_IA32_DEBUGCTL_HIGH</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
</pre></table></code></div></div><p>Note that values we put zero on them can be ignored; if you don’t modify them, it’s like you put zero on them.</p><p>For example, configuring TSC is not important for our hypervisor in the current state, so we put zero on it.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="cm">/* Time-stamp counter offset */</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">TSC_OFFSET_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MATCH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_EXIT_MSR_STORE_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>This time, we’ll configure Segment Registers based on the GDT base address for our Host (When VM-Exit occurs).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="n">GdtBase</span> <span class="o">=</span> <span class="n">GetGdtBase</span><span class="p">();</span>

    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">ES</span><span class="p">,</span> <span class="n">GetEs</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">CS</span><span class="p">,</span> <span class="n">GetCs</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">GetSs</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">DS</span><span class="p">,</span> <span class="n">GetDs</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">GetFs</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">GS</span><span class="p">,</span> <span class="n">GetGs</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">LDTR</span><span class="p">,</span> <span class="n">GetLdtr</span><span class="p">());</span>
    <span class="n">FillGuestSelectorData</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GdtBase</span><span class="p">,</span> <span class="n">TR</span><span class="p">,</span> <span class="n">GetTr</span><span class="p">());</span>
</pre></table></code></div></div><p><code class="language-c highlighter-rouge"><span class="n">GetGdtBase</span></code> is defined above in the process of gathering information for our VMCS.</p><p><code class="language-c highlighter-rouge"><span class="n">FillGuestSelectorData</span></code> is responsible for setting the GUEST selector, attributes, limit, and base for VMCS. It is implemented as below:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">FillGuestSelectorData</span><span class="p">(</span>
    <span class="n">PVOID</span>  <span class="n">GdtBase</span><span class="p">,</span>
    <span class="n">ULONG</span>  <span class="n">Segreg</span><span class="p">,</span>
    <span class="n">USHORT</span> <span class="n">Selector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SEGMENT_SELECTOR</span> <span class="n">SegmentSelector</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">ULONG</span>            <span class="n">AccessRights</span><span class="p">;</span>

    <span class="n">GetSegmentDescriptor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SegmentSelector</span><span class="p">,</span> <span class="n">Selector</span><span class="p">,</span> <span class="n">GdtBase</span><span class="p">);</span>
    <span class="n">AccessRights</span> <span class="o">=</span> <span class="p">((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">SegmentSelector</span><span class="p">.</span><span class="n">ATTRIBUTES</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">SegmentSelector</span><span class="p">.</span><span class="n">ATTRIBUTES</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Selector</span><span class="p">)</span>
        <span class="n">AccessRights</span> <span class="o">|=</span> <span class="mh">0x10000</span><span class="p">;</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_ES_SELECTOR</span> <span class="o">+</span> <span class="n">Segreg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Selector</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_ES_LIMIT</span> <span class="o">+</span> <span class="n">Segreg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SegmentSelector</span><span class="p">.</span><span class="n">LIMIT</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_ES_AR_BYTES</span> <span class="o">+</span> <span class="n">Segreg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">AccessRights</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_ES_BASE</span> <span class="o">+</span> <span class="n">Segreg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SegmentSelector</span><span class="p">.</span><span class="n">BASE</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The function body for <strong>GetSegmentDescriptor</strong> :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">GetSegmentDescriptor</span><span class="p">(</span><span class="n">PSEGMENT_SELECTOR</span> <span class="n">SegmentSelector</span><span class="p">,</span>
                     <span class="n">USHORT</span>            <span class="n">Selector</span><span class="p">,</span>
                     <span class="n">PUCHAR</span>            <span class="n">GdtBase</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PSEGMENT_DESCRIPTOR</span> <span class="n">SegDesc</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SegmentSelector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Selector</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">SegDesc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSEGMENT_DESCRIPTOR</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">GdtBase</span> <span class="o">+</span> <span class="p">(</span><span class="n">Selector</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7</span><span class="p">));</span>

    <span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">SEL</span>               <span class="o">=</span> <span class="n">Selector</span><span class="p">;</span>
    <span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">BASE</span>              <span class="o">=</span> <span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">BASE0</span> <span class="o">|</span> <span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">BASE1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">BASE2</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
    <span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">LIMIT</span>             <span class="o">=</span> <span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">LIMIT0</span> <span class="o">|</span> <span class="p">(</span><span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">LIMIT1ATTR1</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">ATTRIBUTES</span><span class="p">.</span><span class="n">UCHARs</span> <span class="o">=</span> <span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">ATTR0</span> <span class="o">|</span> <span class="p">(</span><span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">LIMIT1ATTR1</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SegDesc</span><span class="o">-&gt;</span><span class="n">ATTR0</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">))</span>
    <span class="p">{</span> <span class="c1">// LA_ACCESSED</span>
        <span class="n">ULONG64</span> <span class="n">Tmp</span><span class="p">;</span>
        <span class="c1">// this is a TSS or callgate etc, save the base high part</span>
        <span class="n">Tmp</span>                   <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">PULONG64</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">SegDesc</span> <span class="o">+</span> <span class="mi">8</span><span class="p">));</span>
        <span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">BASE</span> <span class="o">=</span> <span class="p">(</span><span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">BASE</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">Tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">ATTRIBUTES</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">G</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 4096-bit granularity is enabled for this segment, scale the limit</span>
        <span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">LIMIT</span> <span class="o">=</span> <span class="p">(</span><span class="n">SegmentSelector</span><span class="o">-&gt;</span><span class="n">LIMIT</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xfff</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Another MSR called <code class="language-c highlighter-rouge"><span class="n">IA32_KERNEL_GS_BASE</span></code> is used to set the kernel GS base. Whenever instructions like <strong>SYSCALL</strong> are executed, and the processor enters ring 0, we need to change the current GS register, which can be done using <a href="https://www.felixcloutier.com/x86/SWAPGS.html"><strong>SWAPGS</strong></a> instruction. This instruction copies the content of <strong>IA32_KERNEL_GS_BASE</strong> into the <strong>IA32_GS_BASE</strong>, and now it’s used in the kernel when it wants to re-enter the user-mode.</p><p><strong>MSR_FS_BASE</strong> on the other hand, doesn’t have a kernel base because it is used in 32-Bit mode while we have a 64-bit (long mode) kernel.</p><p>Like the above MSR, we’ll configure the <strong>IA32_GS_BASE</strong> and <strong>IA32_FS_BASE</strong> MSRs based on the current system’s MSRs.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">));</span>
</pre></table></code></div></div><p>The <strong>GUEST_INTERRUPTIBILITY_INFO</strong> and <strong>GUEST_ACTIVITY_STATE</strong> are set to zero (we’ll describe them in the future parts).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_ACTIVITY_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">//Active state </span>
</pre></table></code></div></div><p>Now we reach an essential part of the VMCS, and it’s the configuration of <strong>CPU_BASED_VM_EXEC_CONTROL</strong> and <strong>SECONDARY_VM_EXEC_CONTROL</strong> controls.</p><p>These fields enable and disable some essential features of the guest, e.g., we can configure VMCS to cause a VM-Exit whenever execution of <strong>HLT</strong> instruction is detected (in guest). You can read the description of each bit in the <strong>VM-Execution Controls</strong> section on this topic.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_HLT_EXITING</span> <span class="o">|</span> <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_CTL2_RDTSCP</span> <span class="cm">/* | CPU_BASED_CTL2_ENABLE_EPT*/</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">));</span>
</pre></table></code></div></div><p>As you can see, we set <code class="language-c highlighter-rouge"><span class="n">CPU_BASED_HLT_EXITING</span></code> that will cause the VM-Exit on <strong>HLT</strong> and activate secondary controls using the <code class="language-c highlighter-rouge"><span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span></code> bit.</p><p>In the secondary controls, we used <code class="language-c highlighter-rouge"><span class="n">CPU_BASED_CTL2_RDTSCP</span></code>, and for now, comment <code class="language-c highlighter-rouge"><span class="n">CPU_BASED_CTL2_ENABLE_EPT</span></code> because we don’t need to deal with EPT in this part. In the 7th part, I thoroughly describe about EPT.</p><p>The description of <code class="language-c highlighter-rouge"><span class="n">PIN_BASED_VM_EXEC_CONTROL</span></code>, <code class="language-c highlighter-rouge"><span class="n">VM_EXIT_CONTROLS</span></code>*, and <code class="language-c highlighter-rouge"><span class="n">VM_ENTRY_CONTROLS</span></code> is available above. We don’t have any special configuration for these controls in this part; hence, let us put zero on them.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">PIN_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PINBASED_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">VM_EXIT_IA32E_MODE</span> <span class="o">|</span> <span class="n">VM_EXIT_ACK_INTR_ON_EXIT</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_EXIT_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">));</span>
</pre></table></code></div></div><p>Also, the <code class="language-c highlighter-rouge"><span class="n">AdjustControls</span></code> is a function for configuring the 0-settings and 1-settings of these fields (we will describe them in the future parts) but for now; it’s defined like this:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">ULONG</span>
<span class="nf">AdjustControls</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">Ctl</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Msr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MSR</span> <span class="n">MsrValue</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">MsrValue</span><span class="p">.</span><span class="n">Content</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">Msr</span><span class="p">);</span>
    <span class="n">Ctl</span> <span class="o">&amp;=</span> <span class="n">MsrValue</span><span class="p">.</span><span class="n">High</span><span class="p">;</span> <span class="cm">/* bit == 0 in high word ==&gt; must be zero */</span>
    <span class="n">Ctl</span> <span class="o">|=</span> <span class="n">MsrValue</span><span class="p">.</span><span class="n">Low</span><span class="p">;</span>  <span class="cm">/* bit == 1 in low word  ==&gt; must be one  */</span>
    <span class="k">return</span> <span class="n">Ctl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The next step is setting Control Registers and Debug Registers (DR7) for the guest and the host. We set them to the same values as the current machine’s state using intrinsic functions.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">__readcr0</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="n">__readcr3</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="n">__readcr4</span><span class="p">());</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_CR0</span><span class="p">,</span> <span class="n">__readcr0</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_CR3</span><span class="p">,</span> <span class="n">__readcr3</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_CR4</span><span class="p">,</span> <span class="n">__readcr4</span><span class="p">());</span>
</pre></table></code></div></div><p>The next part is setting up IDT and GDT’s <strong>Base</strong> and <strong>Limit</strong> for our guest. Generally, it’s <a href="https://github.com/SinaKarvandi/Misc/tree/master/HypervisorBypassWithNMI">not a good idea</a> to use the same IDT (and GDT) for the guest and host, but in order to keep our hypervisor simple, we’ll configure them to the same value.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="n">GetGdtBase</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="n">GetIdtBase</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">,</span> <span class="n">GetGdtLimit</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">,</span> <span class="n">GetIdtLimit</span><span class="p">());</span>
</pre></table></code></div></div><p>Next, set the RFLAGS.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">GetRflags</span><span class="p">());</span>
</pre></table></code></div></div><p>If you want to use SYSENTER in your guest, you should configure the following MSRs. It’s not important to set these values in x64 Windows because Windows doesn’t support SYSENTER in x64 versions of Windows; instead, it uses SYSCALL.</p><p>The same instruction works for 32-bit processes too. In 32-bit processes, Windows first changes the execution mode to long-mode (using <a href="http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/">Heaven’s Gate technique</a>), and then executes the SYSCALL instruction.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_EIP</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_ESP</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_EIP</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_EIP</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_ESP</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_ESP</span><span class="p">));</span>
</pre></table></code></div></div><p>Don’t forget to configure <strong>HOST_FS_BASE</strong>, <strong>HOST_GS_BASE</strong>, <strong>HOST_GDTR_BASE</strong>, <strong>HOST_IDTR_BASE</strong>, <strong>HOST_TR_BASE</strong> for the host in the VMCS.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="n">GetSegmentDescriptor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SegmentSelector</span><span class="p">,</span> <span class="n">GetTr</span><span class="p">(),</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">GetGdtBase</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_TR_BASE</span><span class="p">,</span> <span class="n">SegmentSelector</span><span class="p">.</span><span class="n">BASE</span><span class="p">);</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_FS_BASE</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_GS_BASE</span><span class="p">,</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">));</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_GDTR_BASE</span><span class="p">,</span> <span class="n">GetGdtBase</span><span class="p">());</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_IDTR_BASE</span><span class="p">,</span> <span class="n">GetIdtBase</span><span class="p">());</span>
</pre></table></code></div></div><p>The next important part is to set the <strong>RIP</strong> and <strong>RSP</strong> registers of the guest when a <strong>VMLAUNCH</strong> is executed. It starts with the <strong>RIP</strong> you configured in this part and <strong>RIP</strong> and <strong>RSP</strong> of the host when a VM-exit occurs. It’s pretty clear that host <strong>RIP</strong> should point to a function responsible for managing VMX events based on the VM-exit code and whether decide to execute a <strong>VMRESUME</strong> or turn off the hypervisor using <strong>VMXOFF</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">g_VirtualGuestMemoryAddress</span><span class="p">);</span> <span class="c1">// setup guest sp</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">g_VirtualGuestMemoryAddress</span><span class="p">);</span> <span class="c1">// setup guest ip</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_RSP</span><span class="p">,</span> <span class="p">((</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">GuestState</span><span class="o">-&gt;</span><span class="n">VmmStack</span> <span class="o">+</span> <span class="n">VMM_STACK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">HOST_RIP</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">AsmVmexitHandler</span><span class="p">);</span>
</pre></table></code></div></div><p><strong>HOST_RSP</strong> points to <strong>VmmStack</strong> that we allocated before, and <strong>HOST_RIP</strong> points to <strong>AsmVmexitHandler</strong> (an assembly written function described below). <strong>GUEST_RIP</strong> points to <strong>g_VirtualGuestMemoryAddress</strong> (the global variable we configured during EPT initialization) and <strong>GUEST_RSP</strong> to the same address (<strong>g_VirtualGuestMemoryAddress</strong>) because we don’t put any instruction that uses the stack, so for a real-world example, it should point to a different writeable address.</p><p>Done! Our VMCS is almost ready.</p><h3 id="checking-vmcs-layout"><span class="mr-2"><strong>Checking VMCS Layout</strong></span><a href="#checking-vmcs-layout" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Unfortunately, checking VMCS Layout is not as straight as the other parts. We have to control all the checklists described in <strong>[CHAPTER 26] VM ENTRIES</strong> from <strong>Intel’s 64 and IA-32 Architectures Software Developer’s Manual</strong>, including the following sections:</p><ul><li><strong>26.2 CHECKS ON VMX CONTROLS AND HOST-STATE AREA</strong><li><strong>26.3 CHECKING AND LOADING GUEST STATE</strong><li><strong>26.4 LOADING MSRS</strong><li><strong>26.5 EVENT INJECTION</strong><li><strong>26.6 SPECIAL FEATURES OF VM ENTRY</strong><li><strong>26.7 VM-ENTRY FAILURES DURING OR AFTER LOADING GUEST STATE</strong><li><strong>26.8 MACHINE-CHECK EVENTS DURING VM ENTRY</strong></ul><p>The hardest part of this process is when we have no idea about the incorrect part of your VMCS layout or, on the other hand, when you miss something that eventually causes the failure.</p><p>This is because Intel just gives an error number without any further details about what’s exactly wrong in n our VMCS Layout.</p><p>The errors are shown below.</p><p><img data-src="../../assets/images/vm-error.png" alt="VM Errors" data-proofer-ignore></p><p>To solve this problem, I created a user-mode application called <strong>VmcsAuditor</strong>. As its name describes, it can be a choice if you have any error and don’t have any idea about solving the problem.</p><p>Remember that <a href="https://rayanfam.com/topics/vmcsauditor-a-bochs-based-hypervisor-layout-checker">VmcsAuditor</a> is a tool based on Bochs emulator support for VMX, so all the checks come from Bochs, and it’s not a 100% reliable tool that solves all the problem as we don’t know what exactly happens inside the processor. Still, it can be handy and a time saver.</p><p>The source code and executable files are available on GitHub :</p><p>[<a href="https://github.com/SinaKarvandi/VMCS-Auditor">https://github.com/SinaKarvandi/VMCS-Auditor</a>]</p><p>Further description available <a href="https://rayanfam.com/topics/vmcsauditor-a-bochs-based-hypervisor-layout-checker/">here</a>.</p><p>As a better alternative, you can use <a href="https://github.com/tandasat">Satoshi Tanda</a>’s <strong><a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch/tree/master/Part%205%20-%20Setting%20up%20VMCS%20%26%20Running%20Guest%20Code/VMCS-Checks">code</a></strong> for checking the guest state.</p><h2 id="vm-exit-handler"><span class="mr-2"><strong>VM-Exit Handler</strong></span><a href="#vm-exit-handler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>When our guest software exits and gives the handle back to the host, the following VM-exit reasons might happen.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="cp">#define EXIT_REASON_EXCEPTION_NMI       0
#define EXIT_REASON_EXTERNAL_INTERRUPT  1
#define EXIT_REASON_TRIPLE_FAULT        2
#define EXIT_REASON_INIT                3
#define EXIT_REASON_SIPI                4
#define EXIT_REASON_IO_SMI              5
#define EXIT_REASON_OTHER_SMI           6
#define EXIT_REASON_PENDING_VIRT_INTR   7
#define EXIT_REASON_PENDING_VIRT_NMI    8
#define EXIT_REASON_TASK_SWITCH         9
#define EXIT_REASON_CPUID               10
#define EXIT_REASON_GETSEC              11
#define EXIT_REASON_HLT                 12
#define EXIT_REASON_INVD                13
#define EXIT_REASON_INVLPG              14
#define EXIT_REASON_RDPMC               15
#define EXIT_REASON_RDTSC               16
#define EXIT_REASON_RSM                 17
#define EXIT_REASON_VMCALL              18
#define EXIT_REASON_VMCLEAR             19
#define EXIT_REASON_VMLAUNCH            20
#define EXIT_REASON_VMPTRLD             21
#define EXIT_REASON_VMPTRST             22
#define EXIT_REASON_VMREAD              23
#define EXIT_REASON_VMRESUME            24
#define EXIT_REASON_VMWRITE             25
#define EXIT_REASON_VMXOFF              26
#define EXIT_REASON_VMXON               27
#define EXIT_REASON_CR_ACCESS           28
#define EXIT_REASON_DR_ACCESS           29
#define EXIT_REASON_IO_INSTRUCTION      30
#define EXIT_REASON_MSR_READ            31
#define EXIT_REASON_MSR_WRITE           32
#define EXIT_REASON_INVALID_GUEST_STATE 33
#define EXIT_REASON_MSR_LOADING         34
#define EXIT_REASON_MWAIT_INSTRUCTION   36
#define EXIT_REASON_MONITOR_TRAP_FLAG   37
#define EXIT_REASON_MONITOR_INSTRUCTION 39
#define EXIT_REASON_PAUSE_INSTRUCTION   40
#define EXIT_REASON_MCE_DURING_VMENTRY  41
#define EXIT_REASON_TPR_BELOW_THRESHOLD 43
#define EXIT_REASON_APIC_ACCESS         44
#define EXIT_REASON_ACCESS_GDTR_OR_IDTR 46
#define EXIT_REASON_ACCESS_LDTR_OR_TR   47
#define EXIT_REASON_EPT_VIOLATION       48
#define EXIT_REASON_EPT_MISCONFIG       49
#define EXIT_REASON_INVEPT              50
#define EXIT_REASON_RDTSCP              51
#define EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED     52
#define EXIT_REASON_INVVPID             53
#define EXIT_REASON_WBINVD              54
#define EXIT_REASON_XSETBV              55
#define EXIT_REASON_APIC_WRITE          56
#define EXIT_REASON_RDRAND              57
#define EXIT_REASON_INVPCID             58
#define EXIT_REASON_RDSEED              61
#define EXIT_REASON_PML_FULL            62
#define EXIT_REASON_XSAVES              63
#define EXIT_REASON_XRSTORS             64
#define EXIT_REASON_PCOMMIT             65
</span></pre></table></code></div></div><p>VMX-exit handler should be an assembly function because calling a compiled function needs some preparation and some register modification. The necessary thing in the VM-exit handler is saving the registers’ state so we can continue the guest later.</p><p>I create a sample function for saving and restoring registers. In this function, we call another C function to extend the vm-exit handler.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="n">PUBLIC</span> <span class="n">AsmVmexitHandler</span>

<span class="n">EXTERN</span> <span class="n">MainVmexitHandler</span><span class="o">:</span><span class="n">PROC</span>
<span class="n">EXTERN</span> <span class="n">VmResumeInstruction</span><span class="o">:</span><span class="n">PROC</span>

<span class="p">.</span><span class="n">code</span> <span class="n">_text</span>

<span class="n">AsmVmexitHandler</span> <span class="n">PROC</span>

    <span class="n">PUSH</span> <span class="n">R15</span>
    <span class="n">PUSH</span> <span class="n">R14</span>
    <span class="n">PUSH</span> <span class="n">R13</span>
    <span class="n">PUSH</span> <span class="n">R12</span>
    <span class="n">PUSH</span> <span class="n">R11</span>
    <span class="n">PUSH</span> <span class="n">R10</span>
    <span class="n">PUSH</span> <span class="n">R9</span>
    <span class="n">PUSH</span> <span class="n">R8</span>        
    <span class="n">PUSH</span> <span class="n">RDI</span>
    <span class="n">PUSH</span> <span class="n">RSI</span>
    <span class="n">PUSH</span> <span class="n">RBP</span>
    <span class="n">PUSH</span> <span class="n">RBP</span>	<span class="p">;</span> <span class="n">RSP</span>
    <span class="n">PUSH</span> <span class="n">RBX</span>
    <span class="n">PUSH</span> <span class="n">RDX</span>
    <span class="n">PUSH</span> <span class="n">RCX</span>
    <span class="n">PUSH</span> <span class="n">RAX</span>	

	<span class="n">MOV</span> <span class="n">RCX</span><span class="p">,</span> <span class="n">RSP</span>		<span class="p">;</span> <span class="n">GuestRegs</span>
	<span class="n">SUB</span>	<span class="n">RSP</span><span class="p">,</span> <span class="mi">28</span><span class="n">h</span>

	<span class="n">CALL</span>	<span class="n">MainVmexitHandler</span>
	<span class="n">ADD</span>	<span class="n">RSP</span><span class="p">,</span> <span class="mi">28</span><span class="n">h</span>	

	<span class="n">POP</span> <span class="n">RAX</span>
    <span class="n">POP</span> <span class="n">RCX</span>
    <span class="n">POP</span> <span class="n">RDX</span>
    <span class="n">POP</span> <span class="n">RBX</span>
    <span class="n">POP</span> <span class="n">RBP</span>		<span class="p">;</span> <span class="n">RSP</span>
    <span class="n">POP</span> <span class="n">RBP</span>
    <span class="n">POP</span> <span class="n">RSI</span>
    <span class="n">POP</span> <span class="n">RDI</span> 
    <span class="n">POP</span> <span class="n">R8</span>
    <span class="n">POP</span> <span class="n">R9</span>
    <span class="n">POP</span> <span class="n">R10</span>
    <span class="n">POP</span> <span class="n">R11</span>
    <span class="n">POP</span> <span class="n">R12</span>
    <span class="n">POP</span> <span class="n">R13</span>
    <span class="n">POP</span> <span class="n">R14</span>
    <span class="n">POP</span> <span class="n">R15</span>

	<span class="n">SUB</span> <span class="n">RSP</span><span class="p">,</span> <span class="mo">0100</span><span class="n">h</span> <span class="p">;</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">error</span> <span class="n">in</span> <span class="n">future</span> <span class="n">functions</span>
	
    <span class="n">JMP</span> <span class="n">VmResumeInstruction</span>
	
<span class="n">AsmVmexitHandler</span> <span class="n">ENDP</span>

<span class="n">END</span>
</pre></table></code></div></div><p>The main VM-exit handler is a switch-case function with different decisions over the VMCS <strong>VM_EXIT_REASON</strong> and <strong>EXIT_QUALIFICATION</strong>.</p><p>In this part, we’re just performing an action over <strong>EXIT_REASON_HLT</strong> and just print the result and restore the guest state normally.</p><p>From the following code, you can see what event cause the VM-exit. Just keep in mind that some reasons only lead to Vm-exit if the VMCS’s control execution fields (described above) configure it. For instance, the execution of <strong>HLT</strong> instruction in guest will cause VM-exit if the <strong>7</strong>th bit of the Primary Processor-Based VM-Execution Controls allows it.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">MainVmexitHandler</span><span class="p">(</span><span class="n">PGUEST_REGS</span> <span class="n">GuestRegs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">ExitReason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_REASON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitReason</span><span class="p">);</span>

    <span class="n">ULONG</span> <span class="n">ExitQualification</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitQualification</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">VM_EXIT_REASION 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ExitReason</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"\EXIT_QUALIFICATION 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ExitQualification</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">ExitReason</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// 25.1.2  Instructions That Cause VM Exits Unconditionally</span>
        <span class="c1">// The following instructions cause VM exits when they are executed in VMX non-root operation: CPUID, GETSEC,</span>
        <span class="c1">// INVD, and XSETBV. This is also true of instructions introduced with VMX, which include: INVEPT, INVVPID,</span>
        <span class="c1">// VMCALL, VMCLEAR, VMLAUNCH, VMPTRLD, VMPTRST, VMRESUME, VMXOFF, and VMXON.</span>
        <span class="c1">//</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_VMCLEAR</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMPTRLD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMPTRST</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMREAD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMRESUME</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMWRITE</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMXOFF</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMXON</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMLAUNCH</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_HLT</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Execution of HLT detected... </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c1">//</span>
        <span class="c1">// that's enough for now ;)</span>
        <span class="c1">//</span>
        <span class="n">AsmVmxoffAndRestoreState</span><span class="p">();</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_EXCEPTION_NMI</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_CPUID</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_INVD</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_VMCALL</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_CR_ACCESS</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_MSR_READ</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_MSR_WRITE</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">EXIT_REASON_EPT_VIOLATION</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nl">default:</span>
    <span class="p">{</span>
        <span class="c1">// DbgBreakPoint();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="resume-to-next-instruction"><span class="mr-2"><strong>Resume to next instruction</strong></span><a href="#resume-to-next-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>If a VM-exit occurs (e.g., the guest executed a <strong>CPUID</strong> instruction), the guest <strong>RIP</strong> remains constant, and it’s up to VMM to change the Guest’s <strong>RIP</strong> or not, so if we don’t have a certain function for managing this situation, then the processor executes an infinite loop of <strong>CPUID</strong> instructions because we didn’t increment the <strong>RIP</strong>.</p><p>In order to solve this problem, we have to read a VMCS field called <strong>VM_EXIT_INSTRUCTION_LEN</strong> that stores the length of the instruction that caused the VM-exit.</p><p>First, we have to read the guest’s current <strong>RIP</strong> from the <strong>GUEST_RIP</strong>. Second, read the <strong>VM_EXIT_INSTRUCTION_LEN</strong> using <strong>VMREAD</strong>, and third the length of the instruction to the guest’s <strong>RIP</strong>. Now the guest will continue its execution from the next instruction, and we’re good to go.</p><p>The following function is for this purpose.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">ResumeToNextInstruction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PVOID</span> <span class="n">ResumeRIP</span>             <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PVOID</span> <span class="n">CurrentRIP</span>            <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">ExitInstructionLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CurrentRIP</span><span class="p">);</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitInstructionLength</span><span class="p">);</span>

    <span class="n">ResumeRIP</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">CurrentRIP</span> <span class="o">+</span> <span class="n">ExitInstructionLength</span><span class="p">;</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">ResumeRIP</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="vmresume-instruction"><span class="mr-2"><strong>VMRESUME Instruction</strong></span><a href="#vmresume-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that we handled the VM-exit, it’s time to continue the guest. We could continue the execution by using the <strong>VMRESUME</strong> instruction.</p><p><strong>VMRESUME</strong> is like <strong>VMLAUNCH</strong>, but it’s used in order to resume the guest.</p><p>To compare these instructions,</p><ul><li><p>VMLAUNCH fails if the launch state of the current VMCS is not “clear”. If the instruction is successful, it sets the launch state to “launched.”</p><li><p>VMRESUME fails if the launch state of the current VMCS is not “launched.”</p></ul><p>So it’s clear that if we executed the <strong>VMLAUNCH</strong> instruction before, we can’t use it anymore to resume the guest code, and in this condition, <strong>VMRESUME</strong> is used.</p><p>The following code is the implementation of <strong>VMRESUME</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">VmResumeInstruction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">__vmx_vmresume</span><span class="p">();</span>

    <span class="c1">// if VMRESUME succeeds will never be here !</span>

    <span class="n">ULONG64</span> <span class="n">ErrorCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ErrorCode</span><span class="p">);</span>
    <span class="n">__vmx_off</span><span class="p">();</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMRESUME Error : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// It's such a bad error because we don't where to go!</span>
    <span class="c1">// prefer to break</span>
    <span class="c1">//</span>
    <span class="n">DbgBreakPoint</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="lets-test-it"><span class="mr-2"><strong>Let’s Test it!</strong></span><a href="#lets-test-it" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Well, we have done with the configuration, and now it’s time to run our driver using <strong>OSR Driver Loader</strong>. As always, we should disable the driver signature enforcement and run our driver.</p><p><img data-src="../../assets/images/hlt-execution.png" alt="" data-proofer-ignore></p><p>As you can see from the above picture (in the launching VM area), first, we set the current logical processor to 0. Next, we clear our VMCS status using the <strong>VMCLEAR</strong> instruction, set up our VMCS layout and execute the <strong>VMLAUNCH</strong> instruction.</p><p>Now, our guest code is executed, and as we configured our VMCS to cause a VM-exit in the case of the execution of the <strong>HLT</strong> <strong>(CPU_BASED_HLT_EXITING)</strong> instruction.</p><p>After running the guest, the VM-exit handler is called, then it calls the main VM-exit handler, and as the VMCS exit reason is <strong>0xc (EXIT_REASON_HLT)</strong>, we successfully detected the execution of <strong>HLT</strong> in the guest.</p><p>After that, our machine state saving mechanism is executed, and we successfully turn off the hypervisor using the <strong>VMXOFF</strong> instruction and return to the first caller with a successful **(RAX = 1) status.</p><p>That’s it! Wasn’t it easy?</p><p><img data-src="../../assets/images/anime-girls-drinking-tea.jpg" alt=":)" data-proofer-ignore></p><h2 id="conclusion"><span class="mr-2"><strong>Conclusion</strong></span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In this part, we got familiar with configuring the Virtual Machine Control Structure and finally ran our guest code. The future parts would be an enhancement to this configuration like entering <strong>protected-mode,</strong> <strong>interrupt injection</strong>, <strong>page modification logging,</strong> <strong>virtualizing the current machine</strong>, and so on. You can use the comments section below if you have any questions or problems.</p><p>See you in the next part.</p><p>The sixth part is also available <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-6">here</a>.</p><h2 id="references"><span class="mr-2"><strong>References</strong></span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>[1] Vol 3C - Chapter 24 – (VIRTUAL MACHINE CONTROL STRUCTURES (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)</p><p>[2] Vol 3C - Chapter 26 – (VM ENTRIES) (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)</p><p>[3] Segmentation (<a href="https://wiki.osdev.org/Segmentation">https://wiki.osdev.org/Segmentation</a>)</p><p>[4] x86 memory segmentation (<a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">https://en.wikipedia.org/wiki/X86_memory_segmentation</a>)</p><p>[5] VmcsAuditor – A Bochs-Based Hypervisor Layout Checker (<a href="https://rayanfam.com/topics/vmcsauditor-a-bochs-based-hypervisor-layout-checker/">https://rayanfam.com/topics/vmcsauditor-a-bochs-based-hypervisor-layout-checker/</a>)</p><p>[6] Rohaaan/Hypervisor For Beginners (<a href="https://github.com/rohaaan/hypervisor-for-beginners">https://github.com/rohaaan/hypervisor-for-beginners</a>)</p><p>[7] SWAPGS — Swap GS Base Register (<a href="https://www.felixcloutier.com/x86/SWAPGS.html">https://www.felixcloutier.com/x86/SWAPGS.html</a>)</p><p>[8] Knockin’ on Heaven’s Gate - Dynamic Processor Mode Switching (<a href="http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/"></a><a href="http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/">http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/</a>)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cpu/'>cpu</a>, <a href='/categories/hypervisor/'>hypervisor</a>, <a href='/categories/tutorials/'>tutorials</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hypervisor/" class="post-tag no-text-decoration" >hypervisor</a> <a href="/tags/building-vmcs/" class="post-tag no-text-decoration" >building-vmcs</a> <a href="/tags/configuring-vmcs/" class="post-tag no-text-decoration" >configuring-vmcs</a> <a href="/tags/start-virtual-machine/" class="post-tag no-text-decoration" >start-virtual-machine</a> <a href="/tags/virtual-machine-control-structure/" class="post-tag no-text-decoration" >virtual-machine-control-structure</a> <a href="/tags/vmcs/" class="post-tag no-text-decoration" >vmcs</a> <a href="/tags/vmcs-configuration/" class="post-tag no-text-decoration" >vmcs-configuration</a> <a href="/tags/vmlaunch/" class="post-tag no-text-decoration" >vmlaunch</a> <a href="/tags/vmlaunch-0x7/" class="post-tag no-text-decoration" >vmlaunch-0x7</a> <a href="/tags/vmlaunch-0x8/" class="post-tag no-text-decoration" >vmlaunch-0x8</a> <a href="/tags/vmlaunch-error/" class="post-tag no-text-decoration" >vmlaunch-error</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Hypervisor From Scratch – Part 5: Setting up VMCS &amp; Running Guest Code - Rayanfam Blog&amp;url=https://rayanfam.com/topics/hypervisor-from-scratch-part-5/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Hypervisor From Scratch – Part 5: Setting up VMCS &amp; Running Guest Code - Rayanfam Blog&amp;u=https://rayanfam.com/topics/hypervisor-from-scratch-part-5/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://rayanfam.com/topics/hypervisor-from-scratch-part-5/&amp;text=Hypervisor From Scratch – Part 5: Setting up VMCS &amp; Running Guest Code - Rayanfam Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/topics/hypervisor-from-scratch-part-1/">Hypervisor From Scratch - Part 1: Basic Concepts & Configure Testing Environment</a><li><a href="/topics/hypervisor-from-scratch-part-2/">Hypervisor From Scratch – Part 2: Entering VMX Operation</a><li><a href="/topics/hypervisor-from-scratch-part-5/">Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</a><li><a href="/topics/hypervisor-from-scratch-part-6/">Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</a><li><a href="/topics/hypervisor-from-scratch-part-7/">Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/topics/hypervisor-from-scratch-part-3/"><div class="card-body"> <em class="timeago small" data-ts="1536969600" > 2018-09-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 3: Setting up Our First Virtual Machine</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/vmcsauditor-a-bochs-based-hypervisor-layout-checker/"><div class="card-body"> <em class="timeago small" data-ts="1544140800" > 2018-12-07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>VmcsAuditor - A Bochs-Based Hypervisor Layout Checker</h3><div class="text-muted small"><p> Introduction If you’ve ever had experience with developing your own hypervisor from scratch then you definitely faced with the problems of layout checking. What makes it hard to develop a hyperv...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-6/"><div class="card-body"> <em class="timeago small" data-ts="1551052800" > 2019-02-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/topics/vmcsauditor-a-bochs-based-hypervisor-layout-checker/" class="btn btn-outline-primary" prompt="Older"><p>VmcsAuditor - A Bochs-Based Hypervisor Layout Checker</p></a> <a href="/topics/call-gates-ring-transitioning-in-ia-32-mode/" class="btn btn-outline-primary" prompt="Newer"><p>Call Gates' Ring Transitioning in IA-32 Mode</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://rayanfam.com/topics/hypervisor-from-scratch-part-5/'; this.page.identifier = '/topics/hypervisor-from-scratch-part-5/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://rayanfam.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/rayanfam">Rayanfam Blog</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-P6M1BDG57Z"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-P6M1BDG57Z'); }); </script>
