<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!" /><meta name="author" content="Sina Karvandi" /><meta property="og:locale" content="en" /><meta name="description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><meta property="og:description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><link rel="canonical" href="https://rayanfam.com/topics/hypervisor-from-scratch-part-8/" /><meta property="og:url" content="https://rayanfam.com/topics/hypervisor-from-scratch-part-8/" /><meta property="og:site_name" content="Rayanfam Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-03-24T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!" /><meta name="twitter:site" content="@Intel80x86" /><meta name="twitter:creator" content="@Sina Karvandi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sina Karvandi"},"dateModified":"2024-07-13T13:14:26+00:00","datePublished":"2020-03-24T00:00:00+00:00","description":"We write about Windows Internals, Hypervisors, Linux, and Networks.","headline":"Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!","mainEntityOfPage":{"@type":"WebPage","@id":"https://rayanfam.com/topics/hypervisor-from-scratch-part-8/"},"url":"https://rayanfam.com/topics/hypervisor-from-scratch-part-8/"}</script><title>Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor! | Rayanfam Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Rayanfam Blog"><meta name="application-name" content="Rayanfam Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/images/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Rayanfam Blog</a></div><div class="site-subtitle font-italic">An aggressive out-of-order, superscalar blog...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tutorials/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TUTORIALS</span> </a><li class="nav-item"> <a href="/tools/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TOOLS & SCRIPTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/rayanfam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Intel80x86" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sina','rayanfam.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Intel80x86">Sina Karvandi</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1585008000" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-03-24 </em> </span> <span> Updated <em class="timeago" data-ts="1720876466" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-07-13 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="24912 words"> <em>138 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="../../assets/images/hypervisor-from-scratch-8-cover.png" alt="" data-proofer-ignore></p><p><strong>If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out <a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and reversing applications. A free and comprehensive tutorial on hypervisor-based reverse engineering is available at <a href="https://ost2.fyi/dbg3301">OpenSecurityTraining2’s website</a> (<em>preferred</em>) and <a href="https://www.youtube.com/playlist?list=PLUFkSN0XLZ-kF1f143wlw8ujlH2A45nZY">YouTube</a>, which demonstrates numerous practical examples on how to utilize hypervisors for reverse engineering.</strong></p><h2 id="introduction"><span class="mr-2"><strong>Introduction</strong></span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hi guys,</p><p>Welcome to the 8th part of the Hypervisor From Scratch. If you reach here, then you probably finished reading the 7th part, and personally, I believe the 7th part was the most challenging part to understand so hats off, you did a great job.</p><p>The 8th part would be an exciting part as we’ll see lots of real-world and practical examples of solving reverse-engineering related problems with hypervisors. For example, we’ll see how hidden hooks work in the presence of hypervisor or how to create a syscall hook, and we’re eventually able to transfer messages from vmx root to OS (vmx non-root) and then into user-mode thus it gives us a valuable bunch of information about how the system works.</p><p>Besides some OS-related concepts, we’ll also see some CPU related topics like VPIDs and some general information about how patches for Meltdown and Spectre works.</p><p>Event injection, Exception Bitmap, and also adding support to virtualize a hyper-v machine are other titles that will be discussed.</p><p>Before starting, I should give special thanks to my friend <a href="https://twitter.com/PetrBenes"><strong>Petr Benes</strong></a> for his contributions to Hypervisor From Scratch, of course, Hypervisor From Scratch could never have existed without his help and to <a href="https://twitter.com/Liran_Alon"><strong>Liran Alon</strong></a> for great helps on fixing VPID problem, and to <a href="https://twitter.com/gerhart_x"><strong>Gerhart</strong></a> for his in-depth knowledge about Hyper-V internals that makes Hypervisor From Scratch available for Hyper-V.</p><h2 id="overview"><span class="mr-2"><strong>Overview</strong></span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>This part is divided into <strong>eight</strong> main sections :</p><ol><li>How to inject interrupts (Event) into the guest and Exception Bitmap<li>Implementing hidden hooks using EPT<li>Syscall hook<li>Invalidating EPT caches using VPID<li>Demonstrating a custom VMX Root-mode compatible message tracing mechanism and adding WPP Tracing to our Hypervisor<li>We’ll add support to Hyper-V<li>Fixing some previous design caveats<li>Discussion (In this section we discuss the different question and approaches about various topics in this part)</ol><p>The full source code of this tutorial is available on GitHub :</p><p>[<a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch">https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a>]</p><h1 id="table-of-contents"><strong>Table of Contents</strong></h1><ul><li><strong>Introduction</strong><li><strong>Overview</strong><li><strong>Table of Contents</strong><li><p><strong>Event Injection</strong></p><ul><li>Vectored Events<ol><li>Interrupts<li>Exceptions</ol><li>Exception Classifications<li>Event Injection Fields<li>Vectored Event Injection<li>Exception Error Codes</ul><li><strong>Exception Bitmap</strong><li><strong>Monitor Trap Flag (MTF)</strong><li><p><strong>Hidden Hooks</strong> <strong>(Simulating Hardware Debug Registers Without Any Limitation)</strong></p><ul><li>Hidden Hooks Scenarios for Read/Write and Execute<li><p>Implementing Hidden Hooks</p><li><p>Removing Hooks From Pages</p><li>An Important Note When Modifying EPT Entries</ul><li><strong>System-Call Hook</strong><ul><li>Finding Kernel Base<li>Finding SSDT and Shadow SSDT Tables<li>Get Routine Address by Syscall Number</ul><li><strong>Virtual Processor ID (VPID) &amp; TLB</strong><ul><li>INVVPID - Invalidate Translations Based on VPID<ol><li>Individual-address invalidation<li>Single-context invalidation<li>All-contexts invalidation<li>Single-context invalidation, retaining global translations</ol><li>Important Notes For Using VPIDs<li>INVVPID vs. INVPCID</ul><li><strong>Designing A VMX Root-mode Compatible Message Tracing</strong><ul><li>Concepts<ol><li>What’s a spinlock?<li>Test-and-Set<li>What do we mean by “Safe”?<li>What is DPC?</ol><li>Challenges<li>Designing A Spinlock<li>Message Tracer Design<ol><li>Initialization Phase<li>Sending Phase (Saving Buffer and adding them to pools)<li>Reading Phase (Read buffers and send them to user-mode)<li>Checking for new messages<li>Sending messages to pools<li>Receiving buffers and messages in user-mode<li>IOCTL and managing user-mode requests<li>User-mode notify callback<li>Uninitialization Phase</ol></ul><li><strong>WPP Tracing</strong><li><p><strong>Supporting to Hyper-V</strong></p><ul><li><p>Enable Nested Virtualization</p><li><p>Hyper-V’s visible behavior in nested virtualization</p><li><p>Hyper-V Hypervisor Top-Level Functional Specification (TLFS)</p><li><p>Out of Range MSRs</p><li><p>Hyper-V Hypercalls (VMCALLs)</p><li><p>Hyper-V Interface CPUID Leaves</p></ul><li><strong>Fixing Previous Design Issues</strong><ul><li>Fixing the problem with pre-allocated buffers<li>Avoid Intercepting Accesses to CR3<li>Restoring IDTR, GDTR, GS Base and FS Base</ul><li><strong>Let’s Test it!</strong><ul><li>View WPP Tracing Messages<li>How to test?<ol><li>Event Injection &amp; Exception Bitmap Demo<li>Hidden Hooks Demo<ul><li>Read/Write Hooks or Hardware Debug Registers Simulation<li>Hidden Execution Hook</ul><li>Syscall Hook Demo</ol></ul><li><strong>Discussion</strong><li><strong>Conclusion</strong><li><strong>References</strong></ul><p><img data-src="../../assets/images/anime-girl-wind-scarf.jpg" alt="Animmmmeee :0" data-proofer-ignore></p><h1 id="event-injection"><strong>Event Injection</strong></h1><p>One of the essential parts of the hypervisors is the ability to inject events (events are Interrupts, Exceptions, NMIs, and SMIs) as if they’ve arrived normally, and the capability to monitor received interrupts and exceptions.</p><p>This gives us a great ability to manage the guest operating system and unique ability to build applications, For example, if you are developing anti-cheat application, you can easily disable <strong>breakpoint</strong> and <strong>trap</strong> interrupts, and it completely disables all the features of Windbg or any other debugger as you’re the first one that is being notified about the breakpoint thus you can decide to abort the breakpoint or give it to the debugger.</p><p>This is just a simple example that the attacker needs to find a way around it. You can also use event injections for reverse-engineering purposes, e.g., directly inject a breakpoint into an application that uses different anti-debugging techniques to make its code hidden.</p><p>We can also implement some important features of our hypervisor like hidden hooks based on relying on event injection.</p><p>Before going deep into the Event Injection, we need to know some basic processor concepts and terms used by Intel. Most of them derived from <a href="https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/">this post</a> and <a href="https://stackoverflow.com/a/37558741">this answer</a>.</p><p>Intel x86 defines two overlapping categories, <strong>vectored events</strong> (<strong>interrupts</strong> vs <strong>exceptions</strong>), and <strong>exception classes</strong> (<strong>faults</strong> vs <strong>traps</strong> vs <strong>aborts</strong>).</p><h1 id="vectored-events"><strong>Vectored Events</strong></h1><p>Vectored Events (<strong>interrupts</strong> and <strong>exceptions</strong>) cause the processor to jump into an interrupt handler after saving much of the processor’s state (enough such that execution can continue from that point later).</p><p>Exceptions and interrupts have an ID, called a vector, that determines which interrupt handler the processor jumps to. Interrupt handlers are described within the <strong>I</strong>nterrupt <strong>D</strong>escriptor <strong>T</strong>able (IDT).</p><h2 id="interrupts"><span class="mr-2"><strong>Interrupts</strong></span><a href="#interrupts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>Interrupts</strong> occur at random times during the execution of a program, in response to signals from the hardware. System hardware uses interrupts to handle events external to the processor, such as requests to service peripheral devices. The software can also generate interrupts by executing the INT n instruction.</p><h2 id="exceptions"><span class="mr-2"><strong>Exceptions</strong></span><a href="#exceptions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>Exceptions</strong> occur when the processor detects an error condition while executing an instruction, such as division by zero. The processor identifies a variety of error conditions, including protection violations, page faults, and internal machine faults.</p><h1 id="exception-classifications"><strong>Exception Classifications</strong></h1><p><strong>Exceptions</strong> classified as <strong>faults</strong>, <strong>traps</strong>, or <strong>aborts</strong> depending on the way they reported and whether the instruction that caused the exception could be restarted without loss of program or task continuity.</p><p>In summary: <strong>traps</strong> increment the instruction pointer (RIP), <strong>faults</strong> do not, and <strong>aborts</strong> ’explode’.</p><p>We’ll start with the fault classification. You’ve probably heard of things called <strong>page faults</strong> (or <strong>segmentation faults</strong> if you’re from the past).</p><p>A fault is just an exception type that can be corrected and allows the processor the ability to execute some fault handler to rectify an offending operation without terminating the entire operation. When a fault occurs, the system state is reverted to an earlier state before the faulting operation occurred, and the fault handler is called. After executing the fault handler, the processor returns to the faulting instruction to execute it again. That last sentence is important because that means it redoes an instruction execution to make sure the proper results are used in the following operations. This is different from how a trap is handled.</p><p>A trap is an exception that is delivered immediately following the execution of a trapping instruction. In our hypervisor, we trap on various instructions, meaning that after the execution of an instruction – say <strong>rdtsc</strong> or <strong>rdtscp</strong> – a trap exception is reported to the processor. Once a trap exception is reported, control is passed to a trap handler, which will perform some operation(s). Following the execution of the trap handler, the processor returns to the instruction following the trapping instruction.</p><p>An abort, however, is an exception that occurs and doesn’t always yield the location of the error. Aborts are commonly used for reporting hardware errors, or otherwise. You won’t see these very often, and if you do… Well, you’re doing something wrong. It’s important to know that all exceptions are reported on an instruction boundary – excluding aborts. An instruction boundary is quite simple: if you have the bytes <strong>0F 31 48 C1 E2 20</strong> which translates to the instructions,</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">rdtsc</span>
<span class="n">shl</span> <span class="n">rdx</span><span class="p">,</span> <span class="mi">20</span><span class="n">h</span>
</pre></table></code></div></div><p>Then the instruction boundary would be between the bytes <strong>31</strong> and <strong>48.</strong> That’s because <strong>0F 31</strong> is the instruction opcodes for <strong>rdtsc</strong>. This way, two instructions separated by a boundary.</p><h2 id="event-injection-fields"><span class="mr-2"><strong>Event Injection Fields</strong></span><a href="#event-injection-fields" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Event injection is done with using interruption-information field of VMCS.</p><p>The interruption-information is written into the VM-entry fields of the VMCS during VM-entry; after all the guest context has been loaded, including MSRs and Registers, it delivers the exception through the Interrupt Descriptor Table (IDT) using the vector specified in this field. </p><p>The first field to configure event injection is <strong>VM-entry interruption-information field</strong> (32 bits) or <strong>VM_ENTRY_INTR_INFO</strong> in the VMCS, this field provides details about the event to be injected.</p><p>The following picture shows the detail of each bit.</p><p><img data-src="../../assets/images/vm-entry-interruption-information-fields.png" alt="VM-Entry Interruption-Information" data-proofer-ignore></p><ul><li>The <strong>vector</strong> (bits 7:0) determines which entry in the IDT is used or which other event is injected or, in other words, it defines the index of Interrupt to be injected in IDT, for example, the following command (!idt) in windbg shows the IDT indexes. (note that the index is the numbers at the left).</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="n">lkd</span><span class="o">&gt;</span> <span class="o">!</span><span class="n">idt</span>

<span class="n">Dumping</span> <span class="n">IDT</span><span class="o">:</span> <span class="n">fffff8012c05b000</span>

<span class="mo">00</span><span class="o">:</span>	<span class="n">fffff80126551100</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiDivideErrorFaultShadow</span>
<span class="mo">01</span><span class="o">:</span>	<span class="n">fffff80126551180</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiDebugTrapOrFaultShadow</span>	<span class="n">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8012C05F9D0</span>
<span class="mo">02</span><span class="o">:</span>	<span class="n">fffff80126551200</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiNmiInterruptShadow</span>	<span class="n">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8012C05F7D0</span>
<span class="mo">03</span><span class="o">:</span>	<span class="n">fffff80126551280</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiBreakpointTrapShadow</span>
<span class="mo">04</span><span class="o">:</span>	<span class="n">fffff80126551300</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiOverflowTrapShadow</span>
<span class="mo">05</span><span class="o">:</span>	<span class="n">fffff80126551380</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiBoundFaultShadow</span>
<span class="mo">06</span><span class="o">:</span>	<span class="n">fffff80126551400</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiInvalidOpcodeFaultShadow</span>
<span class="mo">07</span><span class="o">:</span>	<span class="n">fffff80126551480</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiNpxNotAvailableFaultShadow</span>
<span class="mi">08</span><span class="o">:</span>	<span class="n">fffff80126551500</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiDoubleFaultAbortShadow</span>	<span class="n">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8012C05F3D0</span>
<span class="mi">09</span><span class="o">:</span>	<span class="n">fffff80126551580</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiNpxSegmentOverrunAbortShadow</span>
<span class="mi">0</span><span class="n">a</span><span class="o">:</span>	<span class="n">fffff80126551600</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiInvalidTssFaultShadow</span>
<span class="mi">0</span><span class="n">b</span><span class="o">:</span>	<span class="n">fffff80126551680</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiSegmentNotPresentFaultShadow</span>
<span class="mi">0</span><span class="n">c</span><span class="o">:</span>	<span class="n">fffff80126551700</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiStackFaultShadow</span>
<span class="mi">0</span><span class="n">d</span><span class="o">:</span>	<span class="n">fffff80126551780</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiGeneralProtectionFaultShadow</span>
<span class="mi">0</span><span class="n">e</span><span class="o">:</span>	<span class="n">fffff80126551800</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiPageFaultShadow</span>
<span class="mi">10</span><span class="o">:</span>	<span class="n">fffff80126551880</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiFloatingErrorFaultShadow</span>
<span class="mi">11</span><span class="o">:</span>	<span class="n">fffff80126551900</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiAlignmentFaultShadow</span>
<span class="mi">12</span><span class="o">:</span>	<span class="n">fffff80126551980</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiMcheckAbortShadow</span>	<span class="n">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8012C05F5D0</span>
<span class="mi">13</span><span class="o">:</span>	<span class="n">fffff80126551a80</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiXmmExceptionShadow</span>
<span class="mi">14</span><span class="o">:</span>	<span class="n">fffff80126551b00</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiVirtualizationExceptionShadow</span>
<span class="mi">15</span><span class="o">:</span>	<span class="n">fffff80126551b80</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiControlProtectionFaultShadow</span>
<span class="mi">1</span><span class="n">f</span><span class="o">:</span>	<span class="n">fffff80126551c00</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiApcInterruptShadow</span>
<span class="mi">20</span><span class="o">:</span>	<span class="n">fffff80126551c80</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiSwInterruptShadow</span>
<span class="mi">29</span><span class="o">:</span>	<span class="n">fffff80126551d00</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiRaiseSecurityCheckFailureShadow</span>
<span class="mi">2</span><span class="n">c</span><span class="o">:</span>	<span class="n">fffff80126551d80</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiRaiseAssertionShadow</span>
<span class="mi">2</span><span class="n">d</span><span class="o">:</span>	<span class="n">fffff80126551e00</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiDebugServiceTrapShadow</span>
<span class="mi">2</span><span class="n">f</span><span class="o">:</span>	<span class="n">fffff80126551f00</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiDpcInterruptShadow</span>
<span class="mi">30</span><span class="o">:</span>	<span class="n">fffff80126551f80</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiHvInterruptShadow</span>
<span class="mi">31</span><span class="o">:</span>	<span class="n">fffff80126552000</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiVmbusInterrupt0Shadow</span>
<span class="mi">32</span><span class="o">:</span>	<span class="n">fffff80126552080</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiVmbusInterrupt1Shadow</span>
<span class="mi">33</span><span class="o">:</span>	<span class="n">fffff80126552100</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiVmbusInterrupt2Shadow</span>
<span class="mi">34</span><span class="o">:</span>	<span class="n">fffff80126552180</span> <span class="n">nt</span><span class="o">!</span><span class="n">KiVmbusInterrupt3Shadow</span>
<span class="p">...</span>
</pre></table></code></div></div><p>The <strong>interruption type</strong> (bits 10:8) determines details of how the injection is performed.</p><p>In general, a VMM should use the type hardware exception for all exceptions other than the following:</p><ul><li>Breakpoint exceptions (#BP): a VMM should use the type software exception.<li>Overflow exceptions (#OF): a VMM should use the use type software exception.<li>Those debug exceptions (#DB) that are generated by INT1 (a VMM should use the use type privileged software exception).</ul><p>For exceptions, the <strong>deliver-error-code bit</strong> (bit 11) determines whether delivery pushes an error code on<br /> the guest stack. (we’ll talk about error-code later)</p><p>The last bit is that VM entry injects an event if and only if the valid bit (bit 31) is 1. The valid bit in this field is cleared on every VM exit means that when you want to inject an event, you set this bit to inject your interrupt and the processor will automatically clear it at the next VM-Exit.</p><p>The second field that controls the event injection is <strong>VM-entry exception error code</strong>.</p><p><strong>VM-entry exception error code (32 bits)</strong> or <strong>VM_ENTRY_EXCEPTION_ERROR_CODE</strong> in the VMCS: This field is used if and only if the valid bit (bit 31) and the deliver error-code bit (bit 11) are both set in the VM-entry interruption-information field.</p><p>The third field that controls the event injection is <strong>VM-entry instruction length</strong>.</p><p><strong>VM-entry instruction length (32 bits)</strong> or <strong>VM_ENTRY_INSTRUCTION_LEN</strong> in the VMCS: For injection of events whose type is a software interrupt, software exception, or privileged software exception, this field is used to determine the value of RIP that is pushed on the stack.</p><p>All in all, these things in VMCS control the Event Injection process: <strong>VM_ENTRY_INTR_INFO</strong>, <strong>VM_ENTRY_EXCEPTION_ERROR_CODE</strong>, <strong>VM_ENTRY_INSTRUCTION_LEN</strong>.</p><h2 id="vectored-event-injection"><span class="mr-2"><strong>Vectored Event Injection</strong></span><a href="#vectored-event-injection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>If the valid bit in the VM-entry interruption-information field is 1, VM entry causes an event to be delivered (or made pending) after all components of the guest state have been loaded (including MSRs) and after the VM-execution control fields have been established.</p><p>The <strong>interruption type</strong> (which is described above) can be one of the following values.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">_INTERRUPT_TYPE</span>
<span class="p">{</span>
	<span class="n">INTERRUPT_TYPE_EXTERNAL_INTERRUPT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_RESERVED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_NMI</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_HARDWARE_EXCEPTION</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_SOFTWARE_INTERRUPT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_PRIVILEGED_SOFTWARE_INTERRUPT</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_SOFTWARE_EXCEPTION</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">INTERRUPT_TYPE_OTHER_EVENT</span> <span class="o">=</span> <span class="mi">7</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Now it’s time to set the <strong>vector</strong> bit. The following enum is the representation of the indexes in IDT. (Look at the indexes of <strong>!idt</strong> command above).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_EXCEPTION_VECTORS</span>
<span class="p">{</span>
	<span class="n">EXCEPTION_VECTOR_DIVIDE_ERROR</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_DEBUG_BREAKPOINT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_NMI</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_BREAKPOINT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_OVERFLOW</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_BOUND_RANGE_EXCEEDED</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_UNDEFINED_OPCODE</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_NO_MATH_COPROCESSOR</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_DOUBLE_FAULT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED0</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_INVALID_TASK_SEGMENT_SELECTOR</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_SEGMENT_NOT_PRESENT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_STACK_SEGMENT_FAULT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_PAGE_FAULT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED1</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_MATH_FAULT</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_ALIGNMENT_CHECK</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_MACHINE_CHECK</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_SIMD_FLOATING_POINT_NUMERIC_ERROR</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_VIRTUAL_EXCEPTION</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED2</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED3</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED4</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED5</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED6</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED7</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED8</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED9</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED10</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED11</span><span class="p">,</span>
	<span class="n">EXCEPTION_VECTOR_RESERVED12</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In general, the event is delivered as if it had been generated normally, and the event is delivered using the vector in that field to select a descriptor in the IDT. Since event injection occurs after loading <strong>IDTR</strong> (IDT Register) from the guest-state area, this is the guest IDT, or in other words, the event is delivered to <strong>GUEST_IDTR_BASE</strong> and <strong>GUEST_IDTR_LIMIT</strong>.</p><p>Putting the above descriptions into the implementation, we have the following function :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// Injects interruption to a guest</span>
<span class="n">VOID</span> <span class="nf">EventInjectInterruption</span><span class="p">(</span><span class="n">INTERRUPT_TYPE</span> <span class="n">InterruptionType</span><span class="p">,</span> <span class="n">EXCEPTION_VECTORS</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">DeliverErrorCode</span><span class="p">,</span> <span class="n">ULONG32</span> <span class="n">ErrorCode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INTERRUPT_INFO</span> <span class="n">Inject</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">Inject</span><span class="p">.</span><span class="n">Valid</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="n">Inject</span><span class="p">.</span><span class="n">InterruptType</span> <span class="o">=</span> <span class="n">InterruptionType</span><span class="p">;</span>
	<span class="n">Inject</span><span class="p">.</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">;</span>
	<span class="n">Inject</span><span class="p">.</span><span class="n">DeliverCode</span> <span class="o">=</span> <span class="n">DeliverErrorCode</span><span class="p">;</span>
	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO</span><span class="p">,</span> <span class="n">Inject</span><span class="p">.</span><span class="n">Flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DeliverErrorCode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As an example we want to inject a <strong>#BP</strong> (breakpoint) into the guest, we can use the following code :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cm">/* Inject #BP to the guest (Event Injection) */</span>
<span class="n">VOID</span> <span class="nf">EventInjectBreakpoint</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">EventInjectInterruption</span><span class="p">(</span><span class="n">INTERRUPT_TYPE_SOFTWARE_EXCEPTION</span><span class="p">,</span> <span class="n">EXCEPTION_VECTOR_BREAKPOINT</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">UINT32</span> <span class="n">ExitInstrLength</span><span class="p">;</span>
<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitInstrLength</span><span class="p">);</span>
<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span> <span class="n">ExitInstrLength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Or if we want to inject a <strong>#GP(0)</strong> or general protection fault with error code 0 then we use the following code:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cm">/* Inject #GP to the guest (Event Injection) */</span>
<span class="n">VOID</span> <span class="nf">EventInjectGeneralProtection</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">EventInjectInterruption</span><span class="p">(</span><span class="n">INTERRUPT_TYPE_HARDWARE_EXCEPTION</span><span class="p">,</span> <span class="n">EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">UINT32</span> <span class="n">ExitInstrLength</span><span class="p">;</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitInstrLength</span><span class="p">);</span>
	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span> <span class="n">ExitInstrLength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You can write functions for other types of interrupts and exceptions. The only thing that you should consider is the <strong>InterruptionType,</strong> which is always hardware exception except for <strong>#DP</strong>, <strong>#BP</strong>, <strong>#OF</strong>, which is discussed above.</p><h2 id="exception-error-codes"><span class="mr-2"><strong>Exception Error Codes</strong></span><a href="#exception-error-codes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>You might notice that we used <strong>VM_ENTRY_EXCEPTION_ERROR_CODE</strong> in the VMCS and 11th bit of the <strong>interruption-information field,</strong> and for some exceptions, we disabled them while for some others we set them to a specific value, so what’s that error codes?</p><p>Some exceptions will push a 32-bit “error code” on to the top of the stack, which provides additional information about the error. This value must be pulled from the stack before returning control back to the currently running program. (i.e., before calling IRET for returning from interrupt).</p><p>The fact that the error code must be pulled from the stack makes event injection more complicated as we have to make sure whether the Windows tries to pull error code from the stack or not, as it turns to error if we put something onto the stack that Windows doesn’t expect to pull it later or we didn’t push anything but Windows thoughts there is something in the stack that needs to be pulled.</p><p>The following table shows some of these exceptions with the presence or absence of <strong>Error code</strong>, this table is derived from <strong>Intel SDM, Volume 1, CHAPTER 6</strong> (<strong>Table 6-1. Exceptions and Interrupts</strong>).</p><div class="table-wrapper"><table><thead><tr><th>Name<th>Vector nr.<th>Type<th>Mnemonic<th>Error code?<tbody><tr><td>Divide-by-zero Error<td>0 (0x0)<td>Fault<td>#DE<td>No<tr><td>Debug<td>1 (0x1)<td>Fault/Trap<td>#DB<td>No<tr><td>Non-maskable Interrupt<td>2 (0x2)<td>Interrupt<td>-<td>No<tr><td>Breakpoint<td>3 (0x3)<td>Trap<td>#BP<td>No<tr><td>Overflow<td>4 (0x4)<td>Trap<td>#OF<td>No<tr><td>Bound Range Exceeded<td>5 (0x5)<td>Fault<td>#BR<td>No<tr><td>Invalid Opcode<td>6 (0x6)<td>Fault<td>#UD<td>No<tr><td>Device Not Available<td>7 (0x7)<td>Fault<td>#NM<td>No<tr><td>Double Fault<td>8 (0x8)<td>Abort<td>#DF<td>Yes (Zero)<tr><td>Coprocessor Segment Overrun<td>9 (0x9)<td>Fault<td>-<td>No<tr><td>Invalid TSS<td>10 (0xA)<td>Fault<td>#TS<td>Yes<tr><td>Segment Not Present<td>11 (0xB)<td>Fault<td>#NP<td>Yes<tr><td>Stack-Segment Fault<td>12 (0xC)<td>Fault<td>#SS<td>Yes<tr><td>General Protection Fault<td>13 (0xD)<td>Fault<td>#GP<td>Yes<tr><td>Page Fault<td>14 (0xE)<td>Fault<td>#PF<td>Yes<tr><td>Reserved<td>15 (0xF)<td>-<td>-<td>No<tr><td>x87 Floating-Point Exception<td>16 (0x10)<td>Fault<td>#MF<td>No<tr><td>Alignment Check<td>17 (0x11)<td>Fault<td>#AC<td>Yes<tr><td>Machine Check<td>18 (0x12)<td>Abort<td>#MC<td>No<tr><td>SIMD Floating-Point Exception<td>19 (0x13)<td>Fault<td>#XM/#XF<td>No<tr><td>Virtualization Exception<td>20 (0x14)<td>Fault<td>#VE<td>No<tr><td>Reserved<td>21-29 (0x15-0x1D)<td>-<td>-<td>No<tr><td>Security Exception<td>30 (0x1E)<td>-<td>#SX<td>Yes<tr><td>Reserved<td>31 (0x1F)<td>-<td>-<td>No<tr><td>Triple Fault<td>-<td>-<td>-<td>No<tr><td>FPU Error Interrupt<td>IRQ 13<td>Interrupt<td>#FERR<td>No</table></div><p>Now that we learn how to create a new events, it’s time to see how to monitor system interrupts.</p><h1 id="exception-bitmap"><strong>Exception Bitmap</strong></h1><p>If you remember from MSR Bitmaps, we have a mask for each MSR that shows whether the read or write on that MSR should cause a vm-exit or not.</p><p>The monitoring of exceptions uses the same method, which means that a simple mask governs it. This mask is <strong>EXCEPTION_BITMAP</strong> in VMCS.</p><p>The exception bitmap is a 32-bit field that contains one bit for each exception. When an exception occurs, its vector is used to select a bit in this field. If the bit is 1, the exception causes a VM exit. If the bit is 0, the exception is delivered normally through the IDT.</p><p>Now it’s up to you to decide whether you want to inject that exception back to the guest or change the state or whatever you want to do.</p><p>For example, if you set the 3rd bit of the <strong>EXCEPTION_BITMAP,</strong> then whenever a breakpoint occurs somewhere (both user-mode and kernel-mode), a vm-exit with <strong>EXIT_REASON_EXCEPTION_NMI</strong> (exit reason == 0) occurs.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Set exception bitmap to hook division by zero (bit 1 of EXCEPTION_BITMAP)</span>
	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">EXCEPTION_BITMAP</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span> <span class="c1">// breakpoint 3nd bit</span>
</pre></table></code></div></div><p>Now we can change the state of the program, then resume the guest, remember resuming the guest doesn’t cause the exception to be delivered to the guest, we have to inject an event manually if we want that the guest process the event normally. For example, we can use the function “EventInjectBreakpoint,” as mentioned earlier, to inject the exception back to the guest.</p><p>The last question is how we can find the index of exception that occurred, you know we might set exception bitmap for multiple exceptions, so we have to know the exact reason why this vm-exit happened or more clearly, what exception causes this vm-exit.</p><p>The following VMCS fields report us about the event,</p><ul><li><strong>VM_EXIT_INTR_INFO</strong><li><strong>VM_EXIT_INTR_ERROR_CODE</strong></ul><p>The following table shows how we can use <strong>VM_EXIT_INTR_INFO</strong>.</p><p><img data-src="../../assets/images/vm-exit-interruption-information.png" alt="" data-proofer-ignore></p><p>Which is the following structure:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">union</span> <span class="n">_VMEXIT_INTERRUPT_INFO</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">UINT32</span> <span class="n">Vector</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">UINT32</span> <span class="n">InterruptionType</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">UINT32</span> <span class="n">ErrorCodeValid</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">UINT32</span> <span class="n">NmiUnblocking</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">UINT32</span> <span class="n">Reserved</span> <span class="o">:</span> <span class="mi">18</span><span class="p">;</span>
		<span class="n">UINT32</span> <span class="n">Valid</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">UINT32</span> <span class="n">Flags</span><span class="p">;</span>
<span class="p">}</span><span class="n">VMEXIT_INTERRUPT_INFO</span><span class="p">,</span> <span class="o">*</span> <span class="n">PVMEXIT_INTERRUPT_INFO</span><span class="p">;</span>
</pre></table></code></div></div><p>And we can read the details using <strong>vmread</strong> instruction, for example, the following command shows how we can detect if breakpoint (0xcc) occurred.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>		<span class="c1">// read the exit reason</span>
		<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">InterruptExit</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">InterruptExit</span><span class="p">.</span><span class="n">InterruptionType</span> <span class="o">==</span> <span class="n">INTERRUPT_TYPE_SOFTWARE_EXCEPTION</span> <span class="o">&amp;&amp;</span> <span class="n">InterruptExit</span><span class="p">.</span><span class="n">Vector</span> <span class="o">==</span> <span class="n">EXCEPTION_VECTOR_BREAKPOINT</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="c1">// Do whatever , e.g re-inject the breakpoint</span>
		<span class="p">}</span>
</pre></table></code></div></div><p>If we want to re-inject an exception that comes with an error code (see the above table), then the error code can be read using <strong>VM_EXIT_INTR_ERROR_CODE</strong> in VMCS. After that, write the error code to <strong>VM_ENTRY_EXCEPTION_ERROR_CODE</strong> and enable the deliver-error-code of <strong>VM_ENTRY_INTR_INFO</strong> to make sure that re-injection is without any flaw.</p><p>Also, keep in mind that page-fault is treated differently you can read Intel SDM for more information.</p><p>But wait! Have you notice that exception bitmap are just a 32-bit field in VMCS while we have up to 256 interrupts in IDT ?!</p><p>If you’re curious about this question you can read its answer in <strong>Discussion</strong> section.</p><h1 id="monitor-trap-flag-mtf"><strong>Monitor Trap Flag (MTF)</strong></h1><p>Monitor Trap Flag or MTF is a feature that works exactly like <strong>Trap Flag</strong> in <strong>r/eflags</strong> except it’s invisible to the guest.</p><p>Whenever you set this flag on <strong>CPU_BASED_VM_EXEC_CONTROL</strong>, after <strong>VMRESUME</strong>, the processor executes <strong>one instruction</strong> then a vm-exit occurs.</p><p>We have to clear this flag otherwise each instruction cause a vm-exit.</p><p>The following function is responsible for setting and unsetting MTF.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cm">/* Set the monitor trap flag */</span>
<span class="n">VOID</span> <span class="nf">HvSetMonitorTrapFlag</span><span class="p">(</span><span class="n">BOOLEAN</span> <span class="n">Set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">CpuBasedVmExecControls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Read the previous flag</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CpuBasedVmExecControls</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">Set</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CpuBasedVmExecControls</span> <span class="o">|=</span> <span class="n">CPU_BASED_MONITOR_TRAP_FLAG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">CpuBasedVmExecControls</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_MONITOR_TRAP_FLAG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Set the new value </span>
	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">CpuBasedVmExecControls</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Setting MTF leads to a vm-exit with exit reason (EXIT_REASON_MONITOR_TRAP_FLAG), we unset the MTF in the vm-exit handler.</p><p>MTF is essential in implementing hidden hooks, more details about <strong>MtfEptHookRestorePoint</strong> later in the <strong>hidden hooks</strong> section.</p><p>Here’s the MTF vm-exit handler.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">EXIT_REASON_MONITOR_TRAP_FLAG</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="cm">/* Monitor Trap Flag */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">MtfEptHookRestorePoint</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Restore the previous state</span>
			<span class="n">EptHandleMonitorTrapFlag</span><span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">MtfEptHookRestorePoint</span><span class="p">);</span>
			<span class="c1">// Set it to NULL</span>
			<span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">MtfEptHookRestorePoint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">LogError</span><span class="p">(</span><span class="s">"Why MTF occured ?!"</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// Redo the instruction </span>
		<span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">IncrementRip</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="c1">// We don't need MTF anymore</span>
		<span class="n">HvSetMonitorTrapFlag</span><span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><h1 id="hidden-hooks"><strong>Hidden Hooks</strong></h1><h3 id="simulating-hardware-debug-registers-without-any-limitation"><span class="mr-2"><strong>(Simulating Hardware Debug Registers Without Any Limitation)</strong></span><a href="#simulating-hardware-debug-registers-without-any-limitation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Have you ever used hardware debugger registers ?!</p><p>The debug registers allow researchers and programmers to selectively enable various debug conditions (read, write, execute) associated with a set of four debug addresses without any change in program instructions.</p><p>As you know, we can set up to 4 locations to these hardware registers, and it’s the worst limitation for these registers.</p><p>so what if we have a structure (let say <strong>_EPROCESS</strong>) and we want to see what function in Windows <strong>Read</strong> or <strong>Write</strong> in this structure?</p><p>It’s not possible with current debug registers but we use EPT to rescue !</p><h2 id="hidden-hooks-scenarios-for-readwrite-and-execute"><span class="mr-2"><strong>Hidden Hooks Scenarios for Read/Write and Execute</strong></span><a href="#hidden-hooks-scenarios-for-readwrite-and-execute" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>We have two strategies for hidden hooks, one for <strong>Read/Write</strong> and one for <strong>Execute</strong>.</p><p><strong>For Read/Write,</strong></p><p>we unset read or write or both (based on how user wants) in the entry corresponding to the address.</p><p>This means before read or write a vm-exit occurs, and an EPT Violation will notify us. In the EPT Violation handler, we log the address that tries to read or write, then we find the entry in EPT table and set both read and write (means that any read or write to the page is allowed) and also set an MTF flag.</p><p>VMM resumes, and one instruction executes, or in other words, read or write is performed, then an MTF vm-exit occurs. In MTF vm-exit handler, we unset the read and write access again so any future access to that page will cause an EPT Violation.</p><p>Note that all of the above scenarios happen to one core. Each core has a separate TLB and separate Monitor Trap Flag.</p><p><strong>For Execute,</strong></p><p>For execution, we use a capability in Intel processors called <strong>execute-only</strong>.</p><p><strong>Execute-only</strong> means that we can have a page with <strong>execute access</strong> enabled while <strong>read and write access</strong> is disabled.</p><p>If the user wants an execution hook, then we find the entry in EPT Table and unset read and write access and set the execute access. Then we create a copy from the original page (<strong>Page A</strong>) to somewhere else (<strong>Page B</strong>) and modify the copied page (<strong>Page B</strong>) with an absolute jump to the hook function.</p><p>Now, each time that any instruction attempted to execute our function, the absolute jump is performed, and our hook function is called. Each time any instruction tries to read or write to that location, an EPT Violation occurs as we unset <strong>read and write access</strong> to that page, so we can swap the original page (Page A) and also set the monitor trap flag to restore the hook after executing one instruction.</p><p>Wasn’t it easy ? Review it one more time if you didn’t understand.</p><p>You can also think about the different methods; for example, <a href="https://github.com/tandasat/DdiMon">DdiMon</a> creates a copy from that page and modifies the hook location by replacing one bytes (0xcc) breakpoint there. Now it intercepts each breakpoint (using Exception Bitmap) and swaps the original page. This method is much simpler to implement and more reliable, but it causes vm-exit for each hook, so it’s slower, but the first method for EPT Hooks never causes a vm-exit for execution.</p><p>Vm-exits for Read and Write hooks are unavoidable.</p><p>The execution hook for this part is derived from <a href="https://github.com/Gbps/gbhv">Gbps hv</a>.</p><p>Let’s dig into implementation.</p><h2 id="implementing-hidden-hooks"><span class="mr-2"><strong>Implementing Hidden Hooks</strong></span><a href="#implementing-hidden-hooks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For hooking functions, first, we split the page into 4KB entries, as described in the <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-7/">previous part</a>. Then find the entry and read that entry. We want to save the details of a hooked page so we can use it later. For read/write hooks, we unset read or write or both, while for executing hooks, we unset read/write access and set execute access and also copy the page contents into a new page and swap the entry’s physical address with the second page’s physical address (fake page’s physical address).</p><p>Then we build a trampoline (explained later) and finally decide how to invalidate the TLB based on vmx-state (vmx-root or vmx non-root) and finally add the hook details to the <strong>HookedPagesList</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
</pre><td class="rouge-code"><pre><span class="cm">/* This function returns false in VMX Non-Root Mode if the VM is already initialized
   This function have to be called through a VMCALL in VMX Root Mode */</span>
<span class="n">BOOLEAN</span> <span class="nf">EptPerformPageHook</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">TargetAddress</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">HookFunction</span><span class="p">,</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">OrigFunction</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">UnsetRead</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">UnsetWrite</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">UnsetExecute</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">EPT_PML1_ENTRY</span> <span class="n">ChangedEntry</span><span class="p">;</span>
	<span class="n">INVEPT_DESCRIPTOR</span> <span class="n">Descriptor</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">VirtualTarget</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">TargetBuffer</span><span class="p">;</span>
	<span class="n">PEPT_PML1_ENTRY</span> <span class="n">TargetPage</span><span class="p">;</span>
	<span class="n">PEPT_HOOKED_PAGE_DETAIL</span> <span class="n">HookedPage</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">LogicalCoreIndex</span><span class="p">;</span>

	<span class="c1">// Check whether we are in VMX Root Mode or Not </span>
	<span class="n">LogicalCoreIndex</span> <span class="o">=</span> <span class="n">KeGetCurrentProcessorIndex</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">IsOnVmxRootMode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">HasLaunched</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Translate the page from a physical address to virtual so we can read its memory.
	 * This function will return NULL if the physical address was not already mapped in
	 * virtual memory.
	 */</span>
	<span class="n">VirtualTarget</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">TargetAddress</span><span class="p">);</span>

	<span class="n">PhysicalAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="n">VirtualTarget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PhysicalAddress</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Target address could not be mapped to physical memory"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Set target buffer, request buffer from pool manager , we also need to allocate new page to replace the current page ASAP</span>
	<span class="n">TargetBuffer</span> <span class="o">=</span> <span class="n">PoolManagerRequestPool</span><span class="p">(</span><span class="n">SPLIT_2MB_PAGING_TO_4KB_PAGE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VMM_EPT_DYNAMIC_SPLIT</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetBuffer</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"There is no pre-allocated buffer available"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EptSplitLargePage</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">TargetBuffer</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">,</span> <span class="n">LogicalCoreIndex</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Could not split page for the address : 0x%llx"</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Pointer to the page entry in the page table. </span>
	<span class="n">TargetPage</span> <span class="o">=</span> <span class="n">EptGetPml1Entry</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPageTable</span><span class="p">,</span> <span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Ensure the target is valid. </span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TargetPage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Failed to get PML1 entry of the target address"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Save the original permissions of the page </span>
	<span class="n">ChangedEntry</span> <span class="o">=</span> <span class="o">*</span><span class="n">TargetPage</span><span class="p">;</span>

	<span class="cm">/* Execution is treated differently */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UnsetRead</span><span class="p">)</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UnsetWrite</span><span class="p">)</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


	<span class="cm">/* Save the detail of hooked page to keep track of it */</span>
	<span class="n">HookedPage</span> <span class="o">=</span> <span class="n">PoolManagerRequestPool</span><span class="p">(</span><span class="n">TRACKING_HOOKED_PAGES</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">EPT_HOOKED_PAGE_DETAIL</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HookedPage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"There is no pre-allocated pool for saving hooked page details"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Save the virtual address</span>
	<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span> <span class="o">=</span> <span class="n">TargetAddress</span><span class="p">;</span>

	<span class="c1">// Save the physical address</span>
	<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">=</span> <span class="n">PhysicalAddress</span><span class="p">;</span>

	<span class="c1">// Fake page content physical address</span>
	<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddressOfFakePageContents</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">FakePageContents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="c1">// Save the entry address</span>
	<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">EntryAddress</span> <span class="o">=</span> <span class="n">TargetPage</span><span class="p">;</span>

	<span class="c1">// Save the orginal entry</span>
	<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">OriginalEntry</span> <span class="o">=</span> <span class="o">*</span><span class="n">TargetPage</span><span class="p">;</span>


	<span class="c1">// If it's Execution hook then we have to set extra fields</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UnsetExecute</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Show that entry has hidden hooks for execution</span>
		<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">IsExecutionHook</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

		<span class="c1">// In execution hook, we have to make sure to unset read, write because</span>
		<span class="c1">// an EPT violation should occur for these cases and we can swap the original page</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// Also set the current pfn to fake page</span>
		<span class="n">ChangedEntry</span><span class="p">.</span><span class="n">PageFrameNumber</span> <span class="o">=</span> <span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddressOfFakePageContents</span><span class="p">;</span>

		<span class="c1">// Copy the content to the fake page</span>
		<span class="n">RtlCopyBytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">FakePageContents</span><span class="p">,</span> <span class="n">VirtualTarget</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="c1">// Create Hook</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EptHookInstructionMemory</span><span class="p">(</span><span class="n">HookedPage</span><span class="p">,</span> <span class="n">TargetAddress</span><span class="p">,</span> <span class="n">HookFunction</span><span class="p">,</span> <span class="n">OrigFunction</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">LogError</span><span class="p">(</span><span class="s">"Could not build the hook."</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Save the modified entry</span>
	<span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">ChangedEntry</span> <span class="o">=</span> <span class="n">ChangedEntry</span><span class="p">;</span>

	<span class="c1">// Add it to the list </span>
	<span class="n">InsertHeadList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">HookedPage</span><span class="o">-&gt;</span><span class="n">PageHookList</span><span class="p">));</span>

	<span class="cm">/***********************************************************/</span>
	<span class="c1">// if not launched, there is no need to modify it on a safe environment</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GuestState</span><span class="p">[</span><span class="n">LogicalCoreIndex</span><span class="p">].</span><span class="n">HasLaunched</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Apply the hook to EPT </span>
		<span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">ChangedEntry</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Apply the hook to EPT </span>
		<span class="n">EptSetPML1AndInvalidateTLB</span><span class="p">(</span><span class="n">TargetPage</span><span class="p">,</span> <span class="n">ChangedEntry</span><span class="p">,</span> <span class="n">INVEPT_SINGLE_CONTEXT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now we need a function that creates another page and patches the original page (<strong>Page A</strong>) with an absolute jump (trampoline) that jumps another page (<strong>Page B</strong>).</p><p>In (<strong>Page B</strong>) we will jump to the hooked function also this function copies the bytes that are patched to the (<strong>Page B</strong>) and save the original function for the caller to return back to the original page on (Page B).</p><p>This is a simple inline hook that we use LDE (<a href="https://github.com/DominicTobias/detourxs">LDE64x64</a>) as the detour function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span> <span class="nf">EptHookInstructionMemory</span><span class="p">(</span><span class="n">PEPT_HOOKED_PAGE_DETAIL</span> <span class="n">Hook</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">TargetFunction</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">HookFunction</span><span class="p">,</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">OrigFunction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SIZE_T</span> <span class="n">SizeOfHookedInstructions</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">OffsetIntoPage</span><span class="p">;</span>

	<span class="n">OffsetIntoPage</span> <span class="o">=</span> <span class="n">ADDRMASK_EPT_PML1_OFFSET</span><span class="p">((</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">TargetFunction</span><span class="p">);</span>
	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"OffsetIntoPage: 0x%llx"</span><span class="p">,</span> <span class="n">OffsetIntoPage</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">OffsetIntoPage</span> <span class="o">+</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Function extends past a page boundary. We just don't have the technology to solve this....."</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine the number of instructions necessary to overwrite using Length Disassembler Engine */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">SizeOfHookedInstructions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SizeOfHookedInstructions</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">;</span>
		<span class="n">SizeOfHookedInstructions</span> <span class="o">+=</span> <span class="n">LDE</span><span class="p">(</span><span class="n">TargetFunction</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="c1">// Get the full size of instructions necessary to copy</span>
	<span class="p">}</span>

	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Number of bytes of instruction mem: %d"</span><span class="p">,</span> <span class="n">SizeOfHookedInstructions</span><span class="p">);</span>

	<span class="cm">/* Build a trampoline */</span>

	<span class="cm">/* Allocate some executable memory for the trampoline */</span>
	<span class="n">Hook</span><span class="o">-&gt;</span><span class="n">Trampoline</span> <span class="o">=</span> <span class="n">PoolManagerRequestPool</span><span class="p">(</span><span class="n">EXEC_TRAMPOLINE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">MAX_EXEC_TRAMPOLINE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Hook</span><span class="o">-&gt;</span><span class="n">Trampoline</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Could not allocate trampoline function buffer."</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the trampoline instructions in. */</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">Hook</span><span class="o">-&gt;</span><span class="n">Trampoline</span><span class="p">,</span> <span class="n">TargetFunction</span><span class="p">,</span> <span class="n">SizeOfHookedInstructions</span><span class="p">);</span>

	<span class="cm">/* Add the absolute jump back to the original function. */</span>
	<span class="n">EptHookWriteAbsoluteJump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Hook</span><span class="o">-&gt;</span><span class="n">Trampoline</span><span class="p">[</span><span class="n">SizeOfHookedInstructions</span><span class="p">],</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">TargetFunction</span> <span class="o">+</span> <span class="n">SizeOfHookedInstructions</span><span class="p">);</span>

	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Trampoline: 0x%llx"</span><span class="p">,</span> <span class="n">Hook</span><span class="o">-&gt;</span><span class="n">Trampoline</span><span class="p">);</span>
	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"HookFunction: 0x%llx"</span><span class="p">,</span> <span class="n">HookFunction</span><span class="p">);</span>

	<span class="cm">/* Let the hook function call the original function */</span>
	<span class="o">*</span><span class="n">OrigFunction</span> <span class="o">=</span> <span class="n">Hook</span><span class="o">-&gt;</span><span class="n">Trampoline</span><span class="p">;</span>

	<span class="cm">/* Write the absolute jump to our shadow page memory to jump to our hook. */</span>
	<span class="n">EptHookWriteAbsoluteJump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Hook</span><span class="o">-&gt;</span><span class="n">FakePageContents</span><span class="p">[</span><span class="n">OffsetIntoPage</span><span class="p">],</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">HookFunction</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>For creating a simple absolute jump we use the following function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/* Write an absolute x64 jump to an arbitrary address to a buffer. */</span>
<span class="n">VOID</span> <span class="nf">EptHookWriteAbsoluteJump</span><span class="p">(</span><span class="n">PCHAR</span> <span class="n">TargetBuffer</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">TargetAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mov r15, Target */</span>
	<span class="n">TargetBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x49</span><span class="p">;</span>
	<span class="n">TargetBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xBB</span><span class="p">;</span>

	<span class="cm">/* Target */</span>
	<span class="o">*</span><span class="p">((</span><span class="n">PSIZE_T</span><span class="p">)</span><span class="o">&amp;</span><span class="n">TargetBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="n">TargetAddress</span><span class="p">;</span>

	<span class="cm">/* push r15 */</span>
	<span class="n">TargetBuffer</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x41</span><span class="p">;</span>
	<span class="n">TargetBuffer</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x53</span><span class="p">;</span>

	<span class="cm">/* ret */</span>
	<span class="n">TargetBuffer</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC3</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the case of EPT Violations, first, we find the details of the physical address that caused this vm-exit. Then we call <strong>EptHandleHookedPage</strong> to create a log about the details then we set an MTF to restore to the hooked state after executing one instruction.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="cm">/* Check if this exit is due to a violation caused by a currently hooked page. Returns FALSE
 * if the violation was not due to a page hook.
 *
 * If the memory access attempt was RW and the page was marked executable, the page is swapped with
 * the original page.
 *
 * If the memory access attempt was execute and the page was marked not executable, the page is swapped with
 * the hooked page.
 */</span>
<span class="n">BOOLEAN</span> <span class="nf">EptHandlePageHookExit</span><span class="p">(</span><span class="n">VMX_EXIT_QUALIFICATION_EPT_VIOLATION</span> <span class="n">ViolationQualification</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">GuestPhysicalAddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BOOLEAN</span> <span class="n">IsHandled</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">PLIST_ENTRY</span> <span class="n">TempList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">TempList</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span> <span class="o">!=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">TempList</span> <span class="o">=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
		<span class="n">PEPT_HOOKED_PAGE_DETAIL</span> <span class="n">HookedEntry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">TempList</span><span class="p">,</span> <span class="n">EPT_HOOKED_PAGE_DETAIL</span><span class="p">,</span> <span class="n">PageHookList</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">==</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">GuestPhysicalAddr</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="cm">/* We found an address that match the details */</span>

			<span class="cm">/*
			   Returning true means that the caller should return to the ept state to the previous state when this instruction is executed
			   by setting the Monitor Trap Flag. Return false means that nothing special for the caller to do
			*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">EptHandleHookedPage</span><span class="p">(</span><span class="n">HookedEntry</span><span class="p">,</span> <span class="n">ViolationQualification</span><span class="p">,</span> <span class="n">GuestPhysicalAddr</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="c1">// Next we have to save the current hooked entry to restore on the next instruction's vm-exit</span>
				<span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">MtfEptHookRestorePoint</span> <span class="o">=</span> <span class="n">HookedEntry</span><span class="p">;</span>

				<span class="c1">// We have to set Monitor trap flag and give it the HookedEntry to work with</span>
				<span class="n">HvSetMonitorTrapFlag</span><span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>


			<span class="p">}</span>

			<span class="c1">// Indicate that we handled the ept violation</span>
			<span class="n">IsHandled</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

			<span class="c1">// Get out of the loop</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// Redo the instruction </span>
	<span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IncrementRip</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">IsHandled</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p>Each time an EPT Violation occurs, we check whether it was because <strong>Read Access</strong> or <strong>Write Access</strong> or <strong>Execute Access</strong> violation and log <strong>GUEST_RIP</strong>, then we restore the initial flags (All read, write, and exec is allowed).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span> <span class="nf">EptHandleHookedPage</span><span class="p">(</span><span class="n">EPT_HOOKED_PAGE_DETAIL</span><span class="o">*</span> <span class="n">HookedEntryDetails</span><span class="p">,</span> <span class="n">VMX_EXIT_QUALIFICATION_EPT_VIOLATION</span> <span class="n">ViolationQualification</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">ULONG64</span> <span class="n">GuestRip</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">ExactAccessedAddress</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">AlignedVirtualAddress</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">AlignedPhysicalAddress</span><span class="p">;</span>


	<span class="c1">// Get alignment</span>
	<span class="n">AlignedVirtualAddress</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">HookedEntryDetails</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">);</span>
	<span class="n">AlignedPhysicalAddress</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">);</span>

	<span class="c1">// Let's read the exact address that was accesses</span>
	<span class="n">ExactAccessedAddress</span> <span class="o">=</span> <span class="n">AlignedVirtualAddress</span> <span class="o">+</span> <span class="n">PhysicalAddress</span> <span class="o">-</span> <span class="n">AlignedPhysicalAddress</span><span class="p">;</span>

	<span class="c1">// Reading guest's RIP </span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestRip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ViolationQualification</span><span class="p">.</span><span class="n">EptExecutable</span> <span class="o">&amp;&amp;</span> <span class="n">ViolationQualification</span><span class="p">.</span><span class="n">ExecuteAccess</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Guest RIP : 0x%llx tries to execute the page at : 0x%llx"</span><span class="p">,</span> <span class="n">GuestRip</span><span class="p">,</span> <span class="n">ExactAccessedAddress</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ViolationQualification</span><span class="p">.</span><span class="n">EptWriteable</span> <span class="o">&amp;&amp;</span> <span class="n">ViolationQualification</span><span class="p">.</span><span class="n">WriteAccess</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Guest RIP : 0x%llx tries to write on the page at :0x%llx"</span><span class="p">,</span> <span class="n">GuestRip</span><span class="p">,</span> <span class="n">ExactAccessedAddress</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ViolationQualification</span><span class="p">.</span><span class="n">EptReadable</span> <span class="o">&amp;&amp;</span> <span class="n">ViolationQualification</span><span class="p">.</span><span class="n">ReadAccess</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Guest RIP : 0x%llx tries to read the page at :0x%llx"</span><span class="p">,</span> <span class="n">GuestRip</span><span class="p">,</span> <span class="n">ExactAccessedAddress</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// there was an unexpected ept violation</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">EptSetPML1AndInvalidateTLB</span><span class="p">(</span><span class="n">HookedEntryDetails</span><span class="o">-&gt;</span><span class="n">EntryAddress</span><span class="p">,</span> <span class="n">HookedEntryDetails</span><span class="o">-&gt;</span><span class="n">OriginalEntry</span><span class="p">,</span> <span class="n">INVEPT_SINGLE_CONTEXT</span><span class="p">);</span>

	<span class="c1">// Means that restore the Entry to the previous state after current instruction executed in the guest</span>
	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That’s it! We have a working hidden hooks.</p><h2 id="removing-hooks-from-pages"><span class="mr-2"><strong>Removing Hooks From Pages</strong></span><a href="#removing-hooks-from-pages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Removing hooks from pages are essential to us because of two reasons; first, sometimes we need to disable the hooks, and second, when we want to turn off hypervisor, we have to remove all the hooks. Otherwise, we might encounter strange behavior.</p><p>Removing hooks is simple as we saved details, including original entries in <strong>PageHookList; we</strong> have to find entries in this list and broadcast to all processors to update their TLBs and also remove that entry.</p><p>The following function is for this purpose.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>
<span class="cm">/* Remove single hook from the hooked pages list and invalidate TLB */</span>
<span class="n">BOOLEAN</span> <span class="nf">HvPerformPageUnHookSinglePage</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">VirtualAddress</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PLIST_ENTRY</span> <span class="n">TempList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">;</span>

	<span class="n">PhysicalAddress</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">VirtualAddressToPhysicalAddress</span><span class="p">(</span><span class="n">VirtualAddress</span><span class="p">));</span>

	<span class="c1">// Should be called from vmx non-root</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IsOnVmxRootMode</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TempList</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span> <span class="o">!=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">TempList</span> <span class="o">=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
		<span class="n">PEPT_HOOKED_PAGE_DETAIL</span> <span class="n">HookedEntry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">TempList</span><span class="p">,</span> <span class="n">EPT_HOOKED_PAGE_DETAIL</span><span class="p">,</span> <span class="n">PageHookList</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">==</span> <span class="n">PhysicalAddress</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Remove it in all the cores</span>
			<span class="n">KeGenericCallDpc</span><span class="p">(</span><span class="n">HvDpcBroadcastRemoveHookAndInvalidateSingleEntry</span><span class="p">,</span> <span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span><span class="p">);</span>

			<span class="c1">// remove the entry from the list</span>
			<span class="n">RemoveEntryList</span><span class="p">(</span><span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">PageHookList</span><span class="p">.</span><span class="n">Flink</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// Nothing found , probably the list is not found</span>
	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In vmx-root, we also search for the specific hook and use <strong>EptSetPML1AndInvalidateTLB</strong> to return that entry to the initial state, which is previously saved in <strong>OriginalEntry</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cm">/* Remove and Invalidate Hook in TLB */</span>
<span class="c1">// Caution : This function won't remove entries from LIST_ENTRY, just invalidate the paging, use HvPerformPageUnHookSinglePage instead</span>
<span class="n">BOOLEAN</span> <span class="nf">EptPageUnHookSinglePage</span><span class="p">(</span><span class="n">SIZE_T</span> <span class="n">PhysicalAddress</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PLIST_ENTRY</span> <span class="n">TempList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Should be called from vmx-root, for calling from vmx non-root use the corresponding VMCALL</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IsOnVmxRootMode</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TempList</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span> <span class="o">!=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">TempList</span> <span class="o">=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
		<span class="n">PEPT_HOOKED_PAGE_DETAIL</span> <span class="n">HookedEntry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">TempList</span><span class="p">,</span> <span class="n">EPT_HOOKED_PAGE_DETAIL</span><span class="p">,</span> <span class="n">PageHookList</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">PhysicalBaseAddress</span> <span class="o">==</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">PhysicalAddress</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="c1">// Undo the hook on the EPT table</span>
			<span class="n">EptSetPML1AndInvalidateTLB</span><span class="p">(</span><span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">EntryAddress</span><span class="p">,</span> <span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">OriginalEntry</span><span class="p">,</span> <span class="n">INVEPT_SINGLE_CONTEXT</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// Nothing found , probably the list is not found</span>
	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If we want to unhook all the pages, then we use another VMCALL, there is no need to iterate through the list here as all of the hooks must be removed. Just broadcast it through all the cores.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cm">/* Remove all hooks from the hooked pages list and invalidate TLB */</span>
<span class="c1">// Should be called from Vmx Non-root</span>
<span class="n">VOID</span> <span class="nf">HvPerformPageUnHookAllPages</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// Should be called from vmx non-root</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IsOnVmxRootMode</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Remove it in all the cores</span>
	<span class="n">KeGenericCallDpc</span><span class="p">(</span><span class="n">HvDpcBroadcastRemoveHookAndInvalidateAllEntries</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

	<span class="c1">// No need to remove the list as it will automatically remove by the pool uninitializer</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In vmx-root we just iterate through the list and restore them to the initial state.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cm">/* Remove and Invalidate Hook in TLB */</span>
<span class="c1">// Caution : This function won't remove entries from LIST_ENTRY, just invalidate the paging, use HvPerformPageUnHookAllPages instead</span>
<span class="n">VOID</span> <span class="nf">EptPageUnHookAllPages</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">PLIST_ENTRY</span> <span class="n">TempList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Should be called from vmx-root, for calling from vmx non-root use the corresponding VMCALL</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IsOnVmxRootMode</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TempList</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">HookedPagesList</span> <span class="o">!=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">TempList</span> <span class="o">=</span> <span class="n">TempList</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
		<span class="n">PEPT_HOOKED_PAGE_DETAIL</span> <span class="n">HookedEntry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">TempList</span><span class="p">,</span> <span class="n">EPT_HOOKED_PAGE_DETAIL</span><span class="p">,</span> <span class="n">PageHookList</span><span class="p">);</span>

		<span class="c1">// Undo the hook on the EPT table</span>
		<span class="n">EptSetPML1AndInvalidateTLB</span><span class="p">(</span><span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">EntryAddress</span><span class="p">,</span> <span class="n">HookedEntry</span><span class="o">-&gt;</span><span class="n">OriginalEntry</span><span class="p">,</span> <span class="n">INVEPT_SINGLE_CONTEXT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="an-important-note-when-modifying-ept-entries"><span class="mr-2"><strong>An Important Note When Modifying EPT Entries</strong></span><a href="#an-important-note-when-modifying-ept-entries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>One interesting thing that I encountered during the test of my driver on the multi-core system was the fact that EPT entries should be modified in one instruction.</p><p>For example, if you change the access bits of an EPT entry, bit by bit, then you probably get the error (EPT Misconfiguration) that one access bits changed and before the next access bit applies another core tries to access page table and it sometimes leads to an EPT Misconfiguration and sometimes you might not get the desired behavior.</p><p>For example the following method for modifying EPT entries is wrong!</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">HookedEntryDetails</span><span class="o">-&gt;</span><span class="n">EntryAddress</span><span class="o">-&gt;</span><span class="n">ExecuteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">HookedEntryDetails</span><span class="o">-&gt;</span><span class="n">EntryAddress</span><span class="o">-&gt;</span><span class="n">WriteAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">HookedEntryDetails</span><span class="o">-&gt;</span><span class="n">EntryAddress</span><span class="o">-&gt;</span><span class="n">ReadAccess</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><p>But the following code is correct. (Applying changes in one instruction instantly).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>		<span class="c1">// Apply the hook to EPT </span>
		<span class="n">TargetPage</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">OriginalEntry</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>
</pre></table></code></div></div><p>This is why we have the following function that acquires a spinlock that makes sure that only one entry is modified once and then invalidate that core’s TLB.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cm">/*  This function set the specific PML1 entry in a spinlock protected area then invalidate the TLB ,
	this function should be called from vmx root-mode
*/</span>
<span class="n">VOID</span> <span class="nf">EptSetPML1AndInvalidateTLB</span><span class="p">(</span><span class="n">PEPT_PML1_ENTRY</span> <span class="n">EntryAddress</span><span class="p">,</span> <span class="n">EPT_PML1_ENTRY</span> <span class="n">EntryValue</span><span class="p">,</span> <span class="n">INVEPT_TYPE</span> <span class="n">InvalidationType</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// acquire the lock</span>
	<span class="n">SpinlockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Pml1ModificationAndInvalidationLock</span><span class="p">);</span>
	<span class="c1">// set the value</span>
	<span class="n">EntryAddress</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">EntryValue</span><span class="p">.</span><span class="n">Flags</span><span class="p">;</span>

	<span class="c1">// invalidate the cache</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">InvalidationType</span> <span class="o">==</span> <span class="n">INVEPT_SINGLE_CONTEXT</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">InveptSingleContext</span><span class="p">(</span><span class="n">EptState</span><span class="o">-&gt;</span><span class="n">EptPointer</span><span class="p">.</span><span class="n">Flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">InveptAllContexts</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">// release the lock</span>
	<span class="n">SpinlockUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Pml1ModificationAndInvalidationLock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The above function solves the problems of simultaneously modifying the EPT Table as we have one EPT Table for all cores.</p><h1 id="system-call-hook"><strong>System-Call Hook</strong></h1><p>When it comes to hypervisors, we have different options for hooking system-calls. Each of these methods has its own advantages and disadvantages.</p><p>Let’s review some of the methods, that we can use to hook system-calls.</p><p>The first method is hooking MSR <strong>0xc0000082</strong> (<strong>LSTAR</strong>). This MSR is the kernel-entry for dispatching system-calls. Each time an instruction like <strong>Syscall</strong> is executed in user-mode, the processor automatically switches to kernel-mode and runs the address stored in this MSR. In Windows address of <strong>KiSystemCall64</strong> is stored in this MSR.</p><p>This means that each time an application needs to call a system-call, it executes a syscall, and now this function is responsible for finding the entries in SSDT and call. In short, SSDT is a table in Windows that stores pointer to Windows function based on a system-call number. All SSDT entries and LSTAR MSR is under the control of PatchGuard.</p><p>This brings us three possibilities!</p><p>First, we can change the MSR <strong>LSTAR</strong> to point to our custom function, and to make it PatchGuard compatible, we can set MSR Bitmap that if any kernel routine wants to read this MSR, then a vm-exit occurs so we can change the result. Instead of showing our custom handler, we can show the <strong>KiSystemCall64,</strong> and PatchGuard will never know that this is a fake MSR.</p><p>Hooking MSR <strong>LSTAR</strong> is complicated, and updates to Meltdown make it even more complicated. In a post-meltdown system, <strong>LSTAR</strong> points to <strong>KiSystemCall64Shadow,</strong> which involves changing CR3 and execute <a href="https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/">KPTI-related</a> instruction and Meltdown mitigation. It’s not a good idea to hook <strong>LSTAR</strong> as we have difficulties with pre-Meltdown and post-Meltdown mitigations and also as the system-state changes in this MSR so we can’t hook anything in the kernel as the kernel is not mapped on CR3.</p><p><a href="https://github.com/DarthTon/HyperBone">Hyperbone</a> uses this method (even it not updated for post-meltdown systems in the time of writing this article).</p><p>The second option is finding SSDT tables and change their entry to point to our custom functions, each time the PatchGuard tries to audit these entries, we can show it the not-patched listings. The only thing that we should keep in mind is to find where KiSystemCall64 tries to read that location and save that location somewhere so we can know that if the function that tries to read is syscall dispatcher our other functions (and probably PatchGuard).</p><p>Implementing this method is not super-fast as we need to unset EPT Read for SSDT entry, and each time a read happens, a vm-exit occurs, so we have one vm-exit for each syscall thus it makes our computer slow!</p><p>The third option is finding functions in SSDT entries and put a hidden hook on the functions that we need to hook. This way, we can catch a custom list of functions because I think hooking all system-calls is stupid!</p><p>We implement the third option in this part.</p><p>Another possible way is Syscall Hooking Via Extended Feature Enable Register (EFER), as described <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">here</a>. This method is based on disabling Syscall Enable (or SCE bit) of the EFER MSR; hence each time a Syscall is executed, a <strong>#UD</strong> exception is generated by the processor, and we can intercept <strong>#UD</strong> by using Exception Bitmap (described above) to handle these syscalls.</p><p>Again it’s not a good idea because it leads to a vm-exit for each syscall; thus, it’s substantially slow but usable for experimental purposes.</p><p>Also, they might be other options. Don’t hesitate to send a comment to this post and describe if you know one!</p><h2 id="finding-kernel-base"><span class="mr-2"><strong>Finding Kernel Base</strong></span><a href="#finding-kernel-base" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>To find SSDT, we need to find <strong>nt!KeServiceDescriptorTable</strong> and <strong>nt!KeServiceDescriptorTableShadow</strong>, these tables are exported in x86 systems but not in x64. This makes the things much complicated as the routines to find these tables might change in future versions of Windows; thus, our Syscall hooker might have problems in future versions.</p><p>First of all, we need to find the base address of <strong>ntoskrnl,</strong> and it’s the image size, this is done by using <strong>ZwQuerySystemInformation</strong>, first, we find this function by using <strong>MmGetSystemRoutineAddress.</strong></p><p>Then we allocate a memory to get the details from Windows and find the base address and module size.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="cm">/* Get the kernel base and Image size */</span>
<span class="n">PVOID</span> <span class="nf">SyscallHookGetKernelBase</span><span class="p">(</span><span class="n">PULONG</span> <span class="n">pImageSize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NTSTATUS</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">ZWQUERYSYSTEMINFORMATION</span> <span class="n">ZwQSI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UNICODE_STRING</span> <span class="n">routineName</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">pModuleBase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">PSYSTEM_MODULE_INFORMATION</span> <span class="n">pSystemInfoBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">SystemInfoBufferSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">RtlInitUnicodeString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">routineName</span><span class="p">,</span> <span class="s">L"ZwQuerySystemInformation"</span><span class="p">);</span>
	<span class="n">ZwQSI</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZWQUERYSYSTEMINFORMATION</span><span class="p">)</span><span class="n">MmGetSystemRoutineAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">routineName</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ZwQSI</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>


	<span class="n">status</span> <span class="o">=</span> <span class="n">ZwQSI</span><span class="p">(</span><span class="n">SystemModuleInformation</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">SystemInfoBufferSize</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">SystemInfoBufferSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SystemInfoBufferSize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"ZwQuerySystemInformation (1) failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pSystemInfoBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSYSTEM_MODULE_INFORMATION</span><span class="p">)</span><span class="n">ExAllocatePool</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="n">SystemInfoBufferSize</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pSystemInfoBuffer</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"ExAllocatePool failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pSystemInfoBuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SystemInfoBufferSize</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ZwQSI</span><span class="p">(</span><span class="n">SystemModuleInformation</span><span class="p">,</span>
		<span class="n">pSystemInfoBuffer</span><span class="p">,</span>
		<span class="n">SystemInfoBufferSize</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">SystemInfoBufferSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">pModuleBase</span> <span class="o">=</span> <span class="n">pSystemInfoBuffer</span><span class="o">-&gt;</span><span class="n">Module</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ImageBase</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pImageSize</span><span class="p">)</span>
			<span class="o">*</span><span class="n">pImageSize</span> <span class="o">=</span> <span class="n">pSystemInfoBuffer</span><span class="o">-&gt;</span><span class="n">Module</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ImageSize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"ZwQuerySystemInformation (2) failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ExFreePool</span><span class="p">(</span><span class="n">pSystemInfoBuffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pModuleBase</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>Update 2</strong>: You can also use <strong>RtlPcToFileHeader</strong> instead of above method:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">RtlPcToFileHeader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RtlPcToFileHeader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NtoskrnlBase</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="finding-ssdt-and-shadow-ssdt-tables"><span class="mr-2"><strong>Finding SSDT and Shadow SSDT Tables</strong></span><a href="#finding-ssdt-and-shadow-ssdt-tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that we have the base address ntoskrnl we can search for this pattern to find <strong>nt!KeServiceDescriptorTableShadow</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">KiSystemServiceStartPattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0xF8</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span> <span class="mh">0xEF</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xE7</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>
</pre></table></code></div></div><p><strong>nt!KeServiceDescriptorTableShadow</strong> contains the <strong>nt!KiServiceTable</strong> and <strong>win32k!W32pServiceTable,</strong> which is the SSDT of Syscall function for both NT Syscalls and Win32K Syscalls.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre>
<span class="cm">/* Find SSDT address of Nt fucntions and W32Table */</span>
<span class="n">BOOLEAN</span> <span class="nf">SyscallHookFindSsdt</span><span class="p">(</span><span class="n">PUINT64</span> <span class="n">NtTable</span><span class="p">,</span> <span class="n">PUINT64</span> <span class="n">Win32kTable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">kernelSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ULONG_PTR</span> <span class="n">kernelBase</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">KiSystemServiceStartPattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0xF8</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span> <span class="mh">0xEF</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xE7</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>
	<span class="k">const</span> <span class="n">ULONG</span> <span class="n">signatureSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">KiSystemServiceStartPattern</span><span class="p">);</span>
	<span class="n">BOOLEAN</span> <span class="n">found</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">LONG</span> <span class="n">relativeOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ULONG_PTR</span> <span class="n">addressAfterPattern</span><span class="p">;</span>
	<span class="n">ULONG_PTR</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">SSDTStruct</span><span class="o">*</span> <span class="n">shadow</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">ntTable</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">win32kTable</span><span class="p">;</span>

	<span class="c1">//x64 code</span>
	<span class="n">kernelBase</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span><span class="n">SyscallHookGetKernelBase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernelSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernelBase</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">kernelSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="c1">// Find KiSystemServiceStart</span>

	<span class="n">ULONG</span> <span class="n">KiSSSOffset</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">KiSSSOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">KiSSSOffset</span> <span class="o">&lt;</span> <span class="n">kernelSize</span> <span class="o">-</span> <span class="n">signatureSize</span><span class="p">;</span> <span class="n">KiSSSOffset</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RtlCompareMemory</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernelBase</span> <span class="o">+</span> <span class="n">KiSSSOffset</span><span class="p">),</span> <span class="n">KiSystemServiceStartPattern</span><span class="p">,</span> <span class="n">signatureSize</span><span class="p">)</span> <span class="o">==</span> <span class="n">signatureSize</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="n">addressAfterPattern</span> <span class="o">=</span> <span class="n">kernelBase</span> <span class="o">+</span> <span class="n">KiSSSOffset</span> <span class="o">+</span> <span class="n">signatureSize</span><span class="p">;</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">addressAfterPattern</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// Skip lea r10,[nt!KeServiceDescriptorTable]</span>
	<span class="c1">// lea r11, KeServiceDescriptorTableShadow</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">address</span> <span class="o">==</span> <span class="mh">0x4c</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">address</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x8d</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">address</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x1d</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">relativeOffset</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">LONG</span><span class="o">*</span><span class="p">)(</span><span class="n">address</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">relativeOffset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="n">shadow</span> <span class="o">=</span> <span class="p">(</span><span class="n">SSDTStruct</span><span class="o">*</span><span class="p">)(</span><span class="n">address</span> <span class="o">+</span> <span class="n">relativeOffset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>

	<span class="n">ntTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">shadow</span><span class="p">;</span>
	<span class="n">win32kTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="p">)</span><span class="n">shadow</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">);</span>    <span class="c1">// Offset showed in Windbg</span>

	<span class="o">*</span><span class="n">NtTable</span> <span class="o">=</span> <span class="n">ntTable</span><span class="p">;</span>
	<span class="o">*</span><span class="n">Win32kTable</span> <span class="o">=</span> <span class="n">win32kTable</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Note that <strong>nt!KeServiceDescriptorTable</strong> only contains the <strong>nt!KiServiceTable,</strong> and it doesn’t provide <strong>win32k!W32pServiceTable</strong>.</p><h2 id="get-routine-address-by-syscall-number"><span class="mr-2"><strong>Get Routine Address by Syscall Number</strong></span><a href="#get-routine-address-by-syscall-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>After finding the NT Syscall Table and Win32k Syscall Table, now it’s time to translate Syscall Numbers to its corresponding address.</p><p>The following formula converts API Number to function address.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">((</span><span class="n">SSDT</span><span class="o">-&gt;</span><span class="n">pServiceTable</span><span class="p">[</span><span class="n">ApiNumber</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">SSDTbase</span><span class="p">);</span>
</pre></table></code></div></div><p>Keep in mind that NT Syscalls start from 0x0, but Win32k Syscalls start from 0x1000, so as we computer indexes based on the start of the table, we should minus the Win32k Syscalls with 0x1000.</p><p>All in all, we have the following function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cm">/* Find entry from SSDT table of Nt fucntions and W32Table syscalls */</span>
<span class="n">PVOID</span> <span class="nf">SyscallHookGetFunctionAddress</span><span class="p">(</span><span class="n">INT32</span> <span class="n">ApiNumber</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">GetFromWin32k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SSDTStruct</span><span class="o">*</span> <span class="n">SSDT</span><span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">Result</span><span class="p">;</span>
	<span class="n">ULONG_PTR</span> <span class="n">SSDTbase</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">ReadOffset</span><span class="p">;</span>
	<span class="n">UINT64</span> <span class="n">NtTable</span><span class="p">,</span> <span class="n">Win32kTable</span><span class="p">;</span>

	<span class="c1">// Read the address og SSDT</span>
	<span class="n">Result</span> <span class="o">=</span> <span class="n">SyscallHookFindSsdt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NtTable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Win32kTable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Result</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"SSDT not found"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetFromWin32k</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">SSDT</span> <span class="o">=</span> <span class="n">NtTable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Win32k APIs start from 0x1000</span>
		<span class="n">ApiNumber</span> <span class="o">=</span> <span class="n">ApiNumber</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">;</span>
		<span class="n">SSDT</span> <span class="o">=</span> <span class="n">Win32kTable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SSDTbase</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span><span class="n">SSDT</span><span class="o">-&gt;</span><span class="n">pServiceTable</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SSDTbase</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"ServiceTable not found"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">SSDT</span><span class="o">-&gt;</span><span class="n">pServiceTable</span><span class="p">[</span><span class="n">ApiNumber</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">SSDTbase</span><span class="p">);</span>

<span class="p">}</span>
</pre></table></code></div></div><p>Now that we have the address of the routine that we want, now it’s time to put a hidden hook on that function, we also need their functions prototypes so we can read their arguments appropriately.</p><p>The syscall hook example is demonstrated later in the (<strong>How to test?</strong>) section.</p><p><img data-src="../../assets/images/anime-girl-kizuna-ai.jpg" alt="Kizuna ai :)" data-proofer-ignore></p><h1 id="virtual-processor-id-vpid--tlb"><strong>Virtual Processor ID (VPID) &amp; TLB</strong></h1><p>In Intel, its explanation about VPIDs is vague, so I found a great <a href="http://www.jauu.net/2011/11/13/virtual-processor-ids-and-tlb/">link</a> that explains is so much more straightforward; hence it’s better to read the details below instead of starting with SDM.</p><p>The translation lookaside buffer (TLB) is a high-speed memory page cache for virtual to physical address translation. It follows the local principle to avoid time-consuming lookups for recently used pages.</p><p>Host mappings are not coherent to the guest and vice versa. Each guest has it’s own address space, the mapping table cannot be re-used in another guest (or host). Therefore first-generation VMs like Intel Core 2 (VMX) flush the TLB on each VM-enter (resume) and VM-exit. But flushing the TLB is a show-stopper, it is one of the most critical components in a modern CPU.</p><p>Intel engineers started to think about that. Intel Nehalem TLB entries have changed by introducing a Virtual Processor ID. So each TLB entry is tagged with this ID. The CPU does not specify VPIDs, the hypervisor allocates them, whereas the host VPID is 0. Starting with Intel Nehalem, the TLB must not be flushed. When a process tries to access a mapping where the actual VPID does not match with the TLB entry VPID a standard TLB miss occurs. Some Intel numbers show that the latency performance gain is 40% for a VM round trip transition compared to Meron, an Intel Core 2.</p><p>Imagine you have two or more VMs:</p><ul><li>If you enable VPIDs, you don’t have to worry that VM1 accidentally, fetches cached memory of VM2 (or even hypervisor itself)<li>If you don’t enable VPIDs, CPU assigns VPID=0 to all operations (VMX root &amp; VMX non-root) and flushes TLB on each transition for you</ul><p>A logical processor may tag some cached information with a 16-bit VPID.</p><p>The VPID is 0000H in the following situations:</p><ul><li>Outside VMX operation. (e.g System Management Mode (SMM)).<li>VMX root operation<li>VMX non-root operation when the “enable VPID” VM-execution control is 0</ul><h1 id="invvpid---invalidate-translations-based-on-vpid"><strong>INVVPID - Invalidate Translations Based on VPID</strong></h1><p>In order to support VPIDs, we have to add <strong>CPU_BASED_CTL2_ENABLE_VPID</strong> to Secondary Processor-Based VM-Execution Controls.</p><p>The next step is to set a 16-bit value to VMCS’s <strong>VIRTUAL_PROCESSOR_ID</strong> field using <strong>VMWRITE</strong> instruction. This value is used as an index for the current VMCS on this core so our current VMCS’s VPID is 1.</p><p>Also, as described above, 0 has special meaning and should not be used.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>	<span class="c1">// Set up VPID</span>

	<span class="cm">/* For all processors, we will use a VPID = 1. This allows the processor to separate caching
	   of EPT structures away from the regular OS page translation tables in the TLB.	*/</span>

	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VIRTUAL_PROCESSOR_ID</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></table></code></div></div><p>INVVPID (instruction) invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on the <strong>virtual processor identifier</strong> (VPID).</p><p>For the INVVPID there are 4 types that currently supported by the processors which are reported in the <strong>IA32_VMX_EPT_VPID_CAP</strong> MSR.</p><p>The enumeration for these types are :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">enum</span> <span class="n">_INVVPID_ENUM</span>
<span class="p">{</span>
	<span class="n">INDIVIDUAL_ADDRESS</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">,</span>
	<span class="n">SINGLE_CONTEXT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">ALL_CONTEXT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">SINGLE_CONTEXT_RETAINING_GLOBALS</span> <span class="o">=</span> <span class="mh">0x00000003</span>
<span class="p">}</span><span class="n">INVVPID_ENUM</span><span class="p">,</span> <span class="o">*</span><span class="n">PINVVPID_ENUM</span><span class="p">;</span>
</pre></table></code></div></div><p>I’ll describe these types in detail later.</p><p>For the implementation of INVVPID we use an assembly function like this (which executes <strong>invvpid</strong> from the RCX and RDX for x64 fast calling convention) :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">AsmInvept</span> <span class="n">PROC</span> <span class="n">PUBLIC</span>

    <span class="n">invept</span>  <span class="n">rcx</span><span class="p">,</span> <span class="n">oword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">jz</span> <span class="err">@</span><span class="n">jz</span>
    <span class="n">jc</span> <span class="err">@</span><span class="n">jc</span>
    <span class="n">xor</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">ret</span>

    <span class="err">@</span><span class="n">jz</span><span class="o">:</span> 
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">VMX_ERROR_CODE_FAILED_WITH_STATUS</span>
    <span class="n">ret</span>

    <span class="err">@</span><span class="n">jc</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">VMX_ERROR_CODE_FAILED</span>
    <span class="n">ret</span>

<span class="n">AsmInvept</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>and then, a general purpose function for calling this assembly function :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="nf">Invvpid</span><span class="p">(</span><span class="n">INVVPID_ENUM</span> <span class="n">Type</span><span class="p">,</span> <span class="n">INVVPID_DESCRIPTOR</span><span class="o">*</span> <span class="n">Descriptor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Descriptor</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">static</span> <span class="n">INVVPID_DESCRIPTOR</span> <span class="n">ZeroDescriptor</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
		<span class="n">Descriptor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ZeroDescriptor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">AsmInvvpid</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">Descriptor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>For INVVPID, there is a descriptor defined below.</p><p><img data-src="../../assets/images/INVVPID-descriptor-definition.png" alt="INVVPID Descriptor" data-proofer-ignore></p><p>This structure defined like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_INVVPID_DESCRIPTOR</span>
<span class="p">{</span>
	<span class="n">UINT64</span> <span class="n">VPID</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">UINT64</span> <span class="n">RESERVED</span> <span class="o">:</span> <span class="mi">48</span><span class="p">;</span>
	<span class="n">UINT64</span> <span class="n">LINEAR_ADDRESS</span><span class="p">;</span>

<span class="p">}</span> <span class="n">INVVPID_DESCRIPTOR</span><span class="p">,</span> <span class="o">*</span><span class="n">PINVVPID_DESCRIPTOR</span><span class="p">;</span>
</pre></table></code></div></div><p>The types of INVVPID is defined as below :</p><ul><li><strong>Individual-address invalidation:</strong> If the INVVPID type is 0, the logical processor invalidates mappings for the linear address, and VPID specified in the INVVPID descriptor. In some cases, it may invalidate mappings for other linear addresses (or other VPIDs) as well.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="nf">InvvpidIndividualAddress</span><span class="p">(</span><span class="n">UINT16</span> <span class="n">Vpid</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">LinearAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INVVPID_DESCRIPTOR</span> <span class="n">Descriptor</span> <span class="o">=</span> <span class="p">{</span> <span class="n">Vpid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LinearAddress</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">Invvpid</span><span class="p">(</span><span class="n">INDIVIDUAL_ADDRESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>Single-context invalidation:</strong> If the INVVPID type is 1, the logical processor invalidates all mappings tagged with the VPID specified in the INVVPID descriptor. In some cases, it may invalidate mappings for other VPIDs as well.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="nf">InvvpidSingleContext</span><span class="p">(</span><span class="n">UINT16</span> <span class="n">Vpid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INVVPID_DESCRIPTOR</span> <span class="n">Descriptor</span> <span class="o">=</span> <span class="p">{</span> <span class="n">Vpid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">Invvpid</span><span class="p">(</span><span class="n">SINGLE_CONTEXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>All-contexts invalidation:</strong> If the INVVPID type is 2, the logical processor invalidates all mappings tagged with all VPIDs except VPID 0000H. In some cases, it may invalidate translations with VPID 0000H as well.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="nf">InvvpidAllContexts</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">Invvpid</span><span class="p">(</span><span class="n">ALL_CONTEXT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>Single-context invalidation, retaining global translations:</strong> If the INVVPID type is 3, the logical processor invalidates all mappings tagged with the VPID specified in the INVVPID descriptor except global translations. In some cases, it may invalidate global translations (and mappings with other VPIDs) as well. See the “Caching Translation Information” section in Chapter 4 of the <em>IA-32 Intel Architecture Software Developer’s Manual, Volumes 3A</em> for information about global translations.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="nf">InvvpidSingleContextRetainingGlobals</span><span class="p">(</span><span class="n">UINT16</span> <span class="n">Vpid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INVVPID_DESCRIPTOR</span> <span class="n">Descriptor</span> <span class="o">=</span> <span class="p">{</span> <span class="n">Vpid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">Invvpid</span><span class="p">(</span><span class="n">SINGLE_CONTEXT_RETAINING_GLOBALS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Descriptor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You probably think about how VPIDs can be used in the hypervisor. We can use it instead of INVEPT, but generally, it doesn’t have any particular usage for us. I described it more in the <strong>Discussion</strong> Section. By the way, VPIDs will be used in implementing special features as it’s more flexible than INVEPT and also when we have multiple VMCS (EPTP). (Can you think about some of them?).</p><h2 id="important-notes-for-using-vpids"><span class="mr-2"><strong>Important Notes For Using VPIDs</strong></span><a href="#important-notes-for-using-vpids" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>There are some important things that you should know when using VPIDs.</p><p>Enabling VPIDs have a side-effect of not flushing TLB on VMEntry/VMExit. You should manually flush guest TLB entries if required (By using INVEPT/INVVPID). These issues might be hidden when VPID is disabled.</p><p>When VPID is disabled, VMEntry flushes the entire TLB. Thus, the hypervisor doesn’t need to explicitly invalidate TLB entries populated by the guest when performing an operation that should invalidate them (e.g., Modifying an EPT entry). When VPID is enabled, INVEPT/INVVPID should be used.</p><p>An easy way for you to find these kinds of issues is indeed the issue you have, is to execute INVEPT global-context before every VMEntry to flush entire TLB while still keeping VPID enabled. If it now works, you should check where you are missing an INVEPT execution.</p><p><strong>In my experience, if you just enable VPIDs without any extra assumption, all processes start to crash one by one, and eventually, kernel crashes, and this is because we didn’t invalidate the TLB.</strong></p><p>In order to solve the problem of crashing every process, we have to invalidate TLB in the case of Mov to Cr3 thus whenever a vm-exit occurs with reason == <strong>EXIT_REASON_CR_ACCESS (28)</strong> then if it’s a Mov to Cr3 we have to invalidate TLB (INVEPT or INVVPID [Look at the <strong>Update 1</strong> for more details]).</p><p>So we edit the code like this:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">TYPE_MOV_TO_CR</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">CrExitQualification</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
			<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
			<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">RegPtr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">)));</span>
			<span class="c1">// InveptSingleContext(EptState-&gt;EptPointer.Flags); (changed, look for "Update 1" at the 8th part for more detail)</span>
			<span class="n">InvvpidSingleContext</span><span class="p">(</span><span class="n">VPID_TAG</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
			<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
			<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">LogWarning</span><span class="p">(</span><span class="s">"Unsupported register %d in handling control registers access"</span><span class="p">,</span> <span class="n">CrExitQualification</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Also, note that as we have a single EPTP for all cores then it’s enough to invalidate single-context otherwise we have to invalidate all-contexts.</p><p><em><strong>Update 1 :</strong> As <a href="https://twitter.com/standa_t">Satoshi Tanda</a> mentioned,</em></p><p><em>The CR3 handler should use INVVPID instead of INVEPT because INVEPT invalidates more than needed. We want to invalid caches of GVA -&gt; HPA (combined mappings), and both instructions do this. This is why INVEPT works too, but INVEPT also invalidates caches of GPA -&gt; HPA (guest-physical mappings), which are not impacted by the guest CR3 change and can be kept without invalidation.</em></p><p><em>The general guideline is, INVVPID when TLB flush emulation is needed, and INVEPT when EPT entries are changed. You can find more info on those instructions and cache types in :</em></p><ul><li><em>28.3.1 Information That May Be Cached</em><li><em>28.3.3.3 Guidelines for Use of the INVVPID Instruction.</em></ul><p><em>so instead of <strong>InveptSingleContext</strong> we used <strong>InvvpidSingleContext</strong>.</em></p><p>Honestly, we have some misunderstanding about handling Cr3 vm-exits, even though the above code works fine, but generally, it has some performance penalties. I’ll explain these performance problems in the “<strong>Fixing Previous Design Issues</strong>” section.</p><p>You might also ask why we avoid writing the 63rd bit of the CR3.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>			<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">RegPtr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">)));</span>
</pre></table></code></div></div><p>Bit 63 of CR3 is a new bit that is part of the PCID feature. It allows OS to change CR3 value without invalidating all TLB entries (tagged with the same <strong>EP4TA</strong> and VPID) besides those marked with global-bit.</p><p><strong>EP4TA</strong> is the value of bits 51:12 of EPTP.</p><p>E.g. Windows KVA Shadowing and Linux KPTI signal this bit on CR3 mov that changes PCID between userspace PCID and kernel space PCID on user and kernel transitions.</p><p>We should not write on bit 63 of CR3 on mov reg, cr3 emulation because the processor does not write and attempt to write this will cause a crash on modern Win10. </p><h2 id="invvpid-vs-invpcid"><span class="mr-2"><strong>INVVPID vs. INVPCID</strong></span><a href="#invvpid-vs-invpcid" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>INVPCID is not really relevant to hypervisor but in the case, if you want to know, INVPCID invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on the process-context identifier (PCID).</p><p>So it’s like INVVPID with the difference that it’s not specific to the hypervisor. It also has its particular contexts (currently 3), you can read more <a href="https://www.felixcloutier.com/x86/invpcid">here</a> but generally keep in mind that to reduce that overhead, a feature called Process Context ID (PCID) was introduced by Intel’s Westmere architecture and related instruction, INVPCID (invalidate PCID) with Haswell. With PCID enabled, the way the TLB is used and flushed changes. First, the TLB tags each entry with the PCID of the process that owns the entry. This allows two different mappings from the same virtual address to be stored in the TLB as long as they have a different PCID. Second, with PCID enabled, switching from one set of page tables to another doesn’t flush the TLB any more. Since each process can only use TLB entries that have the right PCID, there’s no need to flush the TLB each time.</p><p>This behavior is used in Meltdown mitigation to avoid wiping out the entire TLB for the processors that support PCID.</p><h1 id="designing-a-vmx-root-mode-compatible-message-tracing"><strong>Designing A VMX Root-mode Compatible Message Tracing</strong></h1><p>Without any doubt, one of the hardest parts of designing a hypervisor is sending a message from Vmx root-mode to Vmx non-root mode. This is because you have lots of limitations like you can’t access non-paged buffer, and of course, most of the NT functions are not (ANY IRQL) compatible as they might access the buffers that reside in paged pool.</p><p>The things are ending here, there are plenty of other limitation to deal with.</p><p>This section is inspired by Chapter 6: Kernel Mechanisms (High IRQL Synchronization) from the Windows Kernel Programming book by Pavel Yosifovich which is a really amazing book if you want to start with kernel programming.</p><h2 id="concepts"><span class="mr-2"><strong>Concepts</strong></span><a href="#concepts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>This section describes some of the Operating System concepts, you should know before starting.</p><h2 id="whats-a-spinlock"><span class="mr-2"><strong>What’s a spinlock?</strong></span><a href="#whats-a-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The Spin Lock is a bit in memory that provides atomic test and modify operations. When a CPU tries to acquire a spinlock, and it’s not currently free, the CPU keeps spinning on the spinlock, busy waiting for it to be released by another CPU means that it keeps checking until another thread which acquired it first release it.</p><h2 id="test-and-set"><span class="mr-2"><strong>Test-and-Set</strong></span><a href="#test-and-set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>You probably read about Test and Set in university. Still, in case you didn’t, in computer science, the test-and-set instruction is an instruction used to write 1 (set) to a memory location and return its old value as a single atomic (i.e., non-interruptible) operation. If multiple processes may access the same memory location, and if a process is currently performing a test-and-set, no other process may begin another test-and-set until the first process’s test-and-set is finished.</p><h2 id="what-do-we-mean-by-safe"><span class="mr-2"><strong>What do we mean by “Safe”?</strong></span><a href="#what-do-we-mean-by-safe" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The “safe” is used a lot in hypervisors. By “safe,” we mean something that works all the time and won’t cause system crash or system halt. It’s because it’s so tricky to manage codes in vmx root-mode. After all, interrupts are masked (disabled), or transfer buffer from vmx root-mode to vmx non-root mode needs extra effort, and we should be cautious and avoid executing some APIs to be safe.</p><h2 id="what-is-dpc"><span class="mr-2"><strong>What is DPC?</strong></span><a href="#what-is-dpc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>A <strong>Deferred Procedure Call</strong> (<strong>DPC</strong>) is a Windows mechanism that allows high-priority tasks (e.g., an interrupt handler) to defer required but lower-priority tasks for later execution. This permits device drivers and other low-level event consumers to perform the high-priority part of their processing quickly and schedule non-critical additional processing for execution at a lower priority.</p><p>DPCs are implemented by DPC objects which are created and initialized by the kernel when a device driver or some other kernel-mode program issues requests for DPC. The DPC request is then added to the end of a DPC queue. Each processor has a separate DPC queue. DPCs have three priority levels: low, medium, and high. By default, all DPCs are set to medium priority. When Windows drops to an IRQL of Dispatch/DPC level, it checks the DPC queue for any pending DPCs and executes them until the queue is empty or some other interrupt with a higher IRQL occurs.</p><p>This is the description of DPCs from MSDN:</p><p><em>Because ISRs must execute as quickly as possible, drivers must usually postpone the completion of servicing an interrupt until after the ISR returns. Therefore, the system provides support for deferred procedure calls (DPCs), which can be queued from ISRs and which are executed at a later time and at a lower IRQL than the ISR.</em></p><p>There are two posts about DPCs <a href="https://repnz.github.io/posts/practical-reverse-engineering/reversing-dpc-keinsertqueuedpc/">here</a> and <a href="https://repnz.github.io/posts/practical-reverse-engineering/dumping-dpc-queues/">here</a>, you can read them for more information.</p><h2 id="challenges"><span class="mr-2"><strong>Challenges</strong></span><a href="#challenges" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For example, Vmx-root mode is not a HIGH_IRQL interrupt (with discussing it in <strong>Discussion</strong> Section), but as it disables all of the interrupts, we can think like it’s a HIGH_IRQL state. The problem is that must of synchronization functions are designed to be worked on IRQL less than DISPATCH_LEVEL.</p><p>Why is it problematic? Imagine you have a one-core processor, and your function requires a spinlock (let say it’s merely a buffer that needs to be accessed). The function raises the IRQL to <strong>DISPATCH_LEVEL</strong>. Now the Windows Scheduler can’t interrupt the function until it releases the spinlock and lowers the IRQL to <strong>PASSIVE_LEVEL</strong> or <strong>APC_LEVEL</strong>. During the execution of the function, a vm-exit occurs; thus, we’re in vmx root-mode now. It’s because, as I told you, vm-exit happens as if it’s a HIGH_IRQL interrupt.</p><p>Now, what if we want to access that buffer in vmx root mode? Two scenarios might occur.</p><ul><li>We wait on a spinlock that was previously acquired by a thread in vmx non-root mode and this we have to wait forever. A deadlock occurs.<li>We enter the function without looking at the lock (while there is another thread that enters the function at the same time.) so it results in a corrupted buffer and invalid data.</ul><p>The other limitation is in Windows design putting the thread into a waiting state cannot be done at IRQL <strong>DISPATCH_LEVEL</strong> or higher. It’s because in Windows when you acquire a spinlock it raises the IRQL to 2 – <strong>DISPATCH_LEVEL</strong> (if not already there), acquire the spinlock, perform the work and finally release the spinlock and lower IRQL back.</p><p>If you look at a function like <strong>KeAcquireSpinLock</strong> and <strong>KeReleaseSpinLock</strong>, they get an IRQL in their arguments. First, <strong>KeAcquireSpinLock</strong> saves current IRQL to the parameter supplied by the user then raises the IRQL to <strong>DISPATCH_LEVEL</strong> and sets a bit. When the function finished its works with shared data, then it calls <strong>KeReleaseSpinLock</strong> and passes that old IRQL parameter so this function unsets the bit and restore the old IRQL (lowers the IRQL).</p><p>Windows has 4 kinds of Spinlocks,</p><ol><li>KeAcquireSpinLock – KeReleaseSpinLock : This pair can be called at IRQL &lt;= DISPATCH_LEVEL.<li>KeAcquireSpinLockAtDpcLevel – KeReleaseSpinLockFromDpcLevel : This pair can be call at IRQL = DISPATCH_LEVEL only, it’s more optimized if you are already in IRQL 2 as it doesn’t saves the old IRQL and it’s specially designed to work on DPC routine.<li>KeAcquireInterruptSpinLock – KeReleaseInterruptSpinLock: Hardware based use this pair e.g in Interrupt Service Routine (ISR) or it used by drivers with an interrupt source.<li>ExInterlockedXxx : This function raises the IRQL to HIGH_LEVEL and perform it’s task, it doesn’t need a release function as no one interrupt us on HIGH_IRQL.</ol><p>But unfortunately, things are more complicated when it comes to vmx root-mode. We don’t have IRQL in the vmx root-mode. It’s an operating system thing, so we can’t use any of the above functions, and things are getting worst if we want to use our message tracing mechanism between multiple cores!</p><p>For these reasons, we have to design our custom spinlock.</p><h2 id="designing-a-spinlock"><span class="mr-2"><strong>Designing A Spinlock</strong></span><a href="#designing-a-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Designing spinlock in a multi-core system by its nature needs the hardware support for atomic operation means that hardware (most of the time processor) should guarantee that an operation is performed just by logical (hyper-threaded) core and it’s non-interruptible.</p><p>There is an article <a href="https://locklessinc.com/articles/locks/">here</a> that describes different kinds of spinlock with different optimizations, also it’s implemented <a href="https://github.com/cyfdecyf/spinlock">here</a>.</p><p>The design of this mechanism in the processor is beyond the scope of this article. We simply use an intrinsic function provided by Windows called “<strong><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/interlockedbittestandset-intrinsic-functions?view=vs-2019">_interlockedbittestandset</a></strong>”.</p><p>This makes our implementation super simple. We just need to use the following function, and it’s the responsibility of the processor to take care of everything.</p><p><strong>Update 2:</strong> We should use volatile keyword in parameters too, otherwise it’s like un-volatiling.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="n">BOOLEAN</span> <span class="nf">SpinlockTryLock</span><span class="p">(</span><span class="k">volatile</span> <span class="n">LONG</span><span class="o">*</span> <span class="n">Lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">Lock</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_interlockedbittestandset</span><span class="p">(</span><span class="n">Lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now we need to spin! If the above function was not successful, then we have to keep CPU checking to see when another processor releases the lock.</p><p><strong>Update 2:</strong> We should use volatile keyword in parameters too, otherwise it’s like un-volatiling.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">SpinlockLock</span><span class="p">(</span><span class="k">volatile</span> <span class="n">LONG</span><span class="o">*</span> <span class="n">Lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SpinlockTryLock</span><span class="p">(</span><span class="n">Lock</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wait</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">_mm_pause</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="c1">// Don't call "pause" too many times. If the wait becomes too big,</span>
		<span class="c1">// clamp it to the max_wait.</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">max_wait</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">wait</span> <span class="o">=</span> <span class="n">max_wait</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">wait</span> <span class="o">=</span> <span class="n">wait</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If you wonder what is the <strong>_mm_pause()</strong> then it’s equal to <strong>PAUSE</strong> instruction in x86.</p><p>Pause instruction is commonly used in the loop of testing spinlock, when some other thread owns the spinlock, to mitigate the tight loop.</p><p><a href="http://felixcloutier.com/x86/PAUSE.html">PAUSE</a> notifies the CPU that this is a spinlock wait loop, so memory and cache accesses may be optimized. See also <a href="https://stackoverflow.com/questions/12894078/pause-instruction-in-x86">pause instruction in x86</a> for some more details about avoiding the memory-order mis-speculation when leaving the spin-loop. PAUSE may stop CPU for some time to save power. Older CPUs decode it as REP NOP, so you don’t have to check if it’s supported. Older CPUs will simply do nothing (NOP) as fast as possible.</p><p>For releasing the lock, there is nothing special to do, so simply unset it without caring for any other processor as there is no other processor that wants to unset it.</p><p><strong>Update 2:</strong> We should use volatile keyword in parameters too, otherwise it’s like un-volatiling.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">SpinlockUnlock</span><span class="p">(</span><span class="k">volatile</span> <span class="n">LONG</span><span class="o">*</span> <span class="n">Lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">Lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The last step is to use a volatile variable as the lock.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// Vmx-root lock for logging</span>
<span class="k">volatile</span> <span class="n">LONG</span> <span class="n">VmxRootLoggingLock</span><span class="p">;</span>
</pre></table></code></div></div><p>The “<strong>volatile</strong>” keyword tells the compiler that the value of the variable may change at any time without any action being taken by the code the compiler finds nearby. The implications of this are quite serious. There are lots of examples here if you have a problem with understanding “<strong>volatile</strong>”.</p><h2 id="message-tracer-design"><span class="mr-2"><strong>Message Tracer Design</strong></span><a href="#message-tracer-design" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For solving the above the challenge about deadlock, I create two message pools for saving messages. The first pool is designed to be used as storage for vmx non-root messages (buffers) and the second pool is used for vmx-root messages.</p><p>We have the following structure that describes the state of each of these two pools.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Core-specific buffers</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_LOG_BUFFER_INFORMATION</span> <span class="p">{</span>

	<span class="n">UINT64</span> <span class="n">BufferStartAddress</span><span class="p">;</span>						<span class="c1">// Start address of the buffer</span>
	<span class="n">UINT64</span> <span class="n">BufferEndAddress</span><span class="p">;</span>						<span class="c1">// End address of the buffer</span>

	<span class="n">UINT64</span> <span class="n">BufferForMultipleNonImmediateMessage</span><span class="p">;</span>	<span class="c1">// Start address of the buffer for accumulating non-immadiate messages</span>
	<span class="n">UINT32</span> <span class="n">CurrentLengthOfNonImmBuffer</span><span class="p">;</span>				<span class="c1">// the current size of the buffer for accumulating non-immadiate messages</span>


	<span class="n">KSPIN_LOCK</span> <span class="n">BufferLock</span><span class="p">;</span>							<span class="c1">// SpinLock to protect access to the queue</span>
	<span class="n">KSPIN_LOCK</span> <span class="n">BufferLockForNonImmMessage</span><span class="p">;</span>			<span class="c1">// SpinLock to protect access to the queue of non-imm messages</span>

	<span class="n">UINT32</span> <span class="n">CurrentIndexToSend</span><span class="p">;</span>						<span class="c1">// Current buffer index to send to user-mode</span>
	<span class="n">UINT32</span> <span class="n">CurrentIndexToWrite</span><span class="p">;</span>						<span class="c1">// Current buffer index to write new messages</span>

<span class="p">}</span> <span class="n">LOG_BUFFER_INFORMATION</span><span class="p">,</span> <span class="o">*</span> <span class="n">PLOG_BUFFER_INFORMATION</span><span class="p">;</span>
</pre></table></code></div></div><p>Generally, we’ll save the buffer as illustrated below, each chunk of the message came with <strong>BUFFER_HEADER</strong> that describes that chunk.</p><p>Other information for the buffer like <strong>Current Index to Write</strong> and <strong>Current to Send</strong> is saved in the above structure.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="n">A</span> <span class="n">core</span> <span class="n">buffer</span> <span class="n">is</span> <span class="n">like</span> <span class="n">this</span> <span class="p">,</span> <span class="n">it</span><span class="err">'</span><span class="n">s</span> <span class="n">divided</span> <span class="n">into</span> <span class="n">MaximumPacketsCapacity</span> <span class="n">chucks</span><span class="p">,</span>
<span class="n">each</span> <span class="n">chunk</span> <span class="n">has</span> <span class="n">PacketChunkSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">)</span> <span class="n">size</span>

			 <span class="n">__________________________</span>
			<span class="o">|</span>      <span class="n">BUFFER_HEADER</span>      <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>           <span class="n">BODY</span>          <span class="o">|</span>
			<span class="o">|</span>         <span class="p">(</span><span class="n">Buffer</span><span class="p">)</span>        <span class="o">|</span>
			<span class="o">|</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PacketChunkSize</span>  <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
			<span class="o">|</span>      <span class="n">BUFFER_HEADER</span>      <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>           <span class="n">BODY</span>          <span class="o">|</span>
			<span class="o">|</span>         <span class="p">(</span><span class="n">Buffer</span><span class="p">)</span>        <span class="o">|</span>
			<span class="o">|</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PacketChunkSize</span>  <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>           <span class="p">.</span>             <span class="o">|</span>
			<span class="o">|</span>           <span class="p">.</span>             <span class="o">|</span>
			<span class="o">|</span>           <span class="p">.</span>             <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
			<span class="o">|</span>      <span class="n">BUFFER_HEADER</span>      <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span>           <span class="n">BODY</span>          <span class="o">|</span>
			<span class="o">|</span>         <span class="p">(</span><span class="n">Buffer</span><span class="p">)</span>        <span class="o">|</span>
			<span class="o">|</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PacketChunkSize</span>  <span class="o">|</span>
			<span class="o">|</span>                         <span class="o">|</span>
			<span class="o">|</span><span class="n">_________________________</span><span class="o">|</span>
</pre></table></code></div></div><p>The BUFFER_HEADER is defined like this,</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Message buffer structure</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_BUFFER_HEADER</span> <span class="p">{</span>
	<span class="n">UINT32</span> <span class="n">OpeationNumber</span><span class="p">;</span>	<span class="c1">// Operation ID to user-mode</span>
	<span class="n">UINT32</span> <span class="n">BufferLength</span><span class="p">;</span>	<span class="c1">// The actual length</span>
	<span class="n">BOOLEAN</span> <span class="n">Valid</span><span class="p">;</span>			<span class="c1">// Determine whether the buffer was valid to send or not</span>
<span class="p">}</span> <span class="n">BUFFER_HEADER</span><span class="p">,</span> <span class="o">*</span> <span class="n">PBUFFER_HEADER</span><span class="p">;</span>
</pre></table></code></div></div><p>We save the length of used length of the chunk and a bit which determine whether we sent it before or not.</p><p>Operation Number is number, which will be sent to the user-mode to show the type of the buffer that came from the kernel. In other words, it’s a number that indicates the intention (and structure) of the buffer, so the user-mode application will know what to do with this buffer.</p><p>The following Operation Numbers are currently defined :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Message area &gt;= 0x4</span>
<span class="cp">#define OPERATION_LOG_INFO_MESSAGE							0x1
#define OPERATION_LOG_WARNING_MESSAGE						0x2
#define OPERATION_LOG_ERROR_MESSAGE							0x3
#define OPERATION_LOG_NON_IMMEDIATE_MESSAGE					0x4
</span></pre></table></code></div></div><p>Each of them shows a different type of message, and the last one shows that a bunch buffer is accumulated in this buffer. This message tracing is designed to send any kind of the buffer from both vmx root and OS to the user-mode, so it’s not limited just to sending messages, we can send buffers with custom structures and different Operation Numbers.</p><p>The last thing about our message tracing is, it can be configured with the following constants, you can change them in order to have a better performance for your exclusive use.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Default buffer size</span>
<span class="cp">#define MaximumPacketsCapacity 1000 // number of packets
#define PacketChunkSize		1000 // NOTE : REMEMBER TO CHANGE IT IN USER-MODE APP TOO
#define UsermodeBufferSize  sizeof(UINT32) + PacketChunkSize + 1 </span><span class="cm">/* Becausee of Opeation code at the start of the buffer + 1 for null-termminating */</span><span class="cp">
#define LogBufferSize MaximumPacketsCapacity * (PacketChunkSize + sizeof(BUFFER_HEADER))
</span></pre></table></code></div></div><p>You can configure things like the maximum number of chunks in a buffer and also the size of each chunk. Setting the above variables is necessary in some cases if there is no thread to consume (read) these chunks and pools are full; it replaces the previous unread buffer. Hence, if you can’t frequently consume the pools, then it’s better to specify a higher number for <strong>MaximumPacketsCapacity</strong> so that you won’t lose anything.</p><h2 id="initialization-phase"><span class="mr-2"><strong>Initialization Phase</strong></span><a href="#initialization-phase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In the initialization phase, we allocate space for the above structure (2 times, one for vmx non-root and one for vmx-root) and then allocate the buffers to be used as the storage for saving our messages.</p><p>We have to zero them all and also <strong>KeInitializeSpinLock</strong> to initialize the spinlock. We use this spinlock only for vmx non-root, and this function makes sure that the value for the lock is unset. We do the same for our custom spinlock (<strong>VmxRootLoggingLock</strong>), just unset it.</p><p>You might ask, what is the “<strong>BufferLockForNonImmMessage</strong>”, it’s another lock that will use it as optimization (see later).</p><p>All in all, we have the following code.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cm">/* Initialize the buffer relating to log message tracing */</span>
<span class="n">BOOLEAN</span> <span class="nf">LogInitialize</span><span class="p">()</span> <span class="p">{</span>


	<span class="c1">// Initialize buffers for trace message and data messages (wee have two buffers one for vmx root and one for vmx non-root)</span>
	<span class="n">MessageBufferInformation</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LOG_BUFFER_INFORMATION</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MessageBufferInformation</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">//STATUS_INSUFFICIENT_RESOURCES</span>
	<span class="p">}</span>

	<span class="c1">// Zeroing the memory</span>
	<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LOG_BUFFER_INFORMATION</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="c1">// Initialize the lock for Vmx-root mode (HIGH_IRQL Spinlock)</span>
	<span class="n">VmxRootLoggingLock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Allocate buffer for messages and initialize the core buffer information </span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="c1">// initialize the lock</span>
		<span class="c1">// Actually, only the 0th buffer use this spinlock but let initialize it for both but the second buffer spinlock is useless </span>
		<span class="c1">// as we use our custom spinlock.</span>
		<span class="n">KeInitializeSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferLock</span><span class="p">);</span>
		<span class="n">KeInitializeSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferLockForNonImmMessage</span><span class="p">);</span>

		<span class="c1">// allocate the buffer</span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="n">LogBufferSize</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferForMultipleNonImmediateMessage</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="n">PacketChunkSize</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferStartAddress</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// STATUS_INSUFFICIENT_RESOURCES</span>
		<span class="p">}</span>

		<span class="c1">// Zeroing the buffer</span>
		<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferStartAddress</span><span class="p">,</span> <span class="n">LogBufferSize</span><span class="p">);</span>

		<span class="c1">// Set the end address</span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferEndAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">UINT64</span><span class="p">)</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">+</span> <span class="n">LogBufferSize</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="sending-phase-saving-buffer-and-adding-them-to-pools"><span class="mr-2"><strong>Sending Phase (Saving Buffer and adding them to pools)</strong></span><a href="#sending-phase-saving-buffer-and-adding-them-to-pools" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In a regular Windows routine generally, we shouldn’t be on IRQL more than Dispatch Level. There is no case that our log manager needs to be used in higher IRQLs, so we don’t care about them; thus, we have two different approaches here. First, we acquire the lock (spinlock) using <strong>KeAcquireSpinLock</strong> in vmx non-root as it’s a Windows optimized way to acquire a lock and for vmx-root mode, we acquire the lock using our previously designed spinlock.</p><p>As I told you above, we want to fix this problem that might a vmx-exit occurs when we acquired a lock, so it’s not possible to use the same spinlock as deadlock might happen.</p><p>Now we have to see whether we are operating from vmx non-root or vmx root, based on this condition, we select our lock and the index of the buffer that we want to put our message into it.</p><p>I’m not gonna explain each step, as it’s easy, it’s just managing buffer and copying data from a buffer to another buffer and also the code is well commented so you can read the code, instead, I explain tricky parts of our message tracing.</p><p>After creating a header for our new message buffer, we will copy the bytes and change the information about buffer’s indexes. The last step here is to see whether any thread is waiting to receive our message or not.</p><p>If there is no thread waiting for our message then nothing more to do here but if there is a thread which is IRP Pending state (I explain about it later), then we use <strong>KeInsertQueueDpc</strong> so that it will be added to our DPC Queue which will be subsequently executed by Windows in IRQL == <strong>DISPATCH_LEVEL</strong>.</p><p>It means that our callback function will execute by Windows later and of course, Windows execute our function in vmx non-root so it’s safe. I’ll describe this callback and how we create a DPC later.</p><p>Finally, we have to release the locks so that other threads can enter.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="cm">/* Save buffer to the pool */</span>
<span class="n">BOOLEAN</span> <span class="nf">LogSendBuffer</span><span class="p">(</span><span class="n">UINT32</span> <span class="n">OperationCode</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">UINT32</span> <span class="n">BufferLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">KIRQL</span> <span class="n">OldIRQL</span><span class="p">;</span>
	<span class="n">UINT32</span> <span class="n">Index</span><span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">IsVmxRoot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BufferLength</span> <span class="o">&gt;</span> <span class="n">PacketChunkSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">BufferLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// We can't save this huge buffer</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Check that if we're in vmx root-mode</span>
	<span class="n">IsVmxRoot</span> <span class="o">=</span> <span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IsOnVmxRootMode</span><span class="p">;</span>

	<span class="c1">// Check if we're in Vmx-root, if it is then we use our customized HIGH_IRQL Spinlock, if not we use the windows spinlock</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRoot</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Set the index</span>
		<span class="n">Index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">SpinlockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VmxRootLoggingLock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Set the index</span>
		<span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="c1">// Acquire the lock </span>
		<span class="n">KeAcquireSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferLock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OldIRQL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// check if the buffer is filled to it's maximum index or not</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToWrite</span> <span class="o">&gt;</span> <span class="n">MaximumPacketsCapacity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// start from the begining</span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Compute the start of the buffer header</span>
	<span class="n">BUFFER_HEADER</span><span class="o">*</span> <span class="n">Header</span> <span class="o">=</span> <span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="o">*</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToWrite</span> <span class="o">*</span> <span class="p">(</span><span class="n">PacketChunkSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">))));</span>

	<span class="c1">// Set the header</span>
	<span class="n">Header</span><span class="o">-&gt;</span><span class="n">OpeationNumber</span> <span class="o">=</span> <span class="n">OperationCode</span><span class="p">;</span>
	<span class="n">Header</span><span class="o">-&gt;</span><span class="n">BufferLength</span> <span class="o">=</span> <span class="n">BufferLength</span><span class="p">;</span>
	<span class="n">Header</span><span class="o">-&gt;</span><span class="n">Valid</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="cm">/* Now it's time to fill the buffer */</span>

	<span class="c1">// compute the saving index</span>
	<span class="n">PVOID</span> <span class="n">SavingBuffer</span> <span class="o">=</span> <span class="p">((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToWrite</span> <span class="o">*</span> <span class="p">(</span><span class="n">PacketChunkSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">)))</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">));</span>

	<span class="c1">// Copy the buffer</span>
	<span class="n">RtlCopyBytes</span><span class="p">(</span><span class="n">SavingBuffer</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">BufferLength</span><span class="p">);</span>

	<span class="c1">// Increment the next index to write</span>
	<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToWrite</span> <span class="o">=</span> <span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToWrite</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// check if there is any thread in IRP Pending state, so we can complete their request</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GlobalNotifyRecord</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* there is some threads that needs to be completed */</span>
		<span class="c1">// set the target pool</span>
		<span class="n">GlobalNotifyRecord</span><span class="o">-&gt;</span><span class="n">CheckVmxRootMessagePool</span> <span class="o">=</span> <span class="n">IsVmxRoot</span><span class="p">;</span>
		<span class="c1">// Insert dpc to queue</span>
		<span class="n">KeInsertQueueDpc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalNotifyRecord</span><span class="o">-&gt;</span><span class="n">Dpc</span><span class="p">,</span> <span class="n">GlobalNotifyRecord</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="c1">// set notify routine to null</span>
		<span class="n">GlobalNotifyRecord</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Check if we're in Vmx-root, if it is then we use our customized HIGH_IRQL Spinlock, if not we use the windows spinlock</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRoot</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">SpinlockUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VmxRootLoggingLock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Release the lock</span>
		<span class="n">KeReleaseSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferLock</span><span class="p">,</span> <span class="n">OldIRQL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="reading-phase-read-buffers-and-send-them-to-user-mode"><span class="mr-2"><strong>Reading Phase (Read buffers and send them to user-mode)</strong></span><a href="#reading-phase-read-buffers-and-send-them-to-user-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>It’s time to read the previously filled buffer! The fact that we add a DPC in the previous function “<strong>LogSendBuffer</strong>” shows that the “<strong>LogReadBuffer</strong>” is executed in vmx non-root mode so we can freely use most of the APIs (not all of them).</p><p>Theoretically, we have a problem here, if we want to read a buffer from the vmx root-mode pool, then it might cause a deadlock as we acquired a vmx root-mode lock and might a vm-exit occur. Hence, we spin on this lock in vmx root mode forever, but practically there is no deadlock here. Can you guess why?</p><p>It’s because our <strong>LogReadBuffer</strong> executes in <strong>DISPATCH_LEVEL</strong> so the Windows scheduler won’t interrupt us, and our function is executed without any interruption and the fact that we’re not doing anything fancy here. I mean, we’re not performing anything (like CPUID) that causes a vm-exit in our code, so practically there is nothing to cause deadlock here, but we should keep in mind that we’re not allowed to run codes that cause vmx-exit.</p><p>We compute the header address based on previous information and also set the valid bit to zero so that it shows that this buffer is previously used.</p><p>Then we copy the buffer to the buffer that specified in arguments also put the Operation Number on the top of the target buffer so that the future functions will know about the intention of this buffer. We can also use DbgPrint to show the messages to the kernel debugger. Using <strong>DbgPrint</strong> in <strong>DISPATCH_LEVEL</strong> (vmx non-root mode) is safe. We might need to use DbgPrint multiple times as this function has a maximum of 512 bytes by default. Even though you can change the limit number but we assume the default size is selected.</p><p>Finally, we have to reset some of the information regarding buffer, clear the buffer messages (it’s not necessary to zero the buffer, but for making debug process easier, I prefer to zero the buffer), and release the locks.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
</pre><td class="rouge-code"><pre><span class="cm">/* return of this function shows whether the read was successfull or not (e.g FALSE shows there's no new buffer available.)*/</span>
<span class="n">BOOLEAN</span> <span class="nf">LogReadBuffer</span><span class="p">(</span><span class="n">BOOLEAN</span> <span class="n">IsVmxRoot</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">BufferToSaveMessage</span><span class="p">,</span> <span class="n">UINT32</span><span class="o">*</span> <span class="n">ReturnedLength</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">KIRQL</span> <span class="n">OldIRQL</span><span class="p">;</span>
	<span class="n">UINT32</span> <span class="n">Index</span><span class="p">;</span>

	<span class="c1">// Check if we're in Vmx-root, if it is then we use our customized HIGH_IRQL Spinlock, if not we use the windows spinlock</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRoot</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Set the index</span>
		<span class="n">Index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// Acquire the lock </span>
		<span class="n">SpinlockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VmxRootLoggingLock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Set the index</span>
		<span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">// Acquire the lock </span>
		<span class="n">KeAcquireSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferLock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OldIRQL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// Compute the current buffer to read</span>
	<span class="n">BUFFER_HEADER</span><span class="o">*</span> <span class="n">Header</span> <span class="o">=</span> <span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="o">*</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">*</span> <span class="p">(</span><span class="n">PacketChunkSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">))));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// there is nothing to send</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we reached here, means that there is sth to send  */</span>
	<span class="c1">// First copy the header </span>
	<span class="n">RtlCopyBytes</span><span class="p">(</span><span class="n">BufferToSaveMessage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">OpeationNumber</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span>


	<span class="c1">// Second, save the buffer contents</span>
	<span class="n">PVOID</span> <span class="n">SendingBuffer</span> <span class="o">=</span> <span class="p">((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">*</span> <span class="p">(</span><span class="n">PacketChunkSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">)))</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">));</span>
	<span class="n">PVOID</span> <span class="n">SavingAddress</span> <span class="o">=</span> <span class="p">((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">BufferToSaveMessage</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span> <span class="c1">// Because we want to pass the header of usermode header</span>
	<span class="n">RtlCopyBytes</span><span class="p">(</span><span class="n">SavingAddress</span><span class="p">,</span> <span class="n">SendingBuffer</span><span class="p">,</span> <span class="n">Header</span><span class="o">-&gt;</span><span class="n">BufferLength</span><span class="p">);</span>


<span class="cp">#if ShowMessagesOnDebugger
</span>
	<span class="c1">// Means that show just messages</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">OpeationNumber</span> <span class="o">&lt;=</span> <span class="n">OPERATION_LOG_NON_IMMEDIATE_MESSAGE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* We're in Dpc level here so it's safe to use DbgPrint*/</span>
		<span class="c1">// DbgPrint limitation is 512 Byte</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">BufferLength</span> <span class="o">&gt;</span> <span class="n">DbgPrintLimitation</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Header</span><span class="o">-&gt;</span><span class="n">BufferLength</span> <span class="o">/</span> <span class="n">DbgPrintLimitation</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">DbgPrint</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">SendingBuffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">DbgPrintLimitation</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="k">else</span>
				<span class="p">{</span>
					<span class="n">DbgPrint</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">SendingBuffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">DbgPrintLimitation</span> <span class="o">*</span> <span class="n">i</span><span class="p">)));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">DbgPrint</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">SendingBuffer</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="cp">#endif
</span>
	<span class="c1">// Finally, set the current index to invalid as we sent it</span>
	<span class="n">Header</span><span class="o">-&gt;</span><span class="n">Valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="c1">// Set the length to show as the ReturnedByted in usermode ioctl funtion + size of header</span>
	<span class="o">*</span><span class="n">ReturnedLength</span> <span class="o">=</span> <span class="n">Header</span><span class="o">-&gt;</span><span class="n">BufferLength</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">);</span>


	<span class="c1">// Last step is to clear the current buffer (we can't do it once when CurrentIndexToSend is zero because</span>
	<span class="c1">// there might be multiple messages on the start of the queue that didn't read yet)</span>
	<span class="c1">// we don't free the header</span>
	<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">SendingBuffer</span><span class="p">,</span> <span class="n">Header</span><span class="o">-&gt;</span><span class="n">BufferLength</span><span class="p">);</span>

	<span class="c1">// Check to see whether we passed the index or not</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">&gt;</span> <span class="n">MaximumPacketsCapacity</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Increment the next index to read</span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">=</span> <span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Check if we're in Vmx-root, if it is then we use our customized HIGH_IRQL Spinlock, if not we use the windows spinlock</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRoot</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">SpinlockUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VmxRootLoggingLock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Release the lock</span>
		<span class="n">KeReleaseSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferLock</span><span class="p">,</span> <span class="n">OldIRQL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="checking-for-new-messages"><span class="mr-2"><strong>Checking for new messages</strong></span><a href="#checking-for-new-messages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Checking for the new message is simple; we just need to check the current message index based on previous information and see if its header is valid or not. If it’s valid then it shows that we have a new message, but if it’s not valid, then some function reads the message previously, and there is no new message.</p><p>For checking the new message, we even don’t need to acquire a lock because basically we don’t write anything and in our case reading doesn’t need a lock.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cm">/* return of this function shows whether the read was successfull or not (e.g FALSE shows there's no new buffer available.)*/</span>
<span class="n">BOOLEAN</span> <span class="nf">LogCheckForNewMessage</span><span class="p">(</span><span class="n">BOOLEAN</span> <span class="n">IsVmxRoot</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">KIRQL</span> <span class="n">OldIRQL</span><span class="p">;</span>
	<span class="n">UINT32</span> <span class="n">Index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRoot</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// Compute the current buffer to read</span>
	<span class="n">BUFFER_HEADER</span><span class="o">*</span> <span class="n">Header</span> <span class="o">=</span> <span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="o">*</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferStartAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentIndexToSend</span> <span class="o">*</span> <span class="p">(</span><span class="n">PacketChunkSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_HEADER</span><span class="p">))));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// there is nothing to send</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we reached here, means that there is sth to send  */</span>
	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="sending-messages-to-pools"><span class="mr-2"><strong>Sending messages to pools</strong></span><a href="#sending-messages-to-pools" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Previously, we see how to save (send) buffers and read them. Each message is a buffer of strings, so finally, we have to use “<strong>LogSendBuffer</strong>” to send our buffer, but we need to consider extra effort to send a well-formed message.</p><p><strong>va_start</strong> and <strong>va_end</strong> are used to support multiple arguments to one function, e.g like <strong>DbgPrint</strong> or <strong>printf</strong>.</p><p>You can use a combination of <strong>KeQuerySystemTime</strong>, <strong>ExSystemTimeToLocalTime,</strong> and <strong>RtlTimeToTimeFields</strong> to get the current system time (see the example) then putting them together with <strong>sprintf_s</strong>.</p><p>There is a particular reason why we use the sprintf-like function instead of <strong>RtlString*</strong> functions; the reason is described in the <strong>Discussion</strong> section. The next step is computing length using <strong>strnlen_s</strong>.</p><p>Finally, we have a vital optimization here; logically we create two kinds of messages, one called “Immediate Message” which we will directly send it into the pool and another type is “Non-Immediate Message” which we gather the messages in another buffer and append new messages in that buffer until its capacity is full (we shouldn’t pass the <strong>PacketChunkSize</strong> limit).</p><p>Using this way, we don’t send each message to the user-mode separately but instead, we send multiple messages in one buffer to the user-mode. We will gain visible performance improvement. For example with a configuration with <strong>PacketChunkSize == 1000 bytes</strong> we send 6 messages on a buffer (it’s average basically it depends on each message size) because you probably know that CPU has to do a lot to change its state from kernel-mode to user-mode and also creating new IRP Packet is a heavy task.</p><p>You can also change the configuration, e.g., increase the <strong>PacketChunkSize</strong> so that more messages will hold on the temporary buffer, but generally, it delays the time you see the message.</p><p>Also, we work on a buffer so we need another spinlock here.</p><p>Putting it all together we have the following code :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
</pre><td class="rouge-code"><pre><span class="c1">// Send string messages and tracing for logging and monitoring</span>
<span class="n">BOOLEAN</span> <span class="nf">LogSendMessageToQueue</span><span class="p">(</span><span class="n">UINT32</span> <span class="n">OperationCode</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">IsImmediateMessage</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">ShowCurrentSystemTime</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="n">BOOLEAN</span> <span class="n">Result</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">ArgList</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">WrittenSize</span><span class="p">;</span>
	<span class="n">UINT32</span> <span class="n">Index</span><span class="p">;</span>
	<span class="n">KIRQL</span> <span class="n">OldIRQL</span><span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">IsVmxRootMode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">SprintfResult</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">LogMessage</span><span class="p">[</span><span class="n">PacketChunkSize</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">TempMessage</span><span class="p">[</span><span class="n">PacketChunkSize</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">TimeBuffer</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="c1">// Set Vmx State</span>
	<span class="n">IsVmxRootMode</span> <span class="o">=</span> <span class="n">GuestState</span><span class="p">[</span><span class="n">KeGetCurrentProcessorNumber</span><span class="p">()].</span><span class="n">IsOnVmxRootMode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ShowCurrentSystemTime</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// It's actually not necessary to use -1 but because user-mode code might assume a null-terminated buffer so</span>
		<span class="c1">// it's better to use - 1</span>
		<span class="n">va_start</span><span class="p">(</span><span class="n">ArgList</span><span class="p">,</span> <span class="n">Fmt</span><span class="p">);</span>
		<span class="c1">// We won't use this because we can't use in any IRQL</span>
		<span class="cm">/*Status = RtlStringCchVPrintfA(TempMessage, PacketChunkSize - 1, Fmt, ArgList);*/</span>
		<span class="n">SprintfResult</span> <span class="o">=</span> <span class="n">vsprintf_s</span><span class="p">(</span><span class="n">TempMessage</span><span class="p">,</span> <span class="n">PacketChunkSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Fmt</span><span class="p">,</span> <span class="n">ArgList</span><span class="p">);</span>
		<span class="n">va_end</span><span class="p">(</span><span class="n">ArgList</span><span class="p">);</span>

		<span class="c1">// Check if the buffer passed the limit</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SprintfResult</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Probably the buffer is large that we can't store it</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// Fill the above with timer</span>
		<span class="n">TIME_FIELDS</span> <span class="n">TimeFields</span><span class="p">;</span>
		<span class="n">LARGE_INTEGER</span> <span class="n">SystemTime</span><span class="p">,</span> <span class="n">LocalTime</span><span class="p">;</span>
		<span class="n">KeQuerySystemTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SystemTime</span><span class="p">);</span>
		<span class="n">ExSystemTimeToLocalTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SystemTime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LocalTime</span><span class="p">);</span>
		<span class="n">RtlTimeToTimeFields</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LocalTime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TimeFields</span><span class="p">);</span>

		<span class="c1">// We won't use this because we can't use in any IRQL</span>
		<span class="cm">/*Status = RtlStringCchPrintfA(TimeBuffer, RTL_NUMBER_OF(TimeBuffer),
			"%02hd:%02hd:%02hd.%03hd", TimeFields.Hour,
			TimeFields.Minute, TimeFields.Second,
			TimeFields.Milliseconds);

		// Append time with previous message
		Status = RtlStringCchPrintfA(LogMessage, PacketChunkSize - 1, "(%s)\t %s", TimeBuffer, TempMessage);*/</span>

		<span class="c1">// this function probably run without error, so there is no need to check the return value</span>
		<span class="n">sprintf_s</span><span class="p">(</span><span class="n">TimeBuffer</span><span class="p">,</span> <span class="n">RTL_NUMBER_OF</span><span class="p">(</span><span class="n">TimeBuffer</span><span class="p">),</span> <span class="s">"%02hd:%02hd:%02hd.%03hd"</span><span class="p">,</span> <span class="n">TimeFields</span><span class="p">.</span><span class="n">Hour</span><span class="p">,</span>
			<span class="n">TimeFields</span><span class="p">.</span><span class="n">Minute</span><span class="p">,</span> <span class="n">TimeFields</span><span class="p">.</span><span class="n">Second</span><span class="p">,</span>
			<span class="n">TimeFields</span><span class="p">.</span><span class="n">Milliseconds</span><span class="p">);</span>

		<span class="c1">// Append time with previous message</span>
		<span class="n">SprintfResult</span> <span class="o">=</span> <span class="n">sprintf_s</span><span class="p">(</span><span class="n">LogMessage</span><span class="p">,</span> <span class="n">PacketChunkSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"(%s - core : %d - vmx-root? %s)</span><span class="se">\t</span><span class="s"> %s"</span><span class="p">,</span> <span class="n">TimeBuffer</span><span class="p">,</span> <span class="n">KeGetCurrentProcessorNumberEx</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">IsVmxRootMode</span> <span class="o">?</span> <span class="s">"yes"</span> <span class="o">:</span> <span class="s">"no"</span><span class="p">,</span> <span class="n">TempMessage</span><span class="p">);</span>

		<span class="c1">// Check if the buffer passed the limit</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SprintfResult</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Probably the buffer is large that we can't store it</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// It's actually not necessary to use -1 but because user-mode code might assume a null-terminated buffer so</span>
		<span class="c1">// it's better to use - 1</span>
		<span class="n">va_start</span><span class="p">(</span><span class="n">ArgList</span><span class="p">,</span> <span class="n">Fmt</span><span class="p">);</span>
		<span class="c1">// We won't use this because we can't use in any IRQL</span>
		<span class="cm">/* Status = RtlStringCchVPrintfA(LogMessage, PacketChunkSize - 1, Fmt, ArgList); */</span>
		<span class="n">SprintfResult</span> <span class="o">=</span> <span class="n">vsprintf_s</span><span class="p">(</span><span class="n">LogMessage</span><span class="p">,</span> <span class="n">PacketChunkSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Fmt</span><span class="p">,</span> <span class="n">ArgList</span><span class="p">);</span>
		<span class="n">va_end</span><span class="p">(</span><span class="n">ArgList</span><span class="p">);</span>

		<span class="c1">// Check if the buffer passed the limit</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SprintfResult</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Probably the buffer is large that we can't store it</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="c1">// Use std function because they can be run in any IRQL</span>
	<span class="c1">// RtlStringCchLengthA(LogMessage, PacketChunkSize - 1, &amp;WrittenSize);</span>
	<span class="n">WrittenSize</span> <span class="o">=</span> <span class="n">strnlen_s</span><span class="p">(</span><span class="n">LogMessage</span><span class="p">,</span> <span class="n">PacketChunkSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LogMessage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// nothing to write</span>
		<span class="n">DbgBreakPoint</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IsImmediateMessage</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">LogSendBuffer</span><span class="p">(</span><span class="n">OperationCode</span><span class="p">,</span> <span class="n">LogMessage</span><span class="p">,</span> <span class="n">WrittenSize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">// Check if we're in Vmx-root, if it is then we use our customized HIGH_IRQL Spinlock, if not we use the windows spinlock</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRootMode</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Set the index</span>
			<span class="n">Index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">SpinlockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VmxRootLoggingLockForNonImmBuffers</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="c1">// Set the index</span>
			<span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="c1">// Acquire the lock </span>
			<span class="n">KeAcquireSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferLockForNonImmMessage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OldIRQL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="c1">//Set the result to True</span>
		<span class="n">Result</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

		<span class="c1">// If log message WrittenSize is above the buffer then we have to send the previous buffer</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentLengthOfNonImmBuffer</span> <span class="o">+</span> <span class="n">WrittenSize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PacketChunkSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentLengthOfNonImmBuffer</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>

			<span class="c1">// Send the previous buffer (non-immediate message)</span>
			<span class="n">Result</span> <span class="o">=</span> <span class="n">LogSendBuffer</span><span class="p">(</span><span class="n">OPERATION_LOG_NON_IMMEDIATE_MESSAGE</span><span class="p">,</span>
				<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferForMultipleNonImmediateMessage</span><span class="p">,</span>
				<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentLengthOfNonImmBuffer</span><span class="p">);</span>

			<span class="c1">// Free the immediate buffer</span>
			<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentLengthOfNonImmBuffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferForMultipleNonImmediateMessage</span><span class="p">,</span> <span class="n">PacketChunkSize</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// We have to save the message</span>
		<span class="n">RtlCopyBytes</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferForMultipleNonImmediateMessage</span> <span class="o">+</span>
			<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentLengthOfNonImmBuffer</span><span class="p">,</span> <span class="n">LogMessage</span><span class="p">,</span> <span class="n">WrittenSize</span><span class="p">);</span>

		<span class="c1">// add the length </span>
		<span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">CurrentLengthOfNonImmBuffer</span> <span class="o">+=</span> <span class="n">WrittenSize</span><span class="p">;</span>


		<span class="c1">// Check if we're in Vmx-root, if it is then we use our customized HIGH_IRQL Spinlock, if not we use the windows spinlock</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IsVmxRootMode</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">SpinlockUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VmxRootLoggingLockForNonImmBuffers</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="c1">// Release the lock</span>
			<span class="n">KeReleaseSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">BufferLockForNonImmMessage</span><span class="p">,</span> <span class="n">OldIRQL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="receiving-buffers-and-messages-in-user-mode"><span class="mr-2"><strong>Receiving buffers and messages in user-mode</strong></span><a href="#receiving-buffers-and-messages-in-user-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Receiving buffers from the user-mode is done by using an IOCTL. First, we create another thread in our user-mode application. This thread is responsible for bringing the kernel-mode buffers to the user-mode and then operate based on Operation Number.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>		<span class="n">HANDLE</span> <span class="n">Thread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ThreadFunc</span><span class="p">,</span> <span class="n">Handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Thread</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[*] Thread Created successfully !!!"</span><span class="p">);</span>
		<span class="p">}</span>
</pre></table></code></div></div><p>This thread executes the following function. We use <strong>IRP Pending</strong> for transferring data from kernel-mode to user-mode. IRP Pending is primarily used for transferring a packet. For example, you send an IRP packet to the kernel, and kernel marks this packet as <strong>Pending</strong>. Whenever the user-mode buffer is available to send to the user-mode, the kernel completes the IRP request, and the IOCTL function returns to the user-mode and continues the execution.</p><p>It’s somehow like when you use Wait for an object. We can also use <strong>events</strong> in Windows and whenever the buffer is available the event is triggered but IRP Pending is better as it designed for the purpose of sending messages to user-mode.</p><p>What we have to do is allocating a buffer for kernel-mode code and using <strong>DeviceIoControl</strong> to request the packet. When the packet from the kernel received, we process the packet and switch through the Operation Number.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ReadIrpBasedBuffer</span><span class="p">(</span><span class="n">HANDLE</span>  <span class="n">Device</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">BOOL</span>    <span class="n">Status</span><span class="p">;</span>
	<span class="n">ULONG</span>   <span class="n">ReturnedLength</span><span class="p">;</span>
	<span class="n">REGISTER_EVENT</span> <span class="n">RegisterEvent</span><span class="p">;</span>
	<span class="n">UINT32</span> <span class="n">OperationCode</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">" =============================== Kernel-Mode Logs (Driver) ===============================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">RegisterEvent</span><span class="p">.</span><span class="n">hEvent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">RegisterEvent</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">IRP_BASED</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">OutputBuffer</span><span class="p">[</span><span class="n">UsermodeBufferSize</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">try</span>
	<span class="p">{</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">UsermodeBufferSize</span><span class="p">);</span>

			<span class="n">Sleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>							<span class="c1">// we're not trying to eat all of the CPU ;)</span>

			<span class="n">Status</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span>
				<span class="n">Device</span><span class="p">,</span>							<span class="c1">// Handle to device</span>
				<span class="n">IOCTL_REGISTER_EVENT</span><span class="p">,</span>			<span class="c1">// IO Control code</span>
				<span class="o">&amp;</span><span class="n">RegisterEvent</span><span class="p">,</span>					<span class="c1">// Input Buffer to driver.</span>
				<span class="n">SIZEOF_REGISTER_EVENT</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>		<span class="c1">// Length of input buffer in bytes. (x 2 is bcuz as the driver is x64 and has 64 bit values)</span>
				<span class="n">OutputBuffer</span><span class="p">,</span>					<span class="c1">// Output Buffer from driver.</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">OutputBuffer</span><span class="p">),</span>			<span class="c1">// Length of output buffer in bytes.</span>
				<span class="o">&amp;</span><span class="n">ReturnedLength</span><span class="p">,</span>				<span class="c1">// Bytes placed in buffer.</span>
				<span class="nb">NULL</span>							<span class="c1">// synchronous call</span>
			<span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Ioctl failed with code %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">========================= Kernel Mode (Buffer) =========================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

			<span class="n">OperationCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OperationCode</span><span class="p">,</span> <span class="n">OutputBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span>

			<span class="n">printf</span><span class="p">(</span><span class="s">"Returned Length : 0x%x </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ReturnedLength</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Operation Code : 0x%x </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">OperationCode</span><span class="p">);</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">OperationCode</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="k">case</span> <span class="n">OPERATION_LOG_NON_IMMEDIATE_MESSAGE</span><span class="p">:</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"A buffer of messages (OPERATION_LOG_NON_IMMEDIATE_MESSAGE) :</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">OutputBuffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">OPERATION_LOG_INFO_MESSAGE</span><span class="p">:</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Information log (OPERATION_LOG_INFO_MESSAGE) :</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">OutputBuffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">OPERATION_LOG_ERROR_MESSAGE</span><span class="p">:</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Error log (OPERATION_LOG_ERROR_MESSAGE) :</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">OutputBuffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">OPERATION_LOG_WARNING_MESSAGE</span><span class="p">:</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Warning log (OPERATION_LOG_WARNING_MESSAGE) :</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">OutputBuffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UINT32</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>


			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">========================================================================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Exception !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="ioctl-and-managing-user-mode-requests"><span class="mr-2"><strong>IOCTL and managing user-mode requests</strong></span><a href="#ioctl-and-managing-user-mode-requests" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>When the IOCTL arrived on the kernel side, <strong>DrvDispatchIoControl</strong> from major functions is called. This function returns a pointer to the caller’s I/O stack location in the specified IRP.</p><p>From the IRP Stack we can read the IOCTL code and buffers address, this time we perform necessary checks and pass the arguments to <strong>LogRegisterIrpBasedNotification</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre>
<span class="cm">/* Driver IOCTL Dispatcher*/</span>
<span class="n">NTSTATUS</span> <span class="nf">DrvDispatchIoControl</span><span class="p">(</span><span class="n">PDEVICE_OBJECT</span> <span class="n">DeviceObject</span><span class="p">,</span> <span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PIO_STACK_LOCATION</span>  <span class="n">IrpStack</span><span class="p">;</span>
	<span class="n">PREGISTER_EVENT</span> <span class="n">RegisterEvent</span><span class="p">;</span>
	<span class="n">NTSTATUS</span>    <span class="n">Status</span><span class="p">;</span>

	<span class="n">IrpStack</span> <span class="o">=</span> <span class="n">IoGetCurrentIrpStackLocation</span><span class="p">(</span><span class="n">Irp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">IoControlCode</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">IOCTL_REGISTER_EVENT</span><span class="p">:</span>

		<span class="c1">// First validate the parameters.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IrpStack</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">InputBufferLength</span> <span class="o">&lt;</span> <span class="n">SIZEOF_REGISTER_EVENT</span> <span class="o">||</span> <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">AssociatedIrp</span><span class="p">.</span><span class="n">SystemBuffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_INVALID_PARAMETER</span><span class="p">;</span>
			<span class="n">DbgBreakPoint</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">RegisterEvent</span> <span class="o">=</span> <span class="p">(</span><span class="n">PREGISTER_EVENT</span><span class="p">)</span><span class="n">Irp</span><span class="o">-&gt;</span><span class="n">AssociatedIrp</span><span class="p">.</span><span class="n">SystemBuffer</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">RegisterEvent</span><span class="o">-&gt;</span><span class="n">Type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IRP_BASED</span><span class="p">:</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">LogRegisterIrpBasedNotification</span><span class="p">(</span><span class="n">DeviceObject</span><span class="p">,</span> <span class="n">Irp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EVENT_BASED</span><span class="p">:</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">LogRegisterEventBasedNotification</span><span class="p">(</span><span class="n">DeviceObject</span><span class="p">,</span> <span class="n">Irp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ASSERTMSG</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Unknow notification type from user-mode</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_INVALID_PARAMETER</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>  <span class="c1">// should never hit this</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_NOT_IMPLEMENTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">Status</span> <span class="o">!=</span> <span class="n">STATUS_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">Status</span><span class="p">;</span>
		<span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To register an IRP notification, first, we check whether any other thread is pending by checking <strong>GlobalNotifyRecord</strong> if there is any thread we complete the IRP and return to the user-mode because in our design we ignore multiple threads that request the buffers means that only one thread can read the kernel-mode buffer.</p><p>Second, we initialize a custom structure that describes the state. The following structure is responsible for saving Type, DPC Object, and target buffer.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_NOTIFY_RECORD</span> <span class="p">{</span>
	<span class="n">NOTIFY_TYPE</span>     <span class="n">Type</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">PKEVENT</span>     <span class="n">Event</span><span class="p">;</span>
		<span class="n">PIRP</span>        <span class="n">PendingIrp</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">Message</span><span class="p">;</span>
	<span class="n">KDPC</span>            <span class="n">Dpc</span><span class="p">;</span>
	<span class="n">BOOLEAN</span>			<span class="n">CheckVmxRootMessagePool</span><span class="p">;</span> <span class="c1">// Set so that notify callback can understand where to check (Vmx root or Vmx non-root)</span>
<span class="p">}</span> <span class="n">NOTIFY_RECORD</span><span class="p">,</span> <span class="o">*</span> <span class="n">PNOTIFY_RECORD</span><span class="p">;</span>
</pre></table></code></div></div><p>In order to fill this structure, we initialize a DPC object by calling <strong>KeInitializeDpc</strong>, this function gets the function callback that should be called later (<strong>LogNotifyUsermodeCallback</strong>) and the parameter(s) to this function (<strong>NotifyRecord</strong>).</p><p>We first check the vmx non-root pools to see if anything new is available. Otherwise, we check the vmx-root mode buffer. This precedence is because vmx non-root buffers are more important. After all, we spent must of the time in VMX Root-mode, so we might see thousands of messages from vmx-root while we have fewer messages from vmx non-root. If we check the vmx root message buffer first, then we might lose some messages from vmx non-root or never find a time to process them.</p><p>If any new message is available then we directly add a DPC to the queue (<strong>KeInsertQueueDpc</strong>).</p><p>If there isn’t any new message available, then we simply save our Notify Record for future use, and also we mark IRP to pending state using <strong>IoMarkIrpPending</strong> and return <strong>STATUS_PENDING</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="cm">/* Register a new IRP Pending thread which listens for new buffers */</span>
<span class="n">NTSTATUS</span> <span class="nf">LogRegisterIrpBasedNotification</span><span class="p">(</span><span class="n">PDEVICE_OBJECT</span> <span class="n">DeviceObject</span><span class="p">,</span> <span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PNOTIFY_RECORD</span> <span class="n">NotifyRecord</span><span class="p">;</span>
	<span class="n">PIO_STACK_LOCATION</span> <span class="n">IrpStack</span><span class="p">;</span>
	<span class="n">KIRQL</span>   <span class="n">OOldIrql</span><span class="p">;</span>
	<span class="n">PREGISTER_EVENT</span> <span class="n">RegisterEvent</span><span class="p">;</span>

	<span class="c1">// check if current core has another thread with pending IRP, if no then put the current thread to pending</span>
	<span class="c1">// otherwise return and complete thread with STATUS_SUCCESS as there is another thread waiting for message</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GlobalNotifyRecord</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">IrpStack</span> <span class="o">=</span> <span class="n">IoGetCurrentIrpStackLocation</span><span class="p">(</span><span class="n">Irp</span><span class="p">);</span>
		<span class="n">RegisterEvent</span> <span class="o">=</span> <span class="p">(</span><span class="n">PREGISTER_EVENT</span><span class="p">)</span><span class="n">Irp</span><span class="o">-&gt;</span><span class="n">AssociatedIrp</span><span class="p">.</span><span class="n">SystemBuffer</span><span class="p">;</span>

		<span class="c1">// Allocate a record and save all the event context.</span>
		<span class="n">NotifyRecord</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithQuotaTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NOTIFY_RECORD</span><span class="p">),</span> <span class="n">POOLTAG</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">NotifyRecord</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span>  <span class="n">STATUS_INSUFFICIENT_RESOURCES</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Type</span> <span class="o">=</span> <span class="n">IRP_BASED</span><span class="p">;</span>
		<span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Message</span><span class="p">.</span><span class="n">PendingIrp</span> <span class="o">=</span> <span class="n">Irp</span><span class="p">;</span>

		<span class="n">KeInitializeDpc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Dpc</span><span class="p">,</span> <span class="c1">// Dpc</span>
			<span class="n">LogNotifyUsermodeCallback</span><span class="p">,</span>     <span class="c1">// DeferredRoutine</span>
			<span class="n">NotifyRecord</span>        <span class="c1">// DeferredContext</span>
		<span class="p">);</span>

		<span class="n">IoMarkIrpPending</span><span class="p">(</span><span class="n">Irp</span><span class="p">);</span>

		<span class="c1">// check for new message (for both Vmx-root mode or Vmx non root-mode)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">LogCheckForNewMessage</span><span class="p">(</span><span class="n">FALSE</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="c1">// check vmx root</span>
			<span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">CheckVmxRootMessagePool</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

			<span class="c1">// Insert dpc to queue</span>
			<span class="n">KeInsertQueueDpc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Dpc</span><span class="p">,</span> <span class="n">NotifyRecord</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">LogCheckForNewMessage</span><span class="p">(</span><span class="n">TRUE</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="c1">// check vmx non-root</span>
			<span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">CheckVmxRootMessagePool</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

			<span class="c1">// Insert dpc to queue</span>
			<span class="n">KeInsertQueueDpc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Dpc</span><span class="p">,</span> <span class="n">NotifyRecord</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="c1">// Set the notify routine to the global structure</span>
			<span class="n">GlobalNotifyRecord</span> <span class="o">=</span> <span class="n">NotifyRecord</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// We will return pending as we have marked the IRP pending.</span>
		<span class="k">return</span> <span class="n">STATUS_PENDING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="usermode-notify-callback"><span class="mr-2"><strong>Usermode notify callback</strong></span><a href="#usermode-notify-callback" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>As you see in the above codes, we add DPCs to queue in two functions (<strong>LogRegisterIrpBasedNotification and LogSendBuffer</strong>). This way, we won’t miss anything, and everything is processed as a message is generated. For example, if there is any thread waiting for the message then <strong>LogSendBuffer</strong> notifies it about the new message, if there isn’t any thread waiting for the message then <strong>LogSendBuffer</strong> can’t do anything, as long as a new thread comes to the kernel then it checks for the new message. Think about it one more time. It’s beautiful.</p><p>Now it’s time to read the packets from kernel pools and send them to the user-mode.</p><p>When <strong>LogNotifyUsermodeCallback</strong> is called then we sure that we’re in <strong>DISPATCH_LEVEL</strong> and vmx non-root mode.</p><p>In this function, we check if the parameters sent to the kernel are valid or not. It’s because the user-mode provides them. For example, we check the IRP stack’s <strong>Parameters. DeviceIoControl. InputBufferLength</strong> and <strong>Parameters. DeviceIoControl. OutputBufferLength</strong> to make sure they are not null or check whether the <strong>SystemBuffer</strong> is null or not.</p><p>Then we call <strong>LogReadBuffer</strong> with user-mode buffers, so this function will fill the user-mode buffer and adds the Operation Number in a suitable place. Also, <strong>Irp-&gt;IoStatus.Information</strong> provides the buffer length to the user-mode.</p><p>The last step here is to complete the IRP, so I/O Manager sends the results to the user-mode, and the thread can continue to its normal life.</p><p>The reason why we access the user-mode buffer in all processes (because DPCs might run on the random user-mode process) and why we use DPCs and don’t use other things like APCs is discussed in the <strong>Discussion</strong> section.</p><p>The following code demonstrates what we talked about it above.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre><td class="rouge-code"><pre><span class="cm">/* Complete the IRP in IRP Pending state and fill the usermode buffers with pool data */</span>
<span class="n">VOID</span> <span class="nf">LogNotifyUsermodeCallback</span><span class="p">(</span><span class="n">PKDPC</span> <span class="n">Dpc</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">DeferredContext</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">SystemArgument1</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">SystemArgument2</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">PNOTIFY_RECORD</span> <span class="n">NotifyRecord</span><span class="p">;</span>
	<span class="n">PIRP</span> <span class="n">Irp</span><span class="p">;</span>
	<span class="n">UINT32</span> <span class="n">Length</span><span class="p">;</span>

	<span class="n">UNREFERENCED_PARAMETER</span><span class="p">(</span><span class="n">Dpc</span><span class="p">);</span>
	<span class="n">UNREFERENCED_PARAMETER</span><span class="p">(</span><span class="n">SystemArgument1</span><span class="p">);</span>
	<span class="n">UNREFERENCED_PARAMETER</span><span class="p">(</span><span class="n">SystemArgument2</span><span class="p">);</span>

	<span class="n">NotifyRecord</span> <span class="o">=</span> <span class="n">DeferredContext</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">NotifyRecord</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// can't be NULL</span>
	<span class="n">_Analysis_assume_</span><span class="p">(</span><span class="n">NotifyRecord</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Type</span><span class="p">)</span>
	<span class="p">{</span>

	<span class="k">case</span> <span class="n">IRP_BASED</span><span class="p">:</span>
		<span class="n">Irp</span> <span class="o">=</span> <span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Message</span><span class="p">.</span><span class="n">PendingIrp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">Irp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">PCHAR</span> <span class="n">OutBuff</span><span class="p">;</span> <span class="c1">// pointer to output buffer</span>
			<span class="n">ULONG</span> <span class="n">InBuffLength</span><span class="p">;</span> <span class="c1">// Input buffer length</span>
			<span class="n">ULONG</span> <span class="n">OutBuffLength</span><span class="p">;</span> <span class="c1">// Output buffer length</span>
			<span class="n">PIO_STACK_LOCATION</span> <span class="n">IrpSp</span><span class="p">;</span>

			<span class="c1">// Make suree that concurrent calls to notify function never occurs</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Irp</span><span class="o">-&gt;</span><span class="n">CurrentLocation</span> <span class="o">&lt;=</span> <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">StackCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">DbgBreakPoint</span><span class="p">();</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">IrpSp</span> <span class="o">=</span> <span class="n">IoGetCurrentIrpStackLocation</span><span class="p">(</span><span class="n">Irp</span><span class="p">);</span>
			<span class="n">InBuffLength</span> <span class="o">=</span> <span class="n">IrpSp</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">InputBufferLength</span><span class="p">;</span>
			<span class="n">OutBuffLength</span> <span class="o">=</span> <span class="n">IrpSp</span><span class="o">-&gt;</span><span class="n">Parameters</span><span class="p">.</span><span class="n">DeviceIoControl</span><span class="p">.</span><span class="n">OutputBufferLength</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InBuffLength</span> <span class="o">||</span> <span class="o">!</span><span class="n">OutBuffLength</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_INVALID_PARAMETER</span><span class="p">;</span>
				<span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">// Check again that SystemBuffer is not null</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Irp</span><span class="o">-&gt;</span><span class="n">AssociatedIrp</span><span class="p">.</span><span class="n">SystemBuffer</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="c1">// Buffer is invalid</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">OutBuff</span> <span class="o">=</span> <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">AssociatedIrp</span><span class="p">.</span><span class="n">SystemBuffer</span><span class="p">;</span>
			<span class="n">Length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="c1">// Read Buffer might be empty (nothing to send)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LogReadBuffer</span><span class="p">(</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">CheckVmxRootMessagePool</span><span class="p">,</span> <span class="n">OutBuff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Length</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="c1">// we have to return here as there is nothing to send here</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="n">Length</span><span class="p">;</span>


			<span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
			<span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EVENT_BASED</span><span class="p">:</span>

		<span class="c1">// Signal the Event created in user-mode.</span>
		<span class="n">KeSetEvent</span><span class="p">(</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Message</span><span class="p">.</span><span class="n">Event</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

		<span class="c1">// Dereference the object as we are done with it.</span>
		<span class="n">ObDereferenceObject</span><span class="p">(</span><span class="n">NotifyRecord</span><span class="o">-&gt;</span><span class="n">Message</span><span class="p">.</span><span class="n">Event</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NotifyRecord</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">NotifyRecord</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="uninitialization-phase"><span class="mr-2"><strong>Uninitialization Phase</strong></span><a href="#uninitialization-phase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Nothing special, we just de-allocate the previously allocated buffers. Keep in mind that we should initialize the message tracer at the very first function of our driver so we can use it and, of course, uninitialize it at the end when we don’t have any message anymore.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cm">/* Uninitialize the buffer relating to log message tracing */</span>
<span class="n">VOID</span> <span class="nf">LogUnInitialize</span><span class="p">()</span>
<span class="p">{</span>

	<span class="c1">// de-allocate buffer for messages and initialize the core buffer information (for vmx-root core)</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Free each buffers</span>
		<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferStartAddress</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
		<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">BufferForMultipleNonImmediateMessage</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// de-allocate buffers for trace message and data messages</span>
	<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">MessageBufferInformation</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img data-src="../../assets/images/anime-hvfs-part-8-1.jpg" alt="Aniiiimmmmeee :)" data-proofer-ignore></p><h1 id="wpp-tracing"><strong>WPP Tracing</strong></h1><p>WPP Tracing is another mechanism provided by Windows, which can be used to trace messages from both vmx non-root and vmx root-mode and in any IRQL. It is primarily intended for debugging code during development, and it’s capable of publishing events that can be consumed by applications in structured ETW events.</p><p>Logging messages with WPP software tracing is similar to using Windows event logging services. The driver logs a message ID and unformatted binary data in a log file. Subsequently, a postprocessor converts the information in the log file to a human-readable form.</p><p>In order to use WPP Tracing, first, we should configure our driver to use WPP Tracing as the message tracing by setting <strong>UseWPPTracing</strong> to <strong>TRUE</strong>. By default it’s <strong>FALSE</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// Use WPP Tracing instead of all logging functions</span>
<span class="cp">#define UseWPPTracing		TRUE
</span></pre></table></code></div></div><p>Then we go to our project’s <strong>properties</strong> and set <strong>Run Wpp Tracing</strong> to <strong>Yes</strong> and also add a custom function for sending messages by setting <strong>Function To Generate Trace Messages</strong> to <strong>HypervisorTraceLevelMessage (LEVEL,FLAGS,MSG,…)</strong>.</p><p><img data-src="../../assets/images/WPP-tracing-configurations.png" alt="WPP Tracing Configuration" data-proofer-ignore></p><p>Then we need to generate a unique GUID for our driver by using Visual Studio’s <strong>Tools -&gt; Create GUID</strong> and generate one and put it into the following format.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#define WPP_CONTROL_GUIDS                                              \
    WPP_DEFINE_CONTROL_GUID(                                           \
        HypervisorFromScratchLogger, (2AE39766,AE4B,46AB,AFC4,002DB8109721), \
        WPP_DEFINE_BIT(HVFS_LOG)             </span><span class="cm">/* bit  0 = 0x00000001 */</span><span class="cp"> \
        WPP_DEFINE_BIT(HVFS_LOG_INFO)        </span><span class="cm">/* bit  1 = 0x00000002 */</span><span class="cp"> \
        WPP_DEFINE_BIT(HVFS_LOG_WARNING)     </span><span class="cm">/* bit  2 = 0x00000004 */</span><span class="cp"> \
        WPP_DEFINE_BIT(HVFS_LOG_ERROR)       </span><span class="cm">/* bit  3 = 0x00000008 */</span><span class="cp"> \
        )    
</span></pre></table></code></div></div><p><strong>WPP_DEFINE_BIT</strong> creates some specific events for our messages that can be used in the future for masking specific events.</p><p>After all the above code, we initialize the WPP Tracing by adding the following code at the very first line of the code, e.g., <strong>DriverEntry</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Initialize WPP Tracing</span>
	<span class="n">WPP_INIT_TRACING</span><span class="p">(</span><span class="n">DriverObject</span><span class="p">,</span> <span class="n">RegistryPath</span><span class="p">);</span>
</pre></table></code></div></div><p>At last we clean up and set WPP Tracing to off by using the following code to <strong>Driver Unload</strong> function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Stop the tracing</span>
	<span class="n">WPP_CLEANUP</span><span class="p">(</span><span class="n">DriverObject</span><span class="p">);</span>
</pre></table></code></div></div><p>For making things easy, I add the following codes to our previous message tracing code, which means that instead of sending the buffers into our custom message tracing buffer, we’ll send it to WPP Tracing buffer.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre>
	<span class="k">if</span> <span class="p">(</span><span class="n">OperationCode</span> <span class="o">==</span> <span class="n">OPERATION_LOG_INFO_MESSAGE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">HypervisorTraceLevelMessage</span><span class="p">(</span>
			<span class="n">TRACE_LEVEL_INFORMATION</span><span class="p">,</span>  <span class="c1">// ETW Level defined in evntrace.h</span>
			<span class="n">HVFS_LOG_INFO</span><span class="p">,</span>
			<span class="s">"%s"</span><span class="p">,</span><span class="c1">// Flag defined in WPP_CONTROL_GUIDS</span>
			<span class="n">LogMessage</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">OperationCode</span> <span class="o">==</span> <span class="n">OPERATION_LOG_WARNING_MESSAGE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">HypervisorTraceLevelMessage</span><span class="p">(</span>
			<span class="n">TRACE_LEVEL_WARNING</span><span class="p">,</span>  <span class="c1">// ETW Level defined in evntrace.h</span>
			<span class="n">HVFS_LOG_WARNING</span><span class="p">,</span>
			<span class="s">"%s"</span><span class="p">,</span><span class="c1">// Flag defined in WPP_CONTROL_GUIDS</span>
			<span class="n">LogMessage</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">OperationCode</span> <span class="o">==</span> <span class="n">OPERATION_LOG_ERROR_MESSAGE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">HypervisorTraceLevelMessage</span><span class="p">(</span>
			<span class="n">TRACE_LEVEL_ERROR</span><span class="p">,</span>  <span class="c1">// ETW Level defined in evntrace.h</span>
			<span class="n">HVFS_LOG_ERROR</span><span class="p">,</span>
			<span class="s">"%s"</span><span class="p">,</span><span class="c1">// Flag defined in WPP_CONTROL_GUIDS</span>
			<span class="n">LogMessage</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">HypervisorTraceLevelMessage</span><span class="p">(</span>
			<span class="n">TRACE_LEVEL_NONE</span><span class="p">,</span>  <span class="c1">// ETW Level defined in evntrace.h</span>
			<span class="n">HVFS_LOG</span><span class="p">,</span>
			<span class="s">"%s"</span><span class="p">,</span><span class="c1">// Flag defined in WPP_CONTROL_GUIDS</span>
			<span class="n">LogMessage</span><span class="p">);</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Also, we have to <strong>.tmh</strong> files. These files are auto-generated by the WPP framework, which contains the required code for trace messages. <strong>TMH</strong> file name should be the same as the C file, for example, if we are adding the trace message in “Driver.c” then we are supposed to include “<strong>Driver.tmh</strong>”. We used WPP Tracing APIs in two files, first <strong>Driver.c</strong> and <strong>Logging.c,</strong> so we have to include <strong>Driver.tmh</strong> and <strong>Logging.tmh</strong> and no need for these files in other project files as long as we gathered everything in one file.</p><p>The WPP Tracing is complete! In order to see the messages in user-mode, we have to use another application, e.g traceview.</p><p>Personally, I prefer to use my custom message tracing as WPP Tracing needs to some other application to parse the <strong>.pdb</strong> file or other files to show the messages, and I didn’t find any good example of parsing messages in an application without using another app.</p><p>You can see the results of WPP Tracing later in <strong>Let’s Test it!</strong> section.</p><h1 id="supporting-to-hyper-v"><strong>Supporting to Hyper-V</strong></h1><p>As I told you in the previous parts, testing and building hypervisor for Hyper-V needs extra consideration and adding a few more lines of code to support Hyper-V nested virtualization.</p><p>At the time of writing this part, Hyper-V and VMware Workstation are incompatible with each other, which means that if you run Hyper-V you can’t run VMware and a message like this will appear.</p><p><em>VMware Workstation and Hyper-V are not compatible. Remove the Hyper-V role from the system before running VMware Workstation.</em></p><p>The same is true for VMware, if you run VMware you can’t run Hyper-V and you need to execute a command then restart your computer to use another VMM.</p><p>In order to use Hyper-V, you should run the following command (as administrator) and then restart your computer.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">bcdedit</span> <span class="o">/</span><span class="n">set</span> <span class="n">hypervisorlaunchtype</span> <span class="k">auto</span> 
</pre></table></code></div></div><p>And if you want to run VMware, you can run the following command (as administrator) and restart your computer.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">bcdedit</span> <span class="o">/</span><span class="n">set</span> <span class="n">hypervisorlaunchtype</span> <span class="n">off</span>
</pre></table></code></div></div><h2 id="enable-nested-virtualization"><span class="mr-2"><strong>Enable Nested Virtualization</strong></span><a href="#enable-nested-virtualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-1/">part 1</a>, there is a section that describes how to enable VMware’s nested virtualization and test your driver. For Hyper-V we have an exact same scenario, first, turn off the target VM then enable nested virtualization for the target virtual machine by running the following command on <strong>Powershell</strong>:</p><p>Note that instead of <strong>PutYourVmNameHere</strong>, put the name of your virtual machine that you want to enable nested virtualization for it.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Set</span><span class="o">-</span><span class="n">VMProcessor</span> <span class="o">-</span><span class="n">VMName</span> <span class="n">PutYourVmNameHere</span> <span class="o">-</span><span class="n">ExposeVirtualizationExtensions</span> <span class="err">$</span><span class="nb">true</span>
</pre></table></code></div></div><p>And if you need to disable it, you can run:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Set</span><span class="o">-</span><span class="n">VMProcessor</span> <span class="o">-</span><span class="n">VMName</span> <span class="n">PutYourVmNameHere</span> <span class="o">-</span><span class="n">ExposeVirtualizationExtensions</span> <span class="err">$</span><span class="nb">false</span>
</pre></table></code></div></div><p>Now you need to attach your Hyper-V machine to a windbg debugger. There are many ways to do it. You can read <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection-automatically">here</a> and <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection">here</a> (I prefer using <strong>kdnet.exe</strong>).</p><p>Now we have the testing environment, it’s time to modify our hypervisor so we can support Hyper-V.</p><h2 id="hyper-vs-visible-behavior-in-nested-virtualization"><span class="mr-2"><strong>Hyper-V’s visible behavior in nested virtualization</strong></span><a href="#hyper-vs-visible-behavior-in-nested-virtualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hyper-V has some visible behavior for our hypervisor, which means that you should manage some of them that relate to us and give some of them to the Hyper-V as a top-level hypervisor to manage them, you’re confused? Let me explain it one more time.</p><p>In a nested virtualization environment, you’re not directly getting the vm-exits and all other hypervisor events, instead it’s the top-level hypervisor that gets the vm-exit (in our case Hyper-V is the top-level). Top-level hypervisor calls the vm-exit handler of lower-level hypervisors (our hypervisor is a low-level hypervisor in this case.) now the lower level hypervisor manages the vm-exit (for example it injects an event (interrupt) to be delivered to the guest) after vm-exit finishes it executes VMRESUME, but this instruction won’t directly go to the guest vmx non-root. Instead, it goes to the vm-exit handler of the top-level hypervisor, and now it’s the top-level hypervisor that performs the tasks (In our example, insert event to the guest).</p><p>So, even our hypervisor is not the first hypervisor that gets the event, but our hypervisor is the first to manage them.</p><p>On the other hand, Windows kernel is highly integrated to Hyper-V, which means that it uses lots of Hypercalls (Vmcalls) and MSRs to contact with Hyper-V and if the Windows kernel doesn’t get the valid response from Hyper-V then it crashes or halts.</p><p>As the first hypervisor to manage the vm-exits, we have to inspect vm-exit details to see if the vm-exit relates to us our refers to Hyper-V. In other words, it’s a general vm-exit, or it’s because Windows wants to talk with Hyper-V.</p><p>OK, let see what we should manage and what we should not.</p><h2 id="hyper-v-hypervisor-top-level-functional-specification-tlfs"><span class="mr-2"><strong>Hyper-V Hypervisor Top-Level Functional Specification (TLFS)</strong></span><a href="#hyper-v-hypervisor-top-level-functional-specification-tlfs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The Hyper-V Hypervisor Top-Level Functional Specification (TLFS) describes the hypervisor’s externally visible behavior to other operating system components. This specification is meant to be useful for guest operating system developers.</p><p>If you want to research Hyper-V, you have to read the documentation about Hyper-V’s TLFS <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs">here</a>, but we just want to support Hyper-V. Hence, there is documentation (<a href="../../assets/files/Requirements-for-Implementing-the-Microsoft-Hypervisor-Interface-1.pdf">Requirements for Implementing the Microsoft Hypervisor Interface</a>) that describes the things we should do in order to support Hyper-V. Of course, we’re not going to implement all of them to make our hypervisor work on Hyper-V.</p><h2 id="out-of-range-msrs"><span class="mr-2"><strong>Out of Range MSRs</strong></span><a href="#out-of-range-msrs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-6/">part 6</a>, I described MSR Bitmaps, if you remember MSR bitmap support MSR index (RCX) between <strong>0x00000000</strong> to <strong>0x00001FFF</strong> and <strong>0xC0000000</strong> to <strong>0xC0001FFF</strong>. Windows uses other MSRs from <strong>0x40000000</strong> to <strong>0x400000F0</strong> for requesting something or reporting something to vmx-root.</p><p>You might ask why they don’t use VMCALLs. Of course, they can use VMCALL, but most hypervisors do this. It’s cheaper and predates VMCALLs, and also this range is specifically designed to be used by hypervisors.</p><p>The reason why it’s cheaper is the same discussion about why use <strong>int 2e</strong> and not <strong>sysenter</strong> as the cost of sending data over vmcall and allowing it from ring 0 or ring 3 and deciding things (<strong>rdmsr</strong> doesn’t need that ring check) and sending data back is greater than a simple MSR interface and can work with legacy compilers and systems too.</p><p>You can find the definitions of these MSRs <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/hyperv-tlfs.h">here</a>.</p><p>All in all, I modified our previous MSR handler (both MSR Read - RDMSR and MSR Write - WRMSR to support MSRs between <strong>0x40000000</strong> to <strong>0x400000F0</strong>). All we have to do is execute RDMSR or WRMSR in vmx-root mode.</p><p>You might ask, is it ok to run WRMSR or RDMSR with hardware invalid MSRs?</p><p>The answer is no! but the reason why we execute it is because we’re are in a nested virtualization environment and it’s not a real vmx-root, physically we’re in vmx non-root mode if that makes sense.</p><p>In other words, VMware or Hyper-V or any nested virtualization environment calls our vm-exit handler in vmx non-root and pretend that it’s in vmx-root mode, so executing WRMSR or RDMSR causes a real vm-exit to Hyper-V, and that’s how they can handle the actual vm-exit.</p><p>For example RDMSR handles like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cm">/* Handles in the cases when RDMSR causes a Vmexit*/</span>
<span class="n">VOID</span> <span class="nf">HvHandleMsrRead</span><span class="p">(</span><span class="n">PGUEST_REGS</span> <span class="n">GuestRegs</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">MSR</span> <span class="n">msr</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>


	<span class="c1">// RDMSR. The RDMSR instruction causes a VM exit if any of the following are true:</span>
	<span class="c1">// </span>
	<span class="c1">// The "use MSR bitmaps" VM-execution control is 0.</span>
	<span class="c1">// The value of ECX is not in the ranges 00000000H - 00001FFFH and C0000000H - C0001FFFH</span>
	<span class="c1">// The value of ECX is in the range 00000000H - 00001FFFH and bit n in read bitmap for low MSRs is 1,</span>
	<span class="c1">//   where n is the value of ECX.</span>
	<span class="c1">// The value of ECX is in the range C0000000H - C0001FFFH and bit n in read bitmap for high MSRs is 1,</span>
	<span class="c1">//   where n is the value of ECX &amp; 00001FFFH.</span>

	<span class="cm">/*
	   Execute WRMSR or RDMSR on behalf of the guest. Important that this
	   can cause bug check when the guest tries to access unimplemented MSR
	   even within the SEH block* because the below WRMSR or RDMSR raises
	   #GP and are not protected by the SEH block (or cannot be protected
	   either as this code run outside the thread stack region Windows
	   requires to proceed SEH). Hypervisors typically handle this by noop-ing
	   WRMSR and returning zero for RDMSR with non-architecturally defined
	   MSRs. Alternatively, one can probe which MSRs should cause #GP prior
	   to installation of a hypervisor and the hypervisor can emulate the
	   results.
	   */</span>

	   <span class="c1">// Check for sanity of MSR if they're valid or they're for reserved range for WRMSR and RDMSR</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="mh">0x00001FFF</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="mh">0xC0000000</span> <span class="o">&lt;=</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="mh">0xC0001FFF</span><span class="p">))</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&gt;=</span> <span class="n">RESERVED_MSR_RANGE_LOW</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="n">RESERVED_MSR_RANGE_HI</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">msr</span><span class="p">.</span><span class="n">Content</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">msr</span><span class="p">.</span><span class="n">Low</span><span class="p">;</span>
	<span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rdx</span> <span class="o">=</span> <span class="n">msr</span><span class="p">.</span><span class="n">High</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Same checks apply to WRMSR too.</p><h2 id="hyper-v-hypercalls-vmcalls"><span class="mr-2"><strong>Hyper-V Hypercalls (VMCALLs)</strong></span><a href="#hyper-v-hypercalls-vmcalls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>VMCALL is exactly like RDMSR and WRMSR, even though running VMCALL on vmx-root mode has a known behavior (invokes an SMM monitor). Still, in our case, in a nested virtualization environment, it causes a vm-exit to Hyper-V so Hyper-V can manage the hypercall.</p><p>Hyper-V has the following convention for its VMCALLs (hypercall).</p><p><img data-src="../../assets/images/hyperv-vmcall.png" alt="Hyper-V hypercall convention" data-proofer-ignore></p><p>As we want to use our hypervisor VMCALLs, a quick and dirty fix for this problem is somehow show the vm-exit handler that our hypervisor routines should manage this VMCALL; thus we put some random hex values to r10, r11, r12 (as these registers are not used in fastcall calling convention, you can choose other registers too) thus we can check for these registers on the vm-exit handler to make sure that this VMCALL relates to our hypervisor.</p><p>As some of the registers should not be changed due to the Windows x64 fastcall calling convention, we save them to restore them later.</p><p>Generally, The registers RAX, RCX, RDX, R8, R9, R10, R11 are considered <em>volatile</em> (caller-saved) and registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are considered <em>nonvolatile</em> (callee-saved).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>     <span class="p">;</span> <span class="n">We</span> <span class="n">change</span> <span class="n">r10</span> <span class="n">to</span> <span class="n">HVFS</span> <span class="n">Hex</span> <span class="n">ASCII</span> <span class="n">and</span> <span class="n">r11</span> <span class="n">to</span> <span class="n">VMCALL</span> <span class="n">Hex</span> <span class="n">ASCII</span> <span class="n">and</span> <span class="n">r12</span> <span class="n">to</span> <span class="n">NOHYPERV</span> <span class="n">Hex</span> <span class="n">ASCII</span> <span class="n">so</span> <span class="n">we</span> <span class="n">can</span> <span class="n">make</span> <span class="n">sure</span> <span class="n">that</span> <span class="n">the</span> <span class="n">calling</span> <span class="n">Vmcall</span> <span class="n">comes</span>
    <span class="p">;</span> <span class="n">from</span> <span class="n">our</span> <span class="n">hypervisor</span> <span class="n">and</span> <span class="n">we</span><span class="err">'</span><span class="n">re</span> <span class="n">resposible</span> <span class="k">for</span> <span class="n">managing</span> <span class="n">it</span><span class="p">,</span> <span class="n">otherwise</span> <span class="n">it</span> <span class="n">has</span> <span class="n">to</span> <span class="n">be</span> <span class="n">managed</span> <span class="n">by</span> <span class="n">Hyper</span><span class="o">-</span><span class="n">V</span>
    <span class="n">push</span>    <span class="n">r10</span>
    <span class="n">push</span>    <span class="n">r11</span>
    <span class="n">push</span>    <span class="n">r12</span>
    <span class="n">mov</span>     <span class="n">r10</span><span class="p">,</span> <span class="mi">48564653</span><span class="n">H</span>          <span class="p">;</span> <span class="p">[</span><span class="n">HVFS</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">r11</span><span class="p">,</span> <span class="mi">564</span><span class="n">d43414c4cH</span>      <span class="p">;</span> <span class="p">[</span><span class="n">VMCALL</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">r12</span><span class="p">,</span> <span class="mf">4e4</span><span class="n">f485950455256H</span>   <span class="p">;</span> <span class="p">[</span><span class="n">NOHYPERV</span><span class="p">]</span>
    <span class="n">vmcall</span>                          <span class="p">;</span> <span class="n">VmxVmcallHandler</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">VmcallNumber</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam1</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam2</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">OptionalParam3</span><span class="p">)</span>
    <span class="n">pop</span>     <span class="n">r12</span>
    <span class="n">pop</span>     <span class="n">r11</span>
    <span class="n">pop</span>     <span class="n">r10</span>
    <span class="n">ret</span>                             <span class="p">;</span> <span class="n">Return</span> <span class="n">type</span> <span class="n">is</span> <span class="n">NTSTATUS</span> <span class="n">and</span> <span class="n">it</span><span class="err">'</span><span class="n">s</span> <span class="n">on</span> <span class="n">RAX</span> <span class="n">from</span> <span class="n">the</span> <span class="n">previous</span> <span class="n">function</span><span class="p">,</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">change</span> <span class="n">anything</span>
</pre></table></code></div></div><p>For Hyper-V VMCALLs we need to adjust RCX, RDX, R8 as demonstrated in the above picture.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">AsmHypervVmcall</span> <span class="n">PROC</span>
    <span class="n">vmcall</span>                       <span class="p">;</span> <span class="kr">__fastcall</span> <span class="n">Vmcall</span><span class="p">(</span><span class="n">rcx</span> <span class="o">=</span> <span class="n">HypercallInputValue</span><span class="p">,</span> <span class="n">rdx</span> <span class="o">=</span> <span class="n">InputParamGPA</span><span class="p">,</span> <span class="n">r8</span> <span class="o">=</span> <span class="n">OutputParamGPA</span><span class="p">)</span>
    <span class="n">ret</span>

<span class="n">AsmHypervVmcall</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>Finally, in the vm-exit handler, we check for the VMCALL to see if our random values are store in the registers or not. If it’s on those registers, then we call our hypervisor VMCALL handler. Otherwise, we let Hyper-V do whatever it wants to its VMCALLs.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">EXIT_REASON_VMCALL</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="c1">// Check if it's our routines that request the VMCALL our it relates to Hyper-V</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r10</span> <span class="o">==</span> <span class="mh">0x48564653</span> <span class="o">&amp;&amp;</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r11</span> <span class="o">==</span> <span class="mh">0x564d43414c4c</span> <span class="o">&amp;&amp;</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r12</span> <span class="o">==</span> <span class="mh">0x4e4f485950455256</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Then we have to manage it as it relates to us</span>
			<span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">VmxVmcallHandler</span><span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="c1">// Otherwise let the top-level hypervisor to manage it</span>
			<span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">AsmHypervVmcall</span><span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">,</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><h2 id="hyper-v-interface-cpuid-leaves"><span class="mr-2"><strong>Hyper-V Interface CPUID Leaves</strong></span><a href="#hyper-v-interface-cpuid-leaves" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The last step on supporting Hyper-V is managing CPUID leaves, here are some of the CPUID leaves that we have to manage them.</p><p>Note that based on the document I <a href="https://github.com/Microsoft/Virtualization-Documentation/raw/master/tlfs/Requirements%20for%20Implementing%20the%20Microsoft%20Hypervisor%20Interface.pdf">mentioned</a>, we have to return non <strong>“Hv#1”</strong> value. This indicates that our hypervisor does NOT conform to the Microsoft hypervisor interface.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">RegistersState</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="n">CPUID_HV_VENDOR_AND_MAX_FUNCTIONS</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="c1">// Return a maximum supported hypervisor CPUID leaf range and a vendor</span>
		<span class="c1">// ID signature as required by the spec.</span>

		<span class="n">cpu_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HYPERV_CPUID_INTERFACE</span><span class="p">;</span>
		<span class="n">cpu_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">rFvH</span><span class="err">'</span><span class="p">;</span>  <span class="c1">// "[H]yper[v]isor [Fr]o[m] [Scratch] = HvFrmScratch"</span>
		<span class="n">cpu_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">rcSm</span><span class="err">'</span><span class="p">;</span>
		<span class="n">cpu_info</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">hcta</span><span class="err">'</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">RegistersState</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="n">HYPERV_CPUID_INTERFACE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Return our interface identifier</span>
		<span class="c1">//cpu_info[0] = 'HVFS'; // [H]yper[V]isor [F]rom [S]cratch </span>

		<span class="c1">// Return non Hv#1 value. This indicate that our hypervisor does NOT</span>
		<span class="c1">// conform to the Microsoft hypervisor interface.</span>

		<span class="n">cpu_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="mi">0</span><span class="err">#</span><span class="n">vH</span><span class="err">'</span><span class="p">;</span>  <span class="c1">// Hv#0</span>
		<span class="n">cpu_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_info</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span>
</pre></table></code></div></div><p>By the way, it works without the above modification about CPUID leaves, but it’s better to manage them based on TLFS.</p><p>One other thing that I noticed during the development on Hyper-V was the fact that we have vm-exits because the guest executes HLT (Halt) instruction, of course, we don’t want to halt the processor so in the case of <strong>EXIT_REASON_HLT</strong> we simply ignore it.</p><p>Finished! From now you can test your hypervisor on Hyper-V too : )</p><h1 id="fixing-previous-design-issues"><strong>Fixing Previous Design Issues</strong></h1><p>In this part, we want to improve our hypervisor and fix some issues from the previous parts regarding problems and misunderstandings.</p><h2 id="fixing-the-problem-with-pre-allocated-buffers"><span class="mr-2"><strong>Fixing the problem with pre-allocated buffers</strong></span><a href="#fixing-the-problem-with-pre-allocated-buffers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Our previous buffer pre-allocation has 2 problems,</p><ul><li>It doesn’t allow us to hook page from VMX Root mode, which means that every pool allocation should start from vmx non-root mode.<li>In the process of allocation, we didn’t acquire spinlock so that the processor might interrupt us. Next time we want to continue our execution, there is no allocation as we allocate pools per core.</ul><p>To fix them, we need to design a global pool manager. You can see the pool manager code in “<strong>PoolManager.c</strong>” and “<strong>PoolManager.h</strong>”. I’m not gonna describe how it works as it’s pretty clear if you see the source code, but I’ll explain the functionality of this pool manager and how you can use its functions.</p><p>In this pool manager, instead of allocating core-core specific pre-allocated buffers, we’ll use global pre-allocated buffers with ten pre-allocated buffers ready, each time one of these buffers is used we add a request to pool manager to replace another pool as soon as possible, this way we’ll never run out of pre-allocated pools.</p><p>Of course, we might run out of the pre-allocated pool if ten requests arrive at the pool manager, but we don’t need such a request and, of course, between them, pool manager gets a chance to re-allocate new pools.</p><p>Here the functions explanation :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span> <span class="nf">PoolManagerInitialize</span><span class="p">();</span>
</pre></table></code></div></div><p>Initializes the Pool Manager and pre-allocate some pools.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">VOID</span> <span class="nf">PoolManagerUninitialize</span><span class="p">();</span>
</pre></table></code></div></div><p>De-allocate all the allocated pools</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span> <span class="nf">PoolManagerCheckAndPerformAllocation</span><span class="p">();</span>
</pre></table></code></div></div><p>The above function tries to see whether a new pool request is available, if available, then allocates it. It should be called in <strong>PASSIVE_LEVEL</strong> (vmx non-root mode) because we want paging allocation, and also, the best place to check for it is on IOCTL handler as we call it frequently and it’s <strong>PASSIVE_LEVEL</strong> and safe.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span> <span class="nf">PoolManagerRequestAllocation</span><span class="p">(</span><span class="n">SIZE_T</span> <span class="n">Size</span><span class="p">,</span> <span class="n">UINT32</span> <span class="n">Count</span><span class="p">,</span> <span class="n">POOL_ALLOCATION_INTENTION</span> <span class="n">Intention</span><span class="p">);</span>
</pre></table></code></div></div><p>If we have requested to allocate a new pool, we can call this function. It stores the requests somewhere in the memory to be allocated when it’s safe (<strong>IRQL == PASSIVE_LEVEL</strong>).</p><p><strong>POOL_ALLOCATION_INTENTION</strong> is an enum that describes why we need this pool. It’s used because we might need pools for other purposes with different sizes, so we use our pool manager without any problem.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">UINT64</span> <span class="nf">PoolManagerRequestPool</span><span class="p">(</span><span class="n">POOL_ALLOCATION_INTENTION</span> <span class="n">Intention</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">RequestNewPool</span><span class="p">,</span> <span class="n">UINT32</span> <span class="n">Size</span><span class="p">);</span>
</pre></table></code></div></div><p>In the vmx-root mode, if we need a safe pool address immediately we call it, it also requests a new pool if we set <strong>RequestNewPool</strong> to <strong>TRUE;</strong> thus, next time that it’s safe, the pool will be allocated.</p><p>Also, you can look at the code for other explanations.</p><h2 id="avoid-intercepting-accesses-to-cr3"><span class="mr-2"><strong>Avoid Intercepting Accesses to CR3</strong></span><a href="#avoid-intercepting-accesses-to-cr3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>One of misunderstanding that we have from part 5 until this part was that we intercept CR3 accesses because we set <strong>CR3 load-exiting</strong> and <strong>CR3 store-exiting</strong> on the <strong>Cpu Based VM Exec Controls</strong>.</p><p>In general, it’s quite unusual to intercept guest accesses to CR3 when you run it under EPT. It’s a behavior mostly done when you implementing shadow MMU (Because lack of EPT support in CPU) so not intercepting CR3 accesses is the standard behavior for any hypervisor running with EPT enabled.</p><p>Intercepting CR3 access is always configurable, we have to clear bits <strong>CPU_BASED_CR3_STORE_EXITING</strong>, <strong>CPU_BASED_CR3_LOAD_EXITING,</strong> and <strong>CPU_BASED_INVLPG_EXITING</strong> in VMCS’s <strong>CPU_BASED_VM_EXEC_CONTROL</strong>.</p><p>But wait, why we should clear them, we never set them !</p><p>As noted in previous parts, certain VMX controls are reserved and must be set to a specific value (0 or 1), which is determined by the processor. That’s why we used the function “<strong>HvAdjustControls</strong>” and pass them an MSR (<strong>MSR_IA32_VMX_PROCBASED_CTLS</strong>, <strong>MSR_IA32_VMX_PINBASED_CTLS</strong>, <strong>MSR_IA32_VMX_EXIT_CTLS</strong>, <strong>MSR_IA32_VMX_ENTRY_CTLS</strong>) which represents these settings.</p><p>Actually, there are 3 types of settings for VMCS controls.</p><ul><li>Always-flexible. These have never been reserved.<li>Default0. These are (or have been) reserved with a default setting of 0.<li>Default1. They are (or have been) reserved with a default setting of 1.</ul><p>On newer processors, if Bit 55 (<strong>IA32_VMX_BASIC</strong>) is read as 1 if any VMX controls that are <strong>default1</strong> may be cleared to 0. This bit also reports support for the VMX capability MSRs <strong>A32_VMX_TRUE_PINBASED_CTLS</strong>, <strong>IA32_VMX_TRUE_PROCBASED_CTLS</strong>, <strong>IA32_VMX_TRUE_EXIT_CTLS</strong>, and <strong>IA32_VMX_TRUE_ENTRY_CTLS</strong>.</p><p>So we have to check if our CPU supports this bit, if it supports then we have to use new <strong>A32_VMX_TRUE_PINBASED_CTLS</strong>, <strong>IA32_VMX_TRUE_PROCBASED_CTLS</strong>, <strong>IA32_VMX_TRUE_EXIT_CTLS</strong>, and <strong>IA32_VMX_TRUE_ENTRY_CTLS</strong> instead of <strong>MSR_IA32_VMX_PROCBASED_CTLS</strong>, <strong>MSR_IA32_VMX_PINBASED_CTLS</strong>, <strong>MSR_IA32_VMX_EXIT_CTLS</strong>, <strong>MSR_IA32_VMX_ENTRY_CTLS</strong>.</p><p>Note that <strong>MSR_IA32_VMX_PROCBASED_CTLS2</strong> doesn’t have another version.</p><p>For this purpose, first we read the <strong>MSR_IA32_VMX_BASIC</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="n">IA32_VMX_BASIC_MSR</span> <span class="n">VmxBasicMsr</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="c1">// Reading IA32_VMX_BASIC_MSR </span>
	<span class="n">VmxBasicMsr</span><span class="p">.</span><span class="n">All</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_BASIC</span><span class="p">);</span>
</pre></table></code></div></div><p>Then we check whether the 55th bit of the <strong>MSR_IA32_VMX_BASIC</strong> is set or not. If it’s set, then we use different MSR to our <strong>HvAdjustControls</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>	<span class="n">CpuBasedVmExecControls</span> <span class="o">=</span> <span class="n">HvAdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_ACTIVATE_MSR_BITMAP</span>	<span class="o">|</span> <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">,</span>
		<span class="n">VmxBasicMsr</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">VmxCapabilityHint</span> <span class="o">?</span> <span class="n">MSR_IA32_VMX_TRUE_PROCBASED_CTLS</span> <span class="o">:</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">);</span>

	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">CpuBasedVmExecControls</span><span class="p">);</span>

	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Cpu Based VM Exec Controls (Based on %s) : 0x%x"</span><span class="p">,</span> 
		<span class="n">VmxBasicMsr</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">VmxCapabilityHint</span> <span class="o">?</span> <span class="s">"MSR_IA32_VMX_TRUE_PROCBASED_CTLS"</span> <span class="o">:</span> <span class="s">"MSR_IA32_VMX_PROCBASED_CTLS"</span><span class="p">,</span> <span class="n">CpuBasedVmExecControls</span><span class="p">);</span>

	<span class="n">SecondaryProcBasedVmExecControls</span> <span class="o">=</span> <span class="n">HvAdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_CTL2_RDTSCP</span> <span class="o">|</span>
		<span class="n">CPU_BASED_CTL2_ENABLE_EPT</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_INVPCID</span> <span class="o">|</span>
		<span class="n">CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS</span>  <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_VPID</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">);</span>

	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">SecondaryProcBasedVmExecControls</span><span class="p">);</span>
	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Secondary Proc Based VM Exec Controls (MSR_IA32_VMX_PROCBASED_CTLS2) : 0x%x"</span><span class="p">,</span> <span class="n">SecondaryProcBasedVmExecControls</span><span class="p">);</span>
	
	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">PIN_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">HvAdjustControls</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
		<span class="n">VmxBasicMsr</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">VmxCapabilityHint</span> <span class="o">?</span> <span class="n">MSR_IA32_VMX_TRUE_PINBASED_CTLS</span> <span class="o">:</span> <span class="n">MSR_IA32_VMX_PINBASED_CTLS</span><span class="p">));</span>

	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">HvAdjustControls</span><span class="p">(</span><span class="n">VM_EXIT_IA32E_MODE</span><span class="p">,</span> 
		<span class="n">VmxBasicMsr</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">VmxCapabilityHint</span> <span class="o">?</span> <span class="n">MSR_IA32_VMX_TRUE_EXIT_CTLS</span> <span class="o">:</span> <span class="n">MSR_IA32_VMX_EXIT_CTLS</span><span class="p">));</span>

	<span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">HvAdjustControls</span><span class="p">(</span><span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">,</span>
		<span class="n">VmxBasicMsr</span><span class="p">.</span><span class="n">Fields</span><span class="p">.</span><span class="n">VmxCapabilityHint</span> <span class="o">?</span> <span class="n">MSR_IA32_VMX_TRUE_ENTRY_CTLS</span> <span class="o">:</span> <span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">));</span>
</pre></table></code></div></div><p>This way, we can gain better performance by disabling unnecessary vm-exits as there are countless CR3 changes for each process in Windows, and also meltdown patch brings twice cr3 changes. We no longer need to intercept them.</p><h2 id="restoring-idtr-gdtr-gs-base-and-fs-base"><span class="mr-2"><strong>Restoring IDTR, GDTR, GS Base and FS Base</strong></span><a href="#restoring-idtr-gdtr-gs-base-and-fs-base" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>One of the things that we didn’t have in the previous parts was that we didn’t restore the IDTR, GDTR, GS Base, and FS Base when we want to turn off the hypervisor. We should reset GDTR/IDTR when you do vmxoff, or PatchGuard will detect them left modified.</p><p>In order to restore them, before executing vmxoff in each core, the following function is called and it takes care of everything that should be restored to avoid PatchGuard errors.</p><p>It read <strong>GUEST_GS_BASE</strong> and <strong>GUEST_FS_BASE</strong> from VMCS and write to restore them with WRMSR and also restore the <strong>GUEST_GDTR_BASE</strong>, <strong>GUEST_GDTR_LIMIT</strong>, and <strong>GUEST_IDTR_BASE</strong>, <strong>GUEST_IDTR_LIMIT</strong> using <strong>lgdt</strong> and <strong>lidt</strong> instructions.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="n">VOID</span> <span class="nf">HvRestoreRegisters</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ULONG64</span> <span class="n">FsBase</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">GsBase</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">GdtrBase</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">GdtrLimit</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">IdtrBase</span><span class="p">;</span>
	<span class="n">ULONG64</span> <span class="n">IdtrLimit</span><span class="p">;</span>

	<span class="c1">// Restore FS Base </span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FsBase</span><span class="p">);</span>
	<span class="n">__writemsr</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">,</span> <span class="n">FsBase</span><span class="p">);</span>

	<span class="c1">// Restore Gs Base</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GsBase</span><span class="p">);</span>
	<span class="n">__writemsr</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">,</span> <span class="n">GsBase</span><span class="p">);</span>

	<span class="c1">// Restore GDTR</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GdtrBase</span><span class="p">);</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GdtrLimit</span><span class="p">);</span>

	<span class="n">AsmReloadGdtr</span><span class="p">(</span><span class="n">GdtrBase</span><span class="p">,</span> <span class="n">GdtrLimit</span><span class="p">);</span>

	<span class="c1">// Restore IDTR</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">IdtrBase</span><span class="p">);</span>
	<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">IdtrLimit</span><span class="p">);</span>

	<span class="n">AsmReloadIdtr</span><span class="p">(</span><span class="n">IdtrBase</span><span class="p">,</span> <span class="n">IdtrLimit</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This is the assembly part to restore <strong>IDTR</strong> and <strong>GDTR</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="p">;</span><span class="o">------------------------------------------------------------------------</span>

<span class="p">;</span> <span class="n">AsmReloadGdtr</span> <span class="p">(</span><span class="n">PVOID</span> <span class="nf">GdtBase</span> <span class="p">(</span><span class="n">rcx</span><span class="p">),</span> <span class="n">ULONG</span> <span class="n">GdtLimit</span> <span class="p">(</span><span class="n">rdx</span><span class="p">)</span> <span class="p">);</span>

<span class="n">AsmReloadGdtr</span> <span class="n">PROC</span>
	<span class="n">push</span>	<span class="n">rcx</span>
	<span class="n">shl</span>		<span class="n">rdx</span><span class="p">,</span> <span class="mi">48</span>
	<span class="n">push</span>	<span class="n">rdx</span>
	<span class="n">lgdt</span>	<span class="n">fword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span>	<span class="p">;</span> <span class="k">do</span> <span class="n">not</span> <span class="n">try</span> <span class="n">to</span> <span class="n">modify</span> <span class="n">stack</span> <span class="n">selector</span> <span class="n">with</span> <span class="n">this</span> <span class="p">;)</span>
	<span class="n">pop</span>		<span class="n">rax</span>
	<span class="n">pop</span>		<span class="n">rax</span>
	<span class="n">ret</span>
<span class="n">AsmReloadGdtr</span> <span class="n">ENDP</span>

<span class="p">;</span><span class="o">------------------------------------------------------------------------</span>

<span class="p">;</span> <span class="n">AsmReloadIdtr</span> <span class="p">(</span><span class="n">PVOID</span> <span class="nf">IdtBase</span> <span class="p">(</span><span class="n">rcx</span><span class="p">),</span> <span class="n">ULONG</span> <span class="n">IdtLimit</span> <span class="p">(</span><span class="n">rdx</span><span class="p">)</span> <span class="p">);</span>

<span class="n">AsmReloadIdtr</span> <span class="n">PROC</span>
	<span class="n">push</span>	<span class="n">rcx</span>
	<span class="n">shl</span>		<span class="n">rdx</span><span class="p">,</span> <span class="mi">48</span>
	<span class="n">push</span>	<span class="n">rdx</span>
	<span class="n">lidt</span>	<span class="n">fword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span>
	<span class="n">pop</span>		<span class="n">rax</span>
	<span class="n">pop</span>		<span class="n">rax</span>
	<span class="n">ret</span>
<span class="n">AsmReloadIdtr</span> <span class="n">ENDP</span>

<span class="p">;</span><span class="o">------------------------------------------------------------------------</span>
</pre></table></code></div></div><p>Also, it’s better to unset vmx-enable bit of cr4 after executing vmxoff on each core separately.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Now that VMX is OFF, we have to unset vmx-enable bit on cr4</span>
	<span class="n">__writecr4</span><span class="p">(</span><span class="n">__readcr4</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">X86_CR4_VMXE</span><span class="p">));</span>
</pre></table></code></div></div><h1 id="lets-test-it"><strong>Let’s Test it!</strong></h1><p>The code for our hypervisor is tested on bare-metal (physical machine), VMware’s nested virtualization and Hyper-V’s nested virtualization.</p><h2 id="view-wpp-tracing-messages"><span class="mr-2"><strong>View WPP Tracing Messages</strong></span><a href="#view-wpp-tracing-messages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>To test WPP Tracing you need an application for parsing messages, I use TraceView.</p><p>TraceView is located in the tools\&lt;<em>Platform</em>&gt; subdirectory of the Windows Driver Kit (WDK), where &lt;<em>Platform</em>&gt; represents the platform you are running the trace session on, for example, x86, x64, or arm64.</p><p>There are also other applications both GUI and Command-line for this purpose, you can see a list of some of these apps <a href="http://kernelpool.blogspot.com/2018/05/add-wpp-tracing-to-kernel-mode-windows.html">here</a>.</p><p>First, open the traceview (run as administrator), go to <strong>File-&gt; Create New Log Session</strong>, and use the .pdb file generated by visual studio. PDB file contains debugging information, and for WPP Tracing, they contain GUID and format of messages.</p><p><img data-src="../../assets/images/WPP-tracing-browse-pdb-file.png" alt="WPP Tracing Traceview" data-proofer-ignore></p><p>When you select your provider, then click Next.</p><p><img data-src="../../assets/images/WPP-tracing-providers.png" alt="WPP Tracing Selected Provider" data-proofer-ignore></p><p>Here you can configure what kind of messages you want to see, e.g you only want to see error messages.</p><p>The default configuration is to see all the messages.</p><p><img data-src="../../assets/images/WPP-tracing-log-session.png" alt="WPP Tracing Log Session" data-proofer-ignore></p><p>Finally, you’ll see the following results.</p><p><img data-src="../../assets/images/WPP-tracing-results.png" alt="WPP Traceview result" data-proofer-ignore></p><h2 id="how-to-test"><span class="mr-2"><strong>How to test?</strong></span><a href="#how-to-test" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now it’s time to see what we’ve done in this part !</p><p><strong><em>Note: None of the below tests are active by default, you have to uncomment specific lines to see results in your hypervisor!</em></strong></p><h2 id="event-injection--exception-bitmap-demo"><span class="mr-2"><strong>Event Injection &amp; Exception Bitmap Demo</strong></span><a href="#event-injection--exception-bitmap-demo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In order to test event injection and exception bitmap we have a scenario where we want to monitor each debug breakpoint that is triggered in a user-mode application.</p><p>For this, I debugged an application with <strong>Immunity Debugger</strong> and put a breakpoint on multiple addresses. We want to intercept each breakpoint from any applications.</p><p>First, uncomment the following line in Vmx.c .</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Set exception bitmap to hook division by zero (bit 1 of EXCEPTION_BITMAP)</span>
	 <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">EXCEPTION_BITMAP</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span> <span class="c1">// breakpoint 3nd bit</span>
</pre></table></code></div></div><p>This will cause a vm-exit on each execution of breakpoint exception using Exception Bitmap.</p><p>The following codes are responsible to handle the vm-exits for Exception Bitmap. We check to see what was the interrupt/exception that causes this vm-exit by <strong>VM_EXIT_INTR_INFO</strong> from VMCS. If it’s a SOFTWARE EXCEPTION and its a vector is BREAKPOINT then we’re sure that execution of an (int 3 or 0xcc) was the cause for this vm-exit.</p><p>Now, we create a log that shows a breakpoint that happened in <strong>GUEST_RIP</strong> then re-inject the breakpoint back to the guest (Event Injection). We have to re-inject it back to the guest because the event is canceled after this vm-exit, you can check it, just remove the <strong>EventInjectBreakpoint(),</strong> and your user-mode debugger will no longer work.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre>	<span class="k">case</span> <span class="n">EXIT_REASON_EXCEPTION_NMI</span><span class="p">:</span>
	<span class="p">{</span>
		<span class="cm">/*

		Exception or non-maskable interrupt (NMI). Either:
			1: Guest software caused an exception and the bit in the exception bitmap associated with exception’s vector was set to 1
			2: An NMI was delivered to the logical processor and the “NMI exiting” VM-execution control was 1.

		VM_EXIT_INTR_INFO shows the exit infromation about event that occured and causes this exit
		Don't forget to read VM_EXIT_INTR_ERROR_CODE in the case of re-injectiong event

		*/</span>

		<span class="c1">// read the exit reason</span>
		<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">InterruptExit</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">InterruptExit</span><span class="p">.</span><span class="n">InterruptionType</span> <span class="o">==</span> <span class="n">INTERRUPT_TYPE_SOFTWARE_EXCEPTION</span> <span class="o">&amp;&amp;</span> <span class="n">InterruptExit</span><span class="p">.</span><span class="n">Vector</span> <span class="o">==</span> <span class="n">EXCEPTION_VECTOR_BREAKPOINT</span><span class="p">)</span>
		<span class="p">{</span>

			<span class="n">ULONG64</span> <span class="n">GuestRip</span><span class="p">;</span>
			<span class="c1">// Reading guest's RIP </span>
			<span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestRip</span><span class="p">);</span>

			<span class="c1">// Send the user</span>
			<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Breakpoint Hit (Process Id : 0x%x) at : %llx "</span><span class="p">,</span> <span class="n">PsGetCurrentProcessId</span><span class="p">(),</span> <span class="n">GuestRip</span><span class="p">);</span>

			<span class="n">GuestState</span><span class="p">[</span><span class="n">CurrentProcessorIndex</span><span class="p">].</span><span class="n">IncrementRip</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

			<span class="c1">// re-inject #BP back to the guest</span>
			<span class="n">EventInjectBreakpoint</span><span class="p">();</span>

		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">LogError</span><span class="p">(</span><span class="s">"Not expected event occured"</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>To see the result as a gif, click the link below.</p><p><a href="../../assets/images/event-inject-and-exception-bitmap.gif">View Example as a .gif (event-inject-and-exception-bitmap.gif)</a></p><p><img data-src="../../assets/images/event-inject-and-exception-bitmap.png" alt="Event Injection &amp; Exception Bitmap Example" data-proofer-ignore></p><h2 id="hidden-hooks-demo"><span class="mr-2"><strong>Hidden Hooks Demo</strong></span><a href="#hidden-hooks-demo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hidden hooks are divided into two parts, The first part is for hidden hooks of Read/Write (It’s like simulating hardware debug registers without any limitation), and the second part is hidden hooks for execution which is an equivalent of invisible in-line hooks.</p><p>In order to activate the hidden hooks test, uncomment <strong>HiddenHooksTest()</strong> from <strong>Driver.c</strong> .</p><p>Note that you can simultaneously use Hidden Hooks for Read/Write, Execute or syscall hook, there is no limitation.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="c1">//////////// test //////////// </span>
	<span class="n">HiddenHooksTest</span><span class="p">();</span>
	<span class="c1">// SyscallHookTest();</span>
	<span class="c1">////////////////////////////// </span>
</pre></table></code></div></div><h2 id="readwrite-hooks-or-hardware-debug-registers-simulation"><span class="mr-2"><strong>Read/Write Hooks or Hardware Debug Registers Simulation</strong></span><a href="#readwrite-hooks-or-hardware-debug-registers-simulation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For testing read and write, uncomment the first line, now you’ll be notified in the case of any Read/Write from any locations to the current thread’s _ETHREAD structure (<strong>KeGetCurrentThread()</strong>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/* Make examples for testing hidden hooks */</span>
<span class="n">VOID</span> <span class="nf">HiddenHooksTest</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Hook Test</span>
		<span class="n">EptPageHook</span><span class="p">(</span><span class="n">KeGetCurrentThread</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
	<span class="c1">//	EptPageHook(ExAllocatePoolWithTag, ExAllocatePoolWithTagHook, (PVOID*)&amp;ExAllocatePoolWithTagOrig, FALSE, FALSE, TRUE);</span>

	<span class="c1">// Unhook Tests</span>
	<span class="c1">//HvPerformPageUnHookSinglePage(ExAllocatePoolWithTag);</span>
	<span class="c1">//HvPerformPageUnHookAllPages();</span>
	
<span class="p">}</span>
</pre></table></code></div></div><p>To see the result as a gif, click the link below.</p><p><a href="../../assets/images/hidden-hook-example-read-write.gif">View Example as a .gif (hidden-hook-example-read-write.gif)</a></p><p><img data-src="../../assets/images/hidden-hook-example-read-write.png" alt="Hidden Hooks (Read/Write)" data-proofer-ignore></p><p>Also, you can see the results in Windbg !</p><p><img data-src="../../assets/images/hidden-hook-example-read-write-2.png" alt="Hidden Hooks (Read/Write)" data-proofer-ignore></p><h2 id="hidden-execution-hook"><span class="mr-2"><strong>Hidden Execution Hook</strong></span><a href="#hidden-execution-hook" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The second scenario for hidden hooks is to inline hook the <strong>ExAllocatePoolWithTag</strong> function.</p><p>This is done by uncommenting the following line.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/* Make examples for testing hidden hooks */</span>
<span class="n">VOID</span> <span class="nf">HiddenHooksTest</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Hook Test</span>
	<span class="c1">//	EptPageHook(KeGetCurrentThread(), NULL, NULL, TRUE, TRUE, FALSE);</span>
		<span class="n">EptPageHook</span><span class="p">(</span><span class="n">ExAllocatePoolWithTag</span><span class="p">,</span> <span class="n">ExAllocatePoolWithTagHook</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ExAllocatePoolWithTagOrig</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

	<span class="c1">// Unhook Tests</span>
	<span class="c1">//HvPerformPageUnHookSinglePage(ExAllocatePoolWithTag);</span>
	<span class="c1">//HvPerformPageUnHookAllPages();</span>
	
<span class="p">}</span>
</pre></table></code></div></div><p>And also a simple fucntion that logs each <strong>ExAllocatePoolWithTag</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/* Hook function that HooksExAllocatePoolWithTag */</span>
<span class="n">PVOID</span> <span class="nf">ExAllocatePoolWithTagHook</span><span class="p">(</span>
	<span class="n">POOL_TYPE</span>	<span class="n">PoolType</span><span class="p">,</span>
	<span class="n">SIZE_T</span>      <span class="n">NumberOfBytes</span><span class="p">,</span>
	<span class="n">ULONG</span>       <span class="n">Tag</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">LogInfo</span><span class="p">(</span><span class="s">"ExAllocatePoolWithTag Called with : Tag = 0x%x , Number Of Bytes = %d , Pool Type = %d "</span><span class="p">,</span> <span class="n">Tag</span><span class="p">,</span> <span class="n">NumberOfBytes</span><span class="p">,</span> <span class="n">PoolType</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ExAllocatePoolWithTagOrig</span><span class="p">(</span><span class="n">PoolType</span><span class="p">,</span> <span class="n">NumberOfBytes</span><span class="p">,</span> <span class="n">Tag</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The hook is applied ! you can also try to use (<strong>u nt!ExAllocatePoolWithTag</strong>) and see there is no in-line hook there, so it’s <strong>completely hidden</strong> and of course PatchGuard compatible!</p><p>To see the result as a gif, click the link below.</p><p><a href="../../assets/images/hidden-hook-example-exec.gif">View Example as a .gif (hidden-hook-example-exec.gif)</a></p><p><img data-src="../../assets/images/hidden-hook-example-exec.png" alt="Hidden Hooks (Exec)" data-proofer-ignore></p><h2 id="syscall-hook-demo"><span class="mr-2"><strong>Syscall Hook Demo</strong></span><a href="#syscall-hook-demo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Our scenario for testing system-call hooks is first uncommenting the following line in <strong>Driver.c</strong> .</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="c1">//////////// test //////////// </span>
	<span class="c1">// HiddenHooksTest();</span>
	<span class="n">SyscallHookTest</span><span class="p">();</span>
	<span class="c1">////////////////////////////// </span>
</pre></table></code></div></div><p>The following function first searches for API Number 0x55 (on Windows 10 1909, 0x55 represents to <strong>NtCreateFile</strong> this is not true for all versions of Windows you have to find the correct API Number for <strong>NtCreateFile</strong> based on your Windows version, a full list of system-call numbers for Nt Table is <a href="https://j00ru.vexillium.org/syscalls/nt/64/">here</a> and for Win32k Table is <a href="https://j00ru.vexillium.org/syscalls/win32k/64/">here</a>).</p><p>After finding the address of <strong>NtCreateFile</strong> (Syscall number 0x55) we set a hidden hook on this address.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cm">/* Make examples for testing hidden hooks */</span>
<span class="n">VOID</span> <span class="nf">SyscallHookTest</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// Note that this syscall number is only valid for Windows 10 1909, you have to find the syscall number of NtCreateFile based on</span>
	<span class="c1">// Your Windows version, please visit https://j00ru.vexillium.org/syscalls/nt/64/ for finding NtCreateFile's Syscall number for your Windows.</span>
	
	<span class="n">INT32</span> <span class="n">ApiNumberOfNtCreateFile</span> <span class="o">=</span> <span class="mh">0x0055</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">ApiLocationFromSSDTOfNtCreateFile</span> <span class="o">=</span> <span class="n">SyscallHookGetFunctionAddress</span><span class="p">(</span><span class="n">ApiNumberOfNtCreateFile</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ApiLocationFromSSDTOfNtCreateFile</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LogError</span><span class="p">(</span><span class="s">"Error in finding base address."</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EptPageHook</span><span class="p">(</span><span class="n">ApiLocationFromSSDTOfNtCreateFile</span><span class="p">,</span> <span class="n">NtCreateFileHook</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NtCreateFileOrig</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"Hook appkied to address of API Number : 0x%x at %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ApiNumberOfNtCreateFile</span><span class="p">,</span> <span class="n">ApiLocationFromSSDTOfNtCreateFile</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>For handling in-line hook, the following function is used which creates a log based on the file name and finally calls the original <strong>NtCreateFile</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cm">/* Hook function that hooks NtCreateFile */</span>
<span class="n">NTSTATUS</span> <span class="nf">NtCreateFileHook</span><span class="p">(</span>
	<span class="n">PHANDLE</span>            <span class="n">FileHandle</span><span class="p">,</span>
	<span class="n">ACCESS_MASK</span>        <span class="n">DesiredAccess</span><span class="p">,</span>
	<span class="n">POBJECT_ATTRIBUTES</span> <span class="n">ObjectAttributes</span><span class="p">,</span>
	<span class="n">PIO_STATUS_BLOCK</span>   <span class="n">IoStatusBlock</span><span class="p">,</span>
	<span class="n">PLARGE_INTEGER</span>     <span class="n">AllocationSize</span><span class="p">,</span>
	<span class="n">ULONG</span>              <span class="n">FileAttributes</span><span class="p">,</span>
	<span class="n">ULONG</span>              <span class="n">ShareAccess</span><span class="p">,</span>
	<span class="n">ULONG</span>              <span class="n">CreateDisposition</span><span class="p">,</span>
	<span class="n">ULONG</span>              <span class="n">CreateOptions</span><span class="p">,</span>
	<span class="n">PVOID</span>              <span class="n">EaBuffer</span><span class="p">,</span>
	<span class="n">ULONG</span>              <span class="n">EaLength</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">HANDLE</span> <span class="n">kFileHandle</span><span class="p">;</span>
	<span class="n">NTSTATUS</span> <span class="n">ConvertStatus</span><span class="p">;</span>
	<span class="n">UNICODE_STRING</span> <span class="n">kObjectName</span><span class="p">;</span>
	<span class="n">ANSI_STRING</span> <span class="n">FileNameA</span><span class="p">;</span>

	<span class="n">kObjectName</span><span class="p">.</span><span class="n">Buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="kr">__try</span>
	<span class="p">{</span>

		<span class="n">ProbeForRead</span><span class="p">(</span><span class="n">FileHandle</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HANDLE</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ProbeForRead</span><span class="p">(</span><span class="n">ObjectAttributes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OBJECT_ATTRIBUTES</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ProbeForRead</span><span class="p">(</span><span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UNICODE_STRING</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ProbeForRead</span><span class="p">(</span><span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">kFileHandle</span> <span class="o">=</span> <span class="o">*</span><span class="n">FileHandle</span><span class="p">;</span>
		<span class="n">kObjectName</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">;</span>
		<span class="n">kObjectName</span><span class="p">.</span><span class="n">MaximumLength</span> <span class="o">=</span> <span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="o">-&gt;</span><span class="n">MaximumLength</span><span class="p">;</span>
		<span class="n">kObjectName</span><span class="p">.</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="n">kObjectName</span><span class="p">.</span><span class="n">MaximumLength</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">);</span>
		<span class="n">RtlCopyUnicodeString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kObjectName</span><span class="p">,</span> <span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="p">);</span>

		<span class="n">ConvertStatus</span> <span class="o">=</span> <span class="n">RtlUnicodeStringToAnsiString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">FileNameA</span><span class="p">,</span> <span class="n">ObjectAttributes</span><span class="o">-&gt;</span><span class="n">ObjectName</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="n">LogInfo</span><span class="p">(</span><span class="s">"NtCreateFile called for : %s"</span><span class="p">,</span> <span class="n">FileNameA</span><span class="p">.</span><span class="n">Buffer</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="kr">__except</span> <span class="p">(</span><span class="n">EXCEPTION_EXECUTE_HANDLER</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kObjectName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">kObjectName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="n">NtCreateFileOrig</span><span class="p">(</span><span class="n">FileHandle</span><span class="p">,</span> <span class="n">DesiredAccess</span><span class="p">,</span> <span class="n">ObjectAttributes</span><span class="p">,</span> <span class="n">IoStatusBlock</span><span class="p">,</span> <span class="n">AllocationSize</span><span class="p">,</span> <span class="n">FileAttributes</span><span class="p">,</span>
		<span class="n">ShareAccess</span><span class="p">,</span> <span class="n">CreateDisposition</span><span class="p">,</span> <span class="n">CreateOptions</span><span class="p">,</span> <span class="n">EaBuffer</span><span class="p">,</span> <span class="n">EaLength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To see the result as a gif, click the link below.</p><p><a href="../../assets/images/syscall-hook-example-1.gif">View Example as a .gif (syscall-hook-example-1.gif)</a></p><p><img data-src="../../assets/images/syscall-hook-example-2.png" alt="Syscall Hook" data-proofer-ignore></p><p>Also, you can see the results in Windbg !</p><p><img data-src="../../assets/images/syscall-hook-example-3.png" alt="Syscall Hook" data-proofer-ignore></p><h1 id="discussion"><strong>Discussion</strong></h1><p>It’s time to see the questions and discussions about this part, the discussion is usually about questions and experience about developing hypervisors. Thanks to <a href="https://twitter.com/PetrBenes">Petr</a> for making this part ready.</p><p><strong>1. What is the IRQL in VMX root-mode? Have you ever tried to use KeGetCurrentIrql() in the VMX root-mode and see the result? It returns the below results in the picture, different IRQLs.</strong></p><p><img data-src="../../assets/images/IRQL-in-vmx-root.png" alt="IRQL in VMX Root-Mode" data-proofer-ignore></p><p>- IRQL is nothing more than Cr8 register, Cr8 register doesn’t change when VM-exit occurs, therefore, your <strong>KeGetCurrentIrql()</strong> returns the IRQL before the VM-exit happened.</p><p>- In VM-root mode, there is “no IRQL”, because VMX doesn’t know such terms as IRQL (it’s Microsoft thingy) but practically speaking, HIGH_IRQL is what’s closest to the state in VMX-root mode because interrupts are disabled</p><p>- Actually, IRQL requirements don’t mean much when running in the VMM context. For example, even if you enter at <strong>PASSIVE_LEVEL</strong>, you are technically at <strong>HIGH_LEVEL</strong> for all intents and purposes, as interrupts are disabled. </p><p>- You can use <strong>KeGetEffectiveIrql()</strong> in VMX-root mode, and it always returns HIGH_LEVEL (that function checks if IF (Interrupt Flag) bit in EFLAGS is set and if not, it returns HIGH_LEVEL, if yes, then it returns the same value as <strong>KeGetCurrentIrql()</strong>. The EFLAGS.IF is cleared when VM-exit happened but the IF only affects hardware interrupt, and exceptions can still occur.</p><p>- If you still have a problem with understanding IRQL in VMM then there are some interesting questions answered by <a href="https://twitter.com/aionescu">Alex</a> in Hyperplatform: <a href="https://github.com/tandasat/HyperPlatform/issues/3#issuecomment-231804839">https://github.com/tandasat/HyperPlatform/issues/3#issuecomment-231804839</a> that tries to explain why vmx root-mode is like <strong>HIGH_IRQL</strong>. I try to add some explanation to them.</p><p><strong>2. Is it safe for you to be context switched by the OS while in the middle of VMM mode?</strong></p><p>- Of course not. So you are at least at <strong>DISPATCH_LEVEL</strong> (As Windows schedules all threads to run at IRQLs below <strong><em>DISPATCH_LEVEL</em></strong> ).</p><p><strong>3. Is it safe for you to “wait” on an object while at VMM mode?</strong></p><p>- Of course not, you would be context switched to another thread/idle thread which would now be running as VMM Host. (Means that you wait on some objects and when another vm-exit occurs, you’re no longer in the previous thread.)</p><p><strong>4. Is it safe/OK for you to receive DPCs while in the middle of VMM mode?</strong></p><p>- Again, of course not. Another reason why you are at least at <strong>DISPATCH_LEVEL</strong>.</p><p><strong>5. Could you receive a DPC, even if you wanted to?</strong></p><p>- Nope. Receiving a DPC requires an interrupt, and IF in r/eflags is off, so Local APIC will never deliver it.</p><p><strong>6. Will you receive any Device Interrupts?</strong></p><p>- Nope, because EFLAGS.IF is off.</p><p><strong>7. Would you want to be interrupted in the middle of VMM mode?</strong></p><p>- Also nope. So you are at least at <strong>MAX_DIRQL</strong>.</p><p><strong>8. Will you receive the clock interrupt?</strong></p><p>- Nope (also why you hit a CLOCK WATCHDOG BSOD sometimes)… So you are at least at <strong>CLOCK_LEVEL</strong>.</p><p><strong>9. Will you receive IPIs?</strong></p><p>- Nope, because IF is off, so Local APIC will never send them. You also probably don’t want to be running IPI while inside the VMM host… So you are at least at <strong>IPI_LEVEL</strong>. Technically because you are not in the middle of handling an IPI, but rather you’ve disabled interrupts completely, you are at <strong>IPI_LEVEL</strong> + 1, aka <strong>HIGH_LEVEL</strong>.</p><p><strong>10. Why ExAllocatePoolWithTag doesn’t work on Vmx root-mode?</strong></p><p>- In other words, if you call, for example, <strong>ExAllocatePoolWithTag</strong>, and this is PAGED POOL, you can get unlucky and this will require page-in which requires blocking your thread, and now, some other thread will run in VMM host mode… Sure, you can get lucky and control will come back to you, but this is insane… If you request NON-PAGED POOL, it will “appear to work”… And then in one situation, a TLB flush will be required, which sends an IPI… Which can’t be delivered… And so it will hang. etc.</p><p><strong>11. Is it ok that I used Insert DPC in VMX root-mode? I used KeInsertQueueDpc (because according to MSDN this function can be called at Any Level).</strong></p><p>- Yes and no. it’s okay when you have GUARANTEED that you won’t get conflicting VM-exit that would somehow result in a recursion/deadlock, but that very depends on the use case.</p><p>- For demonstration purposes, I wouldn’t mind using <strong>KeInsertQueueDpc</strong> in “real/production” environment, I would probably inject NMI from the hypervisor, and in NMI handler I would queue DPC.</p><p>- It’s one more indirection, therefore it’s going to be slightly slower, but I think it’s a generally safer way… (I use it this way) however, I must note that it’s not bulletproof, as I already ran into recursive NMI injection and deadlocks in NMI handler too.</p><p>- As I said, there’s no silver bullet, there always will be some dark corners when you try to communicate with the underlying OS.</p><p><strong>12. Using functions like RtlStringCchLengthA and RtlStringCchLengthA is not allowed because according to MSDN its IRQL is PASSIVE_LEVEL, so we can’t use them in VMX-Root mode? What should we do instead?</strong></p><p>- We can use <strong>sprintf (and sprintf like functions)</strong> from the C std library. it’s safe to use since it doesn’t allocate any memory. AFAIK <strong>RtlString*</strong> functions are in the PAGE section, therefore they can be paged out and if you call them from VMX-root mode when they’re paged out…. you know what happens ;)</p><p><strong>13. I was reading about VPID (INVVPID) and this seems to be unusable for hypervisors like hvpp and hyperplatform and ours? Am I right? I mean is there any special case in hypervisors that virtualize an already running system that INVVPID is preferred instead of INVEPT?</strong></p><p>- You are right, invvpid is generally useless in our cases. the only case I can think of where <strong>invvpid</strong> might be beneficial is in emulation of “<strong>invlpg</strong>” instruction, see <a href="https://github.com/wbenny/hvpp/blob/f1eece7d0def506f329b5770befd892497be2047/src/hvpp/hvpp/vmexit/vmexit_passthrough.cpp#L228">here</a>.</p><p>- Simply said, <strong>invept</strong> will invalidate ALL EPT mappings. with <strong>invvpid</strong>, you can invalidate <strong>SPECIFIC</strong> addresses in the guest (i.e. underlying OS). I think you know how caches generally work, but I’ll try to explain anyway: with <strong>invept</strong>, you lose all cache for the guest, therefore it will take time to fill that cache again (each first memory access after <strong>INVEPT</strong> will be slow).</p><p>- with <strong>invvpid</strong>, the cache is retained, but the only single address is invalidated, therefore loading of only THAT address will be slow with that said, I really can’t think of any other practical example where you’d need that, except the <strong>invlpg</strong> emulation mentioned above.</p><p><strong>14. What happens if we’re in vmx root and access an address that will cause an EPT violation?</strong></p><p>It’s like asking “what happens if we have paging disabled and access an address that will cause a page fault” EPTs are for guests, vmx-root is essentially host. EPT translation doesn’t happen when you’re in vmx root. Only regular paging. Therefore - it doesn’t matter if you access an address that will cause an EPT violation or not, what matters is whether is that address valid in vmx-root’s regular CR3 page tables.</p><p><strong>15. What if we want to cause vm-exit on exception/interrupts with IDT Index &gt; 32? Exception Bitmap is just a 32-bit field in VMCS!</strong></p><p>There are only 32 exceptions in x86 architecture. The rest are external-interrupts, which are intercepted by the pin-based control “<strong>external-interrupt exiting</strong>”. This means that you can’t select a special interrupt to cause a vm-exit, but you can configure pin-based control to cause vm-exit in the case of each interrupt.</p><p><strong>16. If several CPUs try to acquire the same spinlock at the same time, which CPU gets the spinlock first?</strong></p><p>- Normally, there is no order - the CPU with the fastest electrons wins :). The kernel does provide an alternative, called queued spinlocks that serve CPUs on a FIFO basis. These only work with IRQL DISPATCH_LEVEL. The relevant APIs are KeAcquireInStackQueuedSpinLock and KeReleaseInStackQueuedSpinLock. Check the WDK documentation for more details.</p><p><strong>17. We use DPCs to transfer messages, and because we may be executing in an arbitrary user-mode process as part DPCs, then why is our message tracing works without problem?</strong></p><p>- It works because we use <strong>METHOD_BUFFERED</strong> in our IOCTL. Generally, you have to specify that you need a buffered method in driver entry.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="c1">// Establish user-buffer access method.</span>
	<span class="n">DeviceObject</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">|=</span> <span class="n">DO_BUFFERED_IO</span><span class="p">;</span>
</pre></table></code></div></div><p>- But in the case of IOCTLs, you have specified this flag in IOCTL code, if you’re not familiar with <strong>METHOD_BUFFERED</strong>, it’s a way that Windows gives you a system-wide address which is valid in any process (kernel-mode) that’s why we can fill the buffer from any arbitrary process and address in <strong>Irp-&gt;AssociatedIrp.SystemBuffer</strong> in any process.</p><p>- Using <strong>METHOD_BUFFERED</strong> is, of course, slower, but it solves these kinds of problems and is it’s generally safer.</p><p><strong>18. Why we didn’t use APCs instead of DPCs in message tracing?</strong></p><p>- We can use APCs instead of DPCs in our case, but using DPCs gives us a better priority as the callback is executed in <strong>DISPATCH_LEVEL</strong> as soon as possible. APCs are thread-specific means that whenever a thread runs, we have the chance that our callback is executed while DPCs are processor-specific so we can interrupt any random process, so it’s faster.</p><p>- Another reason is APCs are undocumented kernel object while DPCs are documented so that’s the reason why programmers prefer to use DPCs.</p><h1 id="conclusion"><strong>Conclusion</strong></h1><p>We come to the end of this part, in this part we saw some important things that can be implemented with virtualizing an already running system like hidden hooks, syscall hook, event injection, exception bitmap, and our custom VMX Root compatible message tracing, by now you should be able to use your hypervisor driver in many kinds of researches and solve your reverse-engineering problems.</p><p>In the next part, we’ll look at some advanced virtualization topics like APIC Virtualization and lots of other things to make a stable and useful hypervisor.</p><p>Hope you guys enjoyed it, see you in the next part.</p><p><img data-src="../../assets/images/anime-girl-playing-guitar.png" alt="Aniiiime :)" data-proofer-ignore></p><h1 id="references"><strong>References</strong></h1><p>[1] Virtual Processor IDs and TLB - (<a href="http://www.jauu.net/2011/11/13/virtual-processor-ids-and-tlb/">http://www.jauu.net/2011/11/13/virtual-processor-ids-and-tlb/</a>)<br /> [2] INVVPID — Invalidate Translations Based on VPID - (<a href="https://www.felixcloutier.com/x86/invvpid">https://www.felixcloutier.com/x86/invvpid</a>)<br /> [3] INVPCID — Invalidate Process-Context Identifier - (<a href="https://www.felixcloutier.com/x86/invpcid">https://www.felixcloutier.com/x86/invpcid</a>)<br /> [4] Here’s how, and why, the Spectre and Meltdown patches will hurt performance - (<a href="https://arstechnica.com/gadgets/2018/01/heres-how-and-why-the-spectre-and-meltdown-patches-will-hurt-performance/">https://arstechnica.com/gadgets/2018/01/heres-how-and-why-the-spectre-and-meltdown-patches-will-hurt-performance/</a>)<br /> [5] Is vmxoff path really safe/correct? - (<a href="https://github.com/tandasat/HyperPlatform/issues/3">https://github.com/tandasat/HyperPlatform/issues/3</a>)<br /> [6] Day 5: The VM-Exit Handler, Event Injection, Context Modifications, And CPUID Emulation - (<a href="https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/">https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/</a>)<br /> [7] Test-and-set - (<a href="https://en.wikipedia.org/wiki/Test-and-set">https://en.wikipedia.org/wiki/Test-and-set</a>)<br /> [8] _interlockedbittestandset intrinsic functions - (<a href="https://docs.microsoft.com/en-us/cpp/intrinsics/interlockedbittestandset-intrinsic-functions?view=vs-2019">https://docs.microsoft.com/en-us/cpp/intrinsics/interlockedbittestandset-intrinsic-functions?view=vs-2019</a>)<br /> [9] Spinlocks and Read-Write Locks - (<a href="https://locklessinc.com/articles/locks/">https://locklessinc.com/articles/locks/</a>)<br /> [10] PAUSE - Spin Loop Hint - (<a href="https://locklessinc.com/articles/locks/"></a><a href="https://c9x.me/x86/html/file_module_x86_id_232.html">https://c9x.me/x86/html/file_module_x86_id_232.html</a>)<br /> [11] What is the purpose of the “PAUSE” instruction in x86? - (<a href="https://locklessinc.com/articles/locks/"></a><a href="https://stackoverflow.com/questions/12894078/what-is-the-purpose-of-the-pause-instruction-in-x86">https://stackoverflow.com/questions/12894078/what-is-the-purpose-of-the-pause-instruction-in-x86</a>)<br /> [12] How does x86 pause instruction work in spinlock <em>and</em> can it be used in other scenarios? - (<a href="https://stackoverflow.com/questions/4725676/how-does-x86-pause-instruction-work-in-spinlock-and-can-it-be-used-in-other-sc">https://stackoverflow.com/questions/4725676/how-does-x86-pause-instruction-work-in-spinlock-and-can-it-be-used-in-other-sc</a>)<br /> [13] Introduction to the volatile keyword - (<a href="https://www.embedded.com/introduction-to-the-volatile-keyword/">https://www.embedded.com/introduction-to-the-volatile-keyword/</a>)<br /> [14] Deferred Procedure Call - (<a href="https://www.embedded.com/introduction-to-the-volatile-keyword/"></a><a href="https://en.wikipedia.org/wiki/Deferred_Procedure_Call">https://en.wikipedia.org/wiki/Deferred_Procedure_Call</a>)<br /> [15] Reversing DPC: KeInsertQueueDpc - (<a href="https://www.embedded.com/introduction-to-the-volatile-keyword/"></a><a href="https://repnz.github.io/posts/practical-reverse-engineering/reversing-dpc-keinsertqueuedpc/">https://repnz.github.io/posts/practical-reverse-engineering/reversing-dpc-keinsertqueuedpc/</a>)<br /> [16] Dumping DPC Queues: Adventures in HIGH_LEVEL IRQL - (<a href="https://www.embedded.com/introduction-to-the-volatile-keyword/"></a><a href="https://repnz.github.io/posts/practical-reverse-engineering/dumping-dpc-queues/">https://repnz.github.io/posts/practical-reverse-engineering/dumping-dpc-queues/</a>)<br /> [17] Vol 3C – Chapter 31 – (31.5.1 Algorithms for Determining VMX Capabilities) – (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [18] Vol 3D – Appendix A.2 – (RESERVED CONTROLS AND DEFAULT SETTINGS) – (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)<br /> [19] Add WPP tracing to the Kernel Mode (Windows driver) – (<a href="https://software.intel.com/en-us/articles/intel-sdm"></a><a href="http://kernelpool.blogspot.com/2018/05/add-wpp-tracing-to-kernel-mode-windows.html">http://kernelpool.blogspot.com/2018/05/add-wpp-tracing-to-kernel-mode-windows.html</a>)<br /> [20] WPP Software Tracing – (<a href="https://software.intel.com/en-us/articles/intel-sdm"></a><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/wpp-software-tracing">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/wpp-software-tracing</a>)<br /> [21] TraceView – (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/traceview">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/traceview</a>)<br /> [22] What is the difference between Trap and Interrupt? – (<a href="https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt">https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt</a>)<br /> [23] How to disable Hyper-V in command line? – (<a href="https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt"></a><a href="https://stackoverflow.com/questions/30496116/how-to-disable-hyper-v-in-command-line">https://stackoverflow.com/questions/30496116/how-to-disable-hyper-v-in-command-line</a>)<br /> [24] Run Hyper-V in a Virtual Machine with Nested Virtualization – (<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/nested-virtualization">https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/nested-virtualization</a>)<br /> [25] Hypervisor Top-Level Functional Specification – (<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs">https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs</a>)<br /> [26] Requirements for Implementing the Microsoft Hypervisor Interface – (<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs">https://github.com/Microsoft/Virtualization-Documentation/raw/master/tlfs/Requirements%20for%20Implementing%20the%20Microsoft%20Hypervisor%20Interface.pdf</a>)<br /> [27] Simple Svm Hook Specification – (<a href="https://github.com/tandasat/SimpleSvmHook">https://github.com/tandasat/SimpleSvmHook</a>)<br /> [28] x86 calling conventions – (<a href="https://en.wikipedia.org/wiki/X86_calling_conventions"></a><a href="https://en.wikipedia.org/wiki/X86_calling_conventions">https://en.wikipedia.org/wiki/X86_calling_conventions</a>)<br /> [29] Exceptions – (<a href="https://wiki.osdev.org/Exceptions">https://wiki.osdev.org/Exceptions</a>)<br /> [30] Nt Syscall Table – (<a href="https://wiki.osdev.org/Exceptions"></a><a href="https://j00ru.vexillium.org/syscalls/nt/64/">https://j00ru.vexillium.org/syscalls/nt/64/</a>)<br /> [31] Win32k Syscall Table – (<a href="https://j00ru.vexillium.org/syscalls/win32k/64/">https://j00ru.vexillium.org/syscalls/win32k/64/</a>)<br /> [32] KVA Shadow: Mitigating Meltdown on Windows – (<a href="https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/">https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/</a>)<br /> [33] HyperBone - Minimalistic VT-X hypervisor with hooks – (<a href="https://msrc-blog.microsoft.com/2018/03/23/kva-shadow-mitigating-meltdown-on-windows/"></a><a href="https://github.com/DarthTon/HyperBone">https://github.com/DarthTon/HyperBone</a>)<br /> [34] Syscall Hooking Via Extended Feature Enable Register (EFER) – (<a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/</a>)<br /> [35] xdbg64’s TitanHide – (<a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/"></a><a href="https://github.com/dotfornet/TitanHide/">https://github.com/dotfornet/TitanHide/</a>)<br /> [36] System Service Descriptor Table - SSDT – (<a href="https://ired.team/miscellaneous-reversing-forensics/windows-kernel/glimpse-into-ssdt-in-windows-x64-kernel">https://ired.team/miscellaneous-reversing-forensics/windows-kernel/glimpse-into-ssdt-in-windows-x64-kernel</a>)<br /> [37] DdiMon – (<a href="https://ired.team/miscellaneous-reversing-forensics/windows-kernel/glimpse-into-ssdt-in-windows-x64-kernel"></a><a href="https://github.com/tandasat/DdiMon">https://github.com/tandasat/DdiMon</a>)<br /> [38] Gbhv - Simple x64 Hypervisor Framework – (<a href="https://ired.team/miscellaneous-reversing-forensics/windows-kernel/glimpse-into-ssdt-in-windows-x64-kernel"></a><a href="https://github.com/Gbps/gbhv">https://github.com/Gbps/gbhv</a>)<br /> [39] Hook SSDT(Shadow) – (<a href="https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/ssdt-hook">https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/ssdt-hook</a>)<br /> [40] DetourXS – (<a href="https://github.com/DominicTobias/detourxs">https://github.com/DominicTobias/detourxs</a>)<br /> [41] What is the difference between Trap and Interrupt? – (<a href="https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt">https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt</a>)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cpu/'>cpu</a>, <a href='/categories/hypervisor/'>hypervisor</a>, <a href='/categories/tutorials/'>tutorials</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hypervisor/" class="post-tag no-text-decoration" >hypervisor</a> <a href="/tags/event-injection/" class="post-tag no-text-decoration" >event-injection</a> <a href="/tags/hidden-hook/" class="post-tag no-text-decoration" >hidden-hook</a> <a href="/tags/high-irql-messaging/" class="post-tag no-text-decoration" >high-irql-messaging</a> <a href="/tags/hyper-v-compatible/" class="post-tag no-text-decoration" >hyper-v-compatible</a> <a href="/tags/hypervisor-on-hyper-v/" class="post-tag no-text-decoration" >hypervisor-on-hyper-v</a> <a href="/tags/hypervisor-part-8/" class="post-tag no-text-decoration" >hypervisor-part-8</a> <a href="/tags/inject-interrupt/" class="post-tag no-text-decoration" >inject-interrupt</a> <a href="/tags/invalidate-ept/" class="post-tag no-text-decoration" >invalidate-ept</a> <a href="/tags/invept/" class="post-tag no-text-decoration" >invept</a> <a href="/tags/invpcid/" class="post-tag no-text-decoration" >invpcid</a> <a href="/tags/invvpid/" class="post-tag no-text-decoration" >invvpid</a> <a href="/tags/syscall-hook/" class="post-tag no-text-decoration" >syscall-hook</a> <a href="/tags/system-call-hook/" class="post-tag no-text-decoration" >system-call-hook</a> <a href="/tags/vmfunc/" class="post-tag no-text-decoration" >vmfunc</a> <a href="/tags/vpid-in-hypervisor/" class="post-tag no-text-decoration" >vpid-in-hypervisor</a> <a href="/tags/wpp-tracing/" class="post-tag no-text-decoration" >wpp-tracing</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor! - Rayanfam Blog&amp;url=https://rayanfam.com/topics/hypervisor-from-scratch-part-8/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor! - Rayanfam Blog&amp;u=https://rayanfam.com/topics/hypervisor-from-scratch-part-8/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://rayanfam.com/topics/hypervisor-from-scratch-part-8/&amp;text=Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor! - Rayanfam Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/topics/hypervisor-from-scratch-part-1/">Hypervisor From Scratch - Part 1: Basic Concepts & Configure Testing Environment</a><li><a href="/topics/hypervisor-from-scratch-part-2/">Hypervisor From Scratch – Part 2: Entering VMX Operation</a><li><a href="/topics/hypervisor-from-scratch-part-5/">Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</a><li><a href="/topics/hypervisor-from-scratch-part-6/">Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</a><li><a href="/topics/hypervisor-from-scratch-part-7/">Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/topics/hypervisor-from-scratch-part-7/"><div class="card-body"> <em class="timeago small" data-ts="1579478400" > 2020-01-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-6/"><div class="card-body"> <em class="timeago small" data-ts="1551052800" > 2019-02-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-4/"><div class="card-body"> <em class="timeago small" data-ts="1538697600" > 2018-10-05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 4: Address Translation Using Extended Page Table (EPT)</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/topics/hypervisor-from-scratch-part-7/" class="btn btn-outline-primary" prompt="Older"><p>Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</p></a> <a href="/topics/hyperdbg-one-thousand-and-one-nights/" class="btn btn-outline-primary" prompt="Newer"><p>HyperDbg’s One Thousand and One Nights</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://rayanfam.com/topics/hypervisor-from-scratch-part-8/'; this.page.identifier = '/topics/hypervisor-from-scratch-part-8/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://rayanfam.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/rayanfam">Rayanfam Blog</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-P6M1BDG57Z"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-P6M1BDG57Z'); }); </script>
