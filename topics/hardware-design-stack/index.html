<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Building Silicon Dreams: An Adventure in Hardware Design" /><meta name="author" content="Sina Karvandi, Saleh Khalaj Monfared" /><meta property="og:locale" content="en" /><meta name="description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><meta property="og:description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><link rel="canonical" href="https://rayanfam.com/topics/hardware-design-stack/" /><meta property="og:url" content="https://rayanfam.com/topics/hardware-design-stack/" /><meta property="og:site_name" content="Rayanfam Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-10-07T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Building Silicon Dreams: An Adventure in Hardware Design" /><meta name="twitter:site" content="@Intel80x86" /><meta name="twitter:creator" content="@Sina Karvandi, Saleh Khalaj Monfared" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sina Karvandi, Saleh Khalaj Monfared"},"dateModified":"2023-10-08T09:16:09+00:00","datePublished":"2023-10-07T00:00:00+00:00","description":"We write about Windows Internals, Hypervisors, Linux, and Networks.","headline":"Building Silicon Dreams: An Adventure in Hardware Design","mainEntityOfPage":{"@type":"WebPage","@id":"https://rayanfam.com/topics/hardware-design-stack/"},"url":"https://rayanfam.com/topics/hardware-design-stack/"}</script><title>Building Silicon Dreams: An Adventure in Hardware Design | Rayanfam Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Rayanfam Blog"><meta name="application-name" content="Rayanfam Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/images/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Rayanfam Blog</a></div><div class="site-subtitle font-italic">An aggressive out-of-order, superscalar blog...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tutorials/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TUTORIALS</span> </a><li class="nav-item"> <a href="/tools/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TOOLS & SCRIPTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/rayanfam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Intel80x86" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sina','rayanfam.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Building Silicon Dreams: An Adventure in Hardware Design</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Building Silicon Dreams: An Adventure in Hardware Design</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Intel80x86">Sina Karvandi, Saleh Khalaj Monfared</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1696636800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2023-10-07 </em> </span> <span> Updated <em class="timeago" data-ts="1696756569" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2023-10-08 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8110 words"> <em>45 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="../../assets/images/hardware-design-stack.jpg" alt="" data-proofer-ignore></p><h2 id="story-time"><span class="mr-2">Story Time</span><a href="#story-time" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Exploring the internals of processors has long been a fascination of mine. After spending a lot of time experiencing different processor features like hypervisor and configuring different x86 MSRs, I was seeking to find a way of knowing how exactly these concepts and configurations are made and how they work on the silicon.</p><p>Initially, my knowledge of hardware design was limited to a basic understanding of VHDL and Verilog gained from a microarchitecture design class at university. However, I decided to investigate and go deeper into this field and acquire more knowledge, which I am now eager to share with you.</p><p>This article is neither a deep dive into the hardware design nor does it assume any prior knowledge of hardware design. Instead, it provides an overview of fundamental hardware design concepts, introduces the tools and devices used in the process, and aims to give you a foundational understanding of the hardware design industry.</p><p>My journey in hardware design started when I was looking to find the actual implementation of different processors. After that, I came around two major open-source RISC-V processors.</p><ul><li><a href="https://github.com/chipsalliance/rocket-chip">Rocket Chip Generator</a><li><a href="https://github.com/riscv-boom/riscv-boom">SonicBOOM: The Berkeley Out-of-Order Machine</a></ul><p>These projects are one of the best implementations of RISC-V architecture in which you can use the source code to modify the microarchitecture, add/modify/remove CPU instructions, and finally synthesize the generated Verilog codes into a Xilinx FPGA or if you’re a millionaire you can give your design to TSMC to fabricate it for you :)</p><p>For those who don’t know about RISC-V, it’s an architecture (just like x86 and AMD64) that mainly comes with RISC architecture. There are two fundamental architectures in computer design: 1) CISC and 2) RISC.</p><p>The primary distinction between Complex Instruction Set Computer (CISC) and Reduced Instruction Set Computer (RISC) architectures lies in their approach to instruction execution. CISC, exemplified by the x86 architecture, typically employs a large and varied instruction set, often with complex addressing modes, allowing a single instruction to perform multiple operations. In contrast, RISC architectures like ARM and RISC-V utilize a simplified instruction set with fixed-length instructions, focusing on streamlined, single-cycle instruction execution.</p><p>Based on these explanations, I think we can start our journey from the designing steps of a chip and finally synthesizing into an FPGA our making GDSII (more about it later) layouts.</p><p>Please bear in mind, as you read the rest of this article, it is written by someone with a primary background in OS security and low-level programming, rather than being an expert hardware designer. Furthermore, this article is not an in-depth exploration but rather a high-level overview that provides technical examples and explanations to elaborate on the concepts and distinctions. I would be happy to hear if you have any feedback, corrections, and discussion points. You can use the comments section below.</p><h2 id="table-of-contents"><span class="mr-2">Table of Contents</span><a href="#table-of-contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><strong>Story Time</strong><li><strong>Table of Contents</strong><li><strong>Introduction</strong><ul><li>Analog Signals/Protocols<li>Digital Signals/Protocols</ul><li><strong>Source Code</strong><li><strong>Moore’s Law &amp; Amdahl’s Law</strong><li><strong>Terms</strong><li><strong>Hardware Description Languages (SystemVerilog, Verilog, VHDL)</strong><li><strong>Generating Hardware Using Chisel</strong><li><strong>C/C++ in Hardware Design</strong><ul><li>Vitis HLS</ul><li><strong>Simulating Codes</strong><ul><li>Simulating HDL Code Using GTKWave or ModelSim<li>Testing Codes in Chisel<li>Testing HDL Codes Using Verilator</ul><li><strong>Synthesising HDL Codes</strong><ul><li>Programming Xilinx FPGAs Using Vivado<li>Vivado Netlists</ul><li><strong>The Memory</strong><ul><li>Distributed RAMs in FPGAs<li>Block RAM (BRAM) in FPGAs<ul><li>Static RAM (SRAM) in ASIC</ul></ul><li><strong>Elaborating ASIC Designs</strong><li><strong>Building Hardware Layout (GDSII)</strong><li><strong>Reverse Engineering Netlists</strong><li><strong>Conclusion</strong><li><strong>References</strong></ul><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Over the past decades, the silicon industry changed drastically reaching from 10 µm (1973) to 3 nm (2022). Shrinking chips offer advantages including increased performance, higher integration density, reduced power consumption, improved heat dissipation along economic advancements. These benefits will drive the technological companies to contribute to smaller, more powerful, and energy-efficient chips. However, it also brings challenges related to manufacturing complexity and fundamental physical limits as transistors approach atomic scales.</p><div class="table-wrapper"><table><thead><tr><th>Wavelength (µm)<th>10<th>6<th>3<th>1.5<th>1<th>0.8<th>0.6<th>0.35<th>0.25<th>0.18<th>0.13<th>0.09<th>0.065<th>0.045<th>0.032<th>0.022<th>0.014<th>0.01<th>0.007<th>0.005<th>0.003<th>0.002<tbody><tr><td>Year<td>1971<td>1974<td>1977<td>1981<td>1984<td>1987<td>1990<td>1993<td>1996<td>1999<td>2001<td>2003<td>2005<td>2007<td>2009<td>2012<td>2014<td>2016<td>2018<td>2020<td>2022<td>2024</table></div><p>However, there are technological limitations that prohibit the shrinking of the transistors (later will be discussed as Moore’s law).</p><p><img data-src="../../assets/images/moore1.jpg" alt="" data-proofer-ignore></p><p>Now, let’s see the hardware design from a broader view. <strong>Have you ever asked yourself why computers are 0’s and 1’s?</strong> There are plenty of scientific and engineering theories and concepts that describe why computers are using 0’s and 1’s (and using <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a>), but a very simple explanation is that the current technology of semiconductors works best with zero and one (high and low voltage) signals rather than analog signals. It’s always more efficient to use analog devices as long as we’re not concerned with errors! If it was not because of errors, then probably the current devices that rely on deterministic and correct results are all made of analog devices. If I don’t want to oversimplify things, I can say, that while it’s true that some functions can be efficiently performed using analog signals (e.g., audio and video processing), digital computing offers several advantages, including accuracy, precision, ease of replication, and error correction.</p><p>The same is true for digital/analog protocols. Usually, it’s more efficient to send data over analog signals as you can send data at higher bitrate and longer distances. But, <strong>why there are digital signals while analog is naturally better?</strong> Simple answer, because analog has errors and you cannot guarantee the data will be correct at both sender and receiver.</p><p>Here is a list of digital and analog protocols.</p><h3 id="analog-signalsprotocols"><span class="mr-2">Analog Signals/Protocols:</span><a href="#analog-signalsprotocols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>VGA (Video Graphics Array)<li>RCA (Radio Corporation of America)<li>XLR (External Line Return)<li>3.5mm Audio Jack<li>Component Video<li>Composite Video<li>S-Video (Separate Video)<li>HDMI (High-Definition Multimedia Interface)<li>DVI (Digital Visual Interface) - Some variants support analog signals.<li>VGA-to-HDMI Converters (Analog to Digital conversion)</ul><h3 id="digital-signalsprotocols"><span class="mr-2">Digital Signals/Protocols:</span><a href="#digital-signalsprotocols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>USB (Universal Serial Bus) [Usually]<li>SPI (Serial Peripheral Interface)<li>I2C (Inter-Integrated Circuit)<li>UART (Universal Asynchronous Receiver-Transmitter)<li>Ethernet (IEEE 802.3)<li>HDMI (High-Definition Multimedia Interface) - Also supports digital audio.<li>DisplayPort<li>PCIe (Peripheral Component Interconnect Express)<li>SATA (Serial ATA)<li>CAN (Controller Area Network)</ul><p>Having the above knowledge, let’s explore each step more comprehensively. The rest of this article covers how digital chips are designed at different levels and discusses different tools that are used at each step.</p><h2 id="source-code"><span class="mr-2">Source Code</span><a href="#source-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The full source code of the codes used in this blog post is available on GitHub : [<a href="https://github.com/SinaKarvandi/hardware-design-stack">https://github.com/SinaKarvandi/hardware-design-stack</a>]</p><h2 id="moores-law--amdahls-law"><span class="mr-2">Moore’s Law &amp; Amdahl’s Law</span><a href="#moores-law--amdahls-law" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>There are two important laws in computer architecture. One is Moore’s law and the other is Amdahl’s law.</p><p>Moore’s law is defined as, an observation (prediction) that the number of transistors on a microchip roughly doubles every two years, whereas its cost is halved over that same timeframe.</p><p>If you have studied computer science at the university, you probably saw that professors always use a slide about Moore’s Law, seeking to justify their lessons, and declare that Moore’s Law is no longer true! Thanks to <a href="https://twitter.com/Intel80x86/status/1705472216207642728">ivs</a> for mentioning that what they really mean is that the combination of <a href="https://en.wikipedia.org/wiki/Dennard_scaling">Dennard scaling</a> and Moore’s law isn’t true anymore. Moore’s law by itself is just fine.</p><p><img data-src="../../assets/images/moore2.jpg" alt="" data-proofer-ignore></p><p>Amdahl’s law on the other hand is a formula that gives the theoretical speedup in latency of the execution of a task at a fixed workload that can be expected of a system whose resources are improved. It states that “the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used”.</p><p>But why that is important? The fact that there are physical limitations and barriers to further expanding/shrinking transistors (both because of the power consumption and speed), makes it important to design effective and efficient hardware that is capable of performing the computation at a higher speed with less transistor consumption. As a simple example, there are multiple types of adders to perform the addition of two operands, and each of them is designed for particular purposes and is good to be used in specific operations like Ripple Carry Adder (RCA), Carry Look-Ahead Adder (CLA), Carry Save Adder (CSA), etc.</p><p>Okay, but how do the programmers describe these designs? The answer is, that they use HDL languages to describe the hardware at different levels.</p><h2 id="terms"><span class="mr-2">Terms</span><a href="#terms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Before exploring more hardware design concepts, let’s explain a few terms that we use in this article.</p><p><strong>FPGA (Field-Programmable Gate Array)</strong>: FPGAs are versatile hardware devices that can be customized by users after manufacturing, allowing them to reconfigure the chip’s functionality to suit specific tasks or applications.</p><p><strong>ASIC (Application-Specific Integrated Circuit)</strong>: ASICs are specialized integrated circuits designed for a particular application, often offering optimized performance and power efficiency, but they are not reprogrammable like FPGAs.</p><p><strong>RTL (Register-Transfer Level)</strong>: RTL is a hardware description language abstraction that represents the behavior of digital circuits at a level where data movement between registers and the associated logic operations are defined, making it a crucial step in designing hardware.</p><p><strong>Netlist</strong>: A netlist is a textual or graphical representation of a circuit’s components (gates, flip-flops, etc.) and their interconnections at a lower level than RTL but higher than physical implementation.</p><p><strong>Synthesis</strong>: Synthesis is the automated process of converting a high-level hardware description into a lower-level netlist for hardware implementation, optimizing for efficiency. A code that can make hardware is called a synthesizable code.</p><p><strong>AXI</strong>: The AXI (Advanced eXtensible Interface) protocol is a widely used high-performance, on-chip communication protocol designed for efficient data transfer and interconnection of IP (Intellectual Property) blocks in System-on-Chip (SoC) and FPGA designs.</p><h2 id="hardware-description-languages-systemverilog-verilog-vhdl"><span class="mr-2">Hardware Description Languages (SystemVerilog, Verilog, VHDL)</span><a href="#hardware-description-languages-systemverilog-verilog-vhdl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Almost all of the hardware designs (like CPUs, RAMs, GPUs, etc.) are (can be) programmed using HDL or Hardware Description Languages. <strong>The most amazing thing about HDL languages is that these languages allow you to write programs that do a simple task (AND, OR, XOR, etc.) in a very short and precise slice of time and you can achieve precise control over a multitude of tasks within a fraction of a second!</strong></p><p>For example, assume that you want to write a program that adds two operands. Generally in assembly, we use an instruction like <code class="language-c highlighter-rouge"><span class="n">ADD</span></code> and add a value to a register like <code class="language-c highlighter-rouge"><span class="n">ADD</span> <span class="n">RAX</span><span class="p">,</span> <span class="mh">0x55</span></code>. There are plenty of stages that a processor will follow from fetch and decoding to executing. But in the final step, the values will be added in a very short fraction of time using an adder in the arithmetic logic unit (ALU). Imagine you have a processor/FPGA with a 200 MHz clock cycle speed and each addition of an adder took one cycle to complete. Let’s look at a simple formula:</p><p>Number of Clock Cycles = Clock Frequency (Hz) * Time (seconds) Number of Clock Cycles = 200,000,000 Hz * 1 second = 200,000,000 cycles</p><p>From the above example, you can see that you would able to perform 200,000,000 additions in one second and you’re sure that it took only one second to complete! You can gain control of this very small and precise fraction of time (1/200,000,000 second) by using HDL programming languages.</p><p>There are three famous HDL programming languages: VHDL, Verilog, and SystemVerilog.</p><p>Let’s see a very simple example of a VHDL code that toggles a port to zero and one by each clock.</p><div class="language-vhdl highlighter-rouge"><div class="code-header"> <span data-label-text="Vhdl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">STD_LOGIC_1164</span><span class="o">.</span><span class="k">ALL</span><span class="p">;</span>

<span class="k">entity</span> <span class="n">Switch_Control</span> <span class="k">is</span>
    <span class="k">Port</span> <span class="p">(</span>
        <span class="n">clock</span>   <span class="p">:</span> <span class="k">in</span>  <span class="kt">STD_LOGIC</span><span class="p">;</span>       <span class="c1">-- clock input</span>
        <span class="n">switch</span>  <span class="p">:</span> <span class="k">out</span> <span class="kt">STD_LOGIC</span> <span class="p">:</span><span class="o">=</span> <span class="sc">'0'</span> <span class="c1">-- Initialize switch to OFF (logic low)</span>
    <span class="p">);</span>
<span class="k">end</span> <span class="n">Switch_Control</span><span class="p">;</span>

<span class="k">architecture</span> <span class="n">Behavioral</span> <span class="k">of</span> <span class="n">Switch_Control</span> <span class="k">is</span>
    <span class="k">signal</span> <span class="n">toggle</span> <span class="p">:</span> <span class="kt">STD_LOGIC</span> <span class="p">:</span><span class="o">=</span> <span class="sc">'0'</span><span class="p">;</span> <span class="c1">-- Signal for toggling the switch</span>
<span class="k">begin</span>
    <span class="k">process</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span>
    <span class="k">begin</span>
        <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="k">then</span>
            <span class="n">toggle</span> <span class="o">&lt;=</span> <span class="ow">not</span> <span class="n">toggle</span><span class="p">;</span> <span class="c1">-- Toggle the switch state on rising edge of the clock</span>
        <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">process</span><span class="p">;</span>

    <span class="n">switch</span> <span class="o">&lt;=</span> <span class="n">toggle</span><span class="p">;</span> <span class="c1">-- Assign the switch state to the output port</span>
<span class="k">end</span> <span class="n">Behavioral</span><span class="p">;</span>

</pre></table></code></div></div><p>The above VHDL code defines an input port “clock” and an output port “switch” and inside the architecture block, there’s a process sensitive to the rising edge of the “clock” signal. When the clock signal rises, the “toggle” signal is toggled (inverted).</p><p>The above code is also written in Verilog:</p><div class="language-verilog highlighter-rouge"><div class="code-header"> <span data-label-text="Verilog"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">module</span> <span class="n">Switch_Control</span> <span class="p">(</span>
    <span class="kt">input</span>  <span class="kt">wire</span> <span class="n">clock</span><span class="p">,</span>        <span class="c1">// Clock input</span>
    <span class="kt">output</span> <span class="kt">reg</span>  <span class="n">switch</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1">// Initialize switch to OFF (logic low)</span>
<span class="p">);</span>

<span class="kt">reg</span> <span class="n">toggle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Signal for toggling the switch</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">toggle</span> <span class="o">&lt;=</span> <span class="o">~</span><span class="n">toggle</span><span class="p">;</span> <span class="c1">// Toggle the switch state on rising edge of the clock</span>
<span class="k">end</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="n">toggle</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">switch</span> <span class="o">=</span> <span class="n">toggle</span><span class="p">;</span> <span class="c1">// Assign the switch state to the output port</span>
<span class="k">end</span>

<span class="k">endmodule</span>
</pre></table></code></div></div><p>This code defines a module named <code class="language-c highlighter-rouge"><span class="n">Switch_Control</span></code> with an input wire <code class="language-c highlighter-rouge"><span class="n">clock</span></code> and an output register <code class="language-c highlighter-rouge"><span class="k">switch</span></code> which is initialized to 0 (logic low). Inside the module, there’s a register named <code class="language-c highlighter-rouge"><span class="n">toggle</span></code> initialized to 0. Effectively, this Verilog module also creates a digital switch that toggles its state on each rising edge of the clock input, and the <code class="language-c highlighter-rouge"><span class="k">switch</span></code> output reflects this state.</p><p>The SystemVerilog’s syntax is also (more or less like Verilog) with a couple of <a href="https://www.geeksforgeeks.org/difference-between-verilog-and-systemverilog/">differences</a>. Actually, SystemVerilog extends Verilog by adding several new features and enhancements.</p><p>As you can see the above codes have one input and one output. The above code can be fabricated into a chip. The imaginary chip contains two pins, one for input and one for output. These pins can be made with different IC package types like DIP, SIP, etc. with <a href="https://news.skhynix.com/light-thin-short-and-small-the-development-of-semiconductor-packages/">different technologies</a>.</p><p><img data-src="../../assets/images/ic-packages.jpg" alt="IC packages" data-proofer-ignore></p><p>The problem with these HDL languages is that it’s so hard and frustrating to develop hardware with these languages. Even though these languages give the best control over every single part of the hardware, it can be really time-consuming to design simple hardware. Because of these reasons, hardware designers made other languages like Chisel, SystemC, and HLS that deal with higher-levels of abstractions which makes it possible to write less code; thus, speeding up and easing the development.</p><p>For now, we have a very basic understanding of HDL languages and how chips are digital chips are designed, now we can follow our journey to the next steps.</p><h2 id="generating-hardware-using-chisel"><span class="mr-2">Generating Hardware Using Chisel</span><a href="#generating-hardware-using-chisel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Personally, I have to admit that the <a href="https://www.chisel-lang.org/">Chisel language</a> is one of the most exciting languages that I’ve ever dealt with. I really love the way they engineered a functional programming language like <a href="https://en.wikipedia.org/wiki/Functional_programming">Scala</a> and made a hardware generator language. The <a href="https://github.com/chipsalliance/chisel">Constructing Hardware in a Scala Embedded Language (Chisel)</a> is an open-source hardware description language (HDL) used to describe digital electronics and circuits at the register-transfer level (RTL). Think of it as a language that creates Verilog (or SystemVerilog) codes from the Scala codes. Later you can use the generated Verilog files to synthesize and program FPGAs or fabricate them in ASIC designs.</p><p>Chisel adds hardware construction primitives to the Scala programming language, providing designers with the power of a modern programming language to write complex, parameterizable circuit generators that produce synthesizable Verilog.</p><p>There are plenty of <a href="https://github.com/chipsalliance/chisel#getting-started">resources</a> to start learning Chisel and it’s a large-scale project that is actively maintained by <a href="https://www.chipsalliance.org/">CHIPS Alliance</a> and it’s used for huge projects like <a href="https://github.com/chipsalliance/rocket-chip">Rocket Chip Generator</a>.</p><p>Let’s see a very simple example of a Chisel code:</p><div class="language-scala highlighter-rouge"><div class="code-header"> <span data-label-text="Scala"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.util.Counter</span>
<span class="k">import</span> <span class="nn">circt.stage.ChiselStage</span>

<span class="k">class</span> <span class="nc">Blinky</span><span class="o">(</span><span class="n">freq</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">startOn</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Module</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">led0</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">Bool</span><span class="o">())</span>
  <span class="o">})</span>
  <span class="c1">// Blink LED every second using Chisel built-in util.Counter</span>
  <span class="k">val</span> <span class="nv">led</span> <span class="k">=</span> <span class="nc">RegInit</span><span class="o">(</span><span class="nv">startOn</span><span class="o">.</span><span class="py">B</span><span class="o">)</span>
  <span class="nf">val</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">counterWrap</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Counter</span><span class="o">(</span><span class="nv">true</span><span class="o">.</span><span class="py">B</span><span class="o">,</span> <span class="n">freq</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="nf">when</span><span class="o">(</span><span class="n">counterWrap</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">led</span> <span class="o">:=</span> <span class="o">~</span><span class="n">led</span>
  <span class="o">}</span>
  <span class="nv">io</span><span class="o">.</span><span class="py">led0</span> <span class="o">:=</span> <span class="n">led</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="c1">// These lines generate the Verilog output</span>
  <span class="nf">println</span><span class="o">(</span>
    <span class="nv">ChiselStage</span><span class="o">.</span><span class="py">emitSystemVerilog</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">Blinky</span><span class="o">(</span><span class="mi">1000</span><span class="o">),</span>
      <span class="n">firtoolOpts</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">"-disable-all-randomization"</span><span class="o">,</span> <span class="s">"-strip-debug-info"</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></table></code></div></div><p>This Chisel code snippet is for a digital circuit that blinks an LED at a specified frequency. Defines a Chisel module named <code class="language-c highlighter-rouge"><span class="n">Blinky</span></code> with a parameter for the frequency and an optional parameter for the initial LED state. Inside the module, it declares an output port <code class="language-c highlighter-rouge"><span class="n">led0</span></code> of type Bool to drive an LED. The LED state is stored in a register named <code class="language-c highlighter-rouge"><span class="n">led</span></code> and initialized with the value provided in the <code class="language-c highlighter-rouge"><span class="n">startOn</span></code> parameter. When the counter wraps around, it toggles the <code class="language-c highlighter-rouge"><span class="n">led</span></code> state.</p><p><strong>In digital designs, the clock signal is the perception of time and it’s used for synchronizing different parts of the chips</strong>. As you can see in the above code, it’s a simple LED blinker and as you can see, there is an output signal named <code class="language-c highlighter-rouge"><span class="n">led0</span></code>. But did you notice that it didn’t specify any inputs? How can we make a blinker without knowing or being notified about the time (or more precisely without any perception of the clock signal)?</p><p>The answer to this question lies in the fact that in languages like Chisel, the clock signal is masked and handled by the Chisel and it’s not exported (revealed) to the hardware designer. In other words, the generated Verilog files from the above code actually contain the <code class="language-c highlighter-rouge"><span class="n">clock</span></code> signal (and a <code class="language-c highlighter-rouge"><span class="n">reset</span></code> signal). But it’s actually handled by the Chisel instead of the programmer. Let’s see the generated code from the above Chisel code.</p><div class="language-verilog highlighter-rouge"><div class="code-header"> <span data-label-text="Verilog"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">module</span> <span class="n">Blinky</span><span class="p">(</span>
  <span class="kt">input</span>  <span class="n">clock</span><span class="p">,</span>
         <span class="n">reset</span><span class="p">,</span>
  <span class="kt">output</span> <span class="n">io_led0</span>
<span class="p">);</span>

  <span class="kt">reg</span>       <span class="n">led</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">counterWrap_c_value</span><span class="p">;</span>
  <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">led</span> <span class="o">&lt;=</span> <span class="mh">1'h0</span><span class="p">;</span>
      <span class="n">counterWrap_c_value</span> <span class="o">&lt;=</span> <span class="mh">9'h0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span>
      <span class="k">automatic</span> <span class="kt">logic</span> <span class="n">counterWrap</span> <span class="o">=</span> <span class="n">counterWrap_c_value</span> <span class="o">==</span> <span class="mh">9'h1F3</span><span class="p">;</span>
      <span class="n">led</span> <span class="o">&lt;=</span> <span class="n">counterWrap</span> <span class="o">^</span> <span class="n">led</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">counterWrap</span><span class="p">)</span>
        <span class="n">counterWrap_c_value</span> <span class="o">&lt;=</span> <span class="mh">9'h0</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">counterWrap_c_value</span> <span class="o">&lt;=</span> <span class="n">counterWrap_c_value</span> <span class="o">+</span> <span class="mh">9'h1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span> <span class="c1">// always @(posedge)</span>
  <span class="k">assign</span> <span class="n">io_led0</span> <span class="o">=</span> <span class="n">led</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></table></code></div></div><p>As you can see, there is actually a <code class="language-c highlighter-rouge"><span class="n">clock</span></code> and a <code class="language-c highlighter-rouge"><span class="n">reset</span></code> signal in addition to the <code class="language-c highlighter-rouge"><span class="n">io_led0</span></code> output. Using Chisel, you have less control over the hardware compared to writing codes in Verilog or VHDL, but still, you have the benefit of using a high-level language like Scala (Java). Moreover, you have the ability to <a href="https://chipyard.readthedocs.io/en/stable/Customization/Incorporating-Verilog-Blocks.html">integrate Verilog codes into the Chisel</a> designs and write some parts of the codes in Chisel while using Verilog for remaining parts.</p><h2 id="cc-in-hardware-design"><span class="mr-2">C/C++ in Hardware Design</span><a href="#cc-in-hardware-design" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>When we talk about C/C++ in hardware design, we have to consider two different paradigms.</p><ol><li><p>The first approach is using C/C++ codes to program FPGA. Modern FPGAs like the Xilinx ZYNQ series come with two different units, the processing system (PS), and the FPGA programmable logic (PL). The PS part is usually an ARM processor that is connected directly to the PL parts (e.g., through <a href="https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface">AXI interface</a>). So, you can write specific C/C++ codes compile them for a regular ARM processor, and use it in the FPGA. Usually, it’s super hard if someone wants to implement all protocols (e.g., network protocols, etc.) using the PL part. In these cases, hardware programmers make PL designs that are mainly responsible for running the computational part of a program and finally send the results back to the ARM processor and this ARM processor is responsible for synchronizing or sending/receiving data over the network. You can think of a dozen of examples how this PS part might be useful once it’s connected to the PL part. If you’re interested in this topic, you can see this <a href="https://www.youtube.com/playlist?list=PLXHMvqUANAFOviU0J8HSp0E91lLJInzX1">tutorial</a> as it covers a lot of exciting applications of using PL and PS together.</p><li><p>The second approach is using C/C++ codes to design hardware or generate RTL codes. As an example, we can use Vitis HLS to generate RTL codes. High-level synthesis (HLS) is an automated design method. It starts with a high-level description of how a digital system should behave and then automatically generates the detailed hardware structure that makes that behavior possible at the register-transfer level.</p></ol><p><img data-src="../../assets/images/vitis-hls.jpg" alt="ModelSim" data-proofer-ignore></p><h3 id="vitis-hls"><span class="mr-2">Vitis HLS</span><a href="#vitis-hls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Let’s run a simple HLS example using Xilinx Vitis. Before that, here’s a top view of how HLS works:</p><p><img data-src="../../assets/images/vitis-hls-diagram.png" alt="Vitis HLS" data-proofer-ignore></p><p>For example, we run a simple AXI lite connection interface using HLS (from the Vitis example codes).</p><p><img data-src="../../assets/images/hls-testing.jpg" alt="Vitis HLS AXI lite" data-proofer-ignore></p><p>There are three main phases, <strong>C Synthesis</strong>, <strong>C/RTL Cosimulation</strong>, and <strong>Implementation</strong>. In the first phase, the Vitis synthesizer tries to interpret the C codes, after that, we can write codes for testing our design and finally, the RTL generated code (both in Verilog and VHDL format) is ready!</p><p>Here are the <a href="https://github.com/SinaKarvandi/hardware-design-stack/tree/main/HLS">generated/exported AXI lite codes</a> by Vitis HLS, and this is <a href="https://github.com/SinaKarvandi/hardware-design-stack/tree/main/HLS/hdl/vhdl">VHDL files</a> and <a href="https://github.com/SinaKarvandi/hardware-design-stack/tree/main/HLS/hdl/verilog">Verilog files</a> of our design.</p><h2 id="simulating-codes"><span class="mr-2">Simulating Codes</span><a href="#simulating-codes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Once you finished writing your HDL codes or generating HDL codes from the Chisel (Scala) generator, it’s time to test the code using a simulator. The simulator works like a debugger and it’s an environment to simulate the hardware behavior to test whether the designed logic works properly or contains error. First, let’s simulate HDL codes.</p><h3 id="simulating-hdl-code-using-gtkwave-or-modelsim"><span class="mr-2">Simulating HDL Code Using GTKWave or ModelSim</span><a href="#simulating-hdl-code-using-gtkwave-or-modelsim" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>For simulating and testing VHDL and Verilog codes, we need to write a testbench. A testbench in Verilog, or VHDL is a file that is used exclusively for simulation, it’s a piece of non-synthesizable code that tries to simulate signals (input/output) to the designed logic, so you can see how your design behaves on different signals and inputs and what would be the final output.</p><p>For example, for the above toggle VHDL code, we write the following testbench:</p><div class="language-vhdl highlighter-rouge"><div class="code-header"> <span data-label-text="Vhdl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">STD_LOGIC_1164</span><span class="o">.</span><span class="k">ALL</span><span class="p">;</span>
<span class="k">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">STD_LOGIC_ARITH</span><span class="o">.</span><span class="k">ALL</span><span class="p">;</span>
<span class="k">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">STD_LOGIC_UNSIGNED</span><span class="o">.</span><span class="k">ALL</span><span class="p">;</span>

<span class="k">entity</span> <span class="n">Switch_Control_tb</span> <span class="k">is</span>
<span class="k">end</span> <span class="n">Switch_Control_tb</span><span class="p">;</span>

<span class="k">architecture</span> <span class="n">testbench</span> <span class="k">of</span> <span class="n">Switch_Control_tb</span> <span class="k">is</span>
    <span class="c1">-- Signals for testbench</span>
    <span class="k">signal</span> <span class="n">clock_tb</span>  <span class="p">:</span> <span class="kt">STD_LOGIC</span> <span class="p">:</span><span class="o">=</span> <span class="sc">'0'</span><span class="p">;</span> <span class="c1">-- Testbench clock signal</span>
    <span class="k">signal</span> <span class="n">switch_tb</span> <span class="p">:</span> <span class="kt">STD_LOGIC</span><span class="p">;</span>        <span class="c1">-- Testbench switch signal</span>

<span class="k">begin</span>
    <span class="c1">-- Instantiate the Switch_Control DUT</span>
    <span class="n">DUT</span><span class="p">:</span> <span class="k">entity</span> <span class="n">work</span><span class="o">.</span><span class="n">Switch_Control</span>
        <span class="k">port</span> <span class="k">map</span> <span class="p">(</span>
            <span class="n">clock</span>   <span class="o">=&gt;</span> <span class="n">clock_tb</span><span class="p">,</span>
            <span class="n">switch</span>  <span class="o">=&gt;</span> <span class="n">switch_tb</span>
        <span class="p">);</span>

    <span class="c1">-- Clock generation process (generates a clock signal)</span>
    <span class="k">process</span>
    <span class="k">begin</span>
        <span class="k">while</span> <span class="nb">true</span> <span class="k">loop</span>
            <span class="n">clock_tb</span> <span class="o">&lt;=</span> <span class="ow">not</span> <span class="n">clock_tb</span><span class="p">;</span> <span class="c1">-- Toggle the clock</span>
            <span class="k">wait</span> <span class="k">for</span> <span class="mi">5</span> <span class="n">ns</span><span class="p">;</span>            <span class="c1">-- Clock period (adjust as needed)</span>
        <span class="k">end</span> <span class="k">loop</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">process</span><span class="p">;</span>

<span class="k">end</span> <span class="n">testbench</span><span class="p">;</span>
</pre></table></code></div></div><p>This VHDL testbench creates a clock signal and connects it to the <code class="language-c highlighter-rouge"><span class="n">Switch_Control</span></code> while monitoring the output signal <code class="language-c highlighter-rouge"><span class="n">switch_tb</span></code> to observe the behavior of the chip during simulation.</p><p>The Verilog version of the testbench is available <a href="https://github.com/SinaKarvandi/hardware-design-stack/blob/main/Verilog/tb_toggle.v">here</a>.</p><p>Now it’s time to test our testbench.</p><p>Probably the most famous tool for testing HDL codes is <a href="https://www.intel.com/content/www/us/en/software-kit/750368/modelsim-intel-fpgas-standard-edition-software-version-18-1.html">ModelSim</a>. There are also other tools like internal Vivado simulator (previously named isim) or GTKWave but in my opinion, ModelSim is better as it offers more functionalities along with a powerful scripting capability. Moreover, you don’t have to necessarily install Vivado to use ModelSim. You can just install ModelSim and test (simulate) your code.</p><p>The following picture is the simulation signal of the above testbench using ModelSim:</p><p><img data-src="../../assets/images/modelsim-wave.jpg" alt="ModelSim" data-proofer-ignore></p><p>And this is the simulation result of the Vivado’s internal simulator:</p><p><img data-src="../../assets/images/vivado-sim.jpg" alt="Vivado simulator" data-proofer-ignore></p><p>Keep in mind that, what you will see in the simulator environment might not necessarily behave the same once it is fabricated as a chip or is programmed into an FPGA, so there are different pre- and post-synthesis simulations plus plenty of other physical and electrical considerations that might affect the behavior of the circuit, but it usually reflects the correct behavior of what you can expect from a circuit and you can find possible design errors. By the way, it’s a program that simulates the circuit, not a physical circuit!</p><h3 id="testing-codes-in-chisel"><span class="mr-2">Testing Codes in Chisel</span><a href="#testing-codes-in-chisel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Chisel is based on Scala and as it’s a high-level programming language, it gives you unlimited power of testing and writing testbenches. For example, imagine you write a code that is designing an arithmetic unit for a processor. You can generate dozens of random numbers and statements, write some Scala (or even Java) codes to compute a formula or an expression, and then provide these random values to your designed circuit, and compare the output of your circuit with the results of the formula.</p><div class="language-scala highlighter-rouge"><div class="code-header"> <span data-label-text="Scala"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.util._</span>
<span class="k">import</span> <span class="nn">chiseltest._</span>
<span class="k">import</span> <span class="nn">org.scalatest.flatspec.AnyFlatSpec</span>
<span class="k">import</span> <span class="nn">scala.util.control.Breaks._</span>

<span class="k">class</span> <span class="nc">ToggleTest</span> <span class="k">extends</span> <span class="nc">AnyFlatSpec</span> <span class="k">with</span> <span class="nc">ChiselScalatestTester</span> <span class="o">{</span>
  <span class="s">"DUT"</span> <span class="n">should</span> <span class="s">"pass"</span> <span class="n">in</span> <span class="o">{</span>

    <span class="nf">test</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">Toggle</span><span class="o">(</span>
		<span class="c1">//</span>
		<span class="c1">// Arugments to parameterize the chisel designs</span>
		<span class="c1">//</span>
      <span class="o">)</span>
    <span class="o">)</span> <span class="o">{</span> <span class="n">dut</span> <span class="k">=&gt;</span>
	
      <span class="c1">// First, set an input called "start" to 0</span>
      <span class="nv">dut</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">start</span><span class="o">.</span><span class="py">poke</span><span class="o">(</span><span class="mf">0.</span><span class="n">U</span><span class="o">)</span>
	  
	  <span class="c1">// Run the circuit for one-clock</span>
      <span class="nv">dut</span><span class="o">.</span><span class="py">clock</span><span class="o">.</span><span class="py">step</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

      <span class="c1">// Perform the first test</span>
      <span class="k">val</span> <span class="nv">test1</span> <span class="k">=</span> <span class="nv">Integer</span><span class="o">.</span><span class="py">parseInt</span><span class="o">(</span><span class="nv">TestingSample</span><span class="o">.</span><span class="py">SampleFormulaFunctions</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="py">U</span>

      <span class="c1">// Set the start to 1</span>
      <span class="nv">dut</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">start</span><span class="o">.</span><span class="py">poke</span><span class="o">(</span><span class="mf">1.</span><span class="n">U</span><span class="o">)</span>

	  <span class="c1">// Set an input called "in1" to the test1 value</span>
      <span class="nv">dut</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">in1</span><span class="o">.</span><span class="py">poke</span><span class="o">(</span><span class="n">test1</span><span class="o">)</span>

	  <span class="c1">// Run the circuit for one-clock</span>
      <span class="nv">dut</span><span class="o">.</span><span class="py">clock</span><span class="o">.</span><span class="py">step</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

      <span class="c1">// Check the output from "out1" with a value like 0 </span>
      <span class="nf">if</span> <span class="o">(</span><span class="nv">dut</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">out1</span><span class="o">.</span><span class="py">peek</span><span class="o">().</span><span class="py">litValue</span><span class="o">.</span><span class="py">toInt</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">print</span><span class="o">(</span><span class="s">"[*] Successful\n"</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nf">print</span><span class="o">(</span><span class="s">"[x] NOT successful!\n"</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="c1">// Remove the start bit again (disable chip)</span>
      <span class="nv">dut</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">start</span><span class="o">.</span><span class="py">poke</span><span class="o">(</span><span class="mf">0.</span><span class="n">U</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>This is a Chisel testbench to test a Chisel circuit with specific input conditions and check the output to determine if the circuit behaves as expected.</p><p>Initially, the <code class="language-c highlighter-rouge"><span class="n">start</span></code> input is set to 0 using <code class="language-c highlighter-rouge"><span class="n">poke</span></code>. The circuit is advanced by one clock cycle using <code class="language-c highlighter-rouge"><span class="n">dut</span><span class="p">.</span><span class="n">clock</span><span class="p">.</span><span class="n">step</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code>. Then, a test value is calculated using a function named <code class="language-c highlighter-rouge"><span class="n">TestingSample</span><span class="p">.</span><span class="n">SampleFormulaFunctions</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></code> and converted to an integer. The <code class="language-c highlighter-rouge"><span class="n">start</span></code> input is set to 1 to enable the circuit. The <code class="language-c highlighter-rouge"><span class="n">in1</span></code> input is set to the previously calculated test value using <code class="language-c highlighter-rouge"><span class="n">poke</span></code>. The circuit is advanced by one clock cycle again. Finally, the output from <code class="language-c highlighter-rouge"><span class="n">out1</span></code> is checked. If it matches the expected value (0), it prints <code class="language-c highlighter-rouge"><span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="n">Successful</span></code>, otherwise <code class="language-c highlighter-rouge"><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="n">NOT</span> <span class="n">successful</span><span class="o">!</span></code>.</p><p>After that, you can run your test by using <a href="https://www.scala-sbt.org/">sbt</a>, and it will make a <code class="language-c highlighter-rouge"><span class="p">.</span><span class="n">vcd</span></code> file. The VCD file is passed as an input to the <a href="https://gtkwave.sourceforge.net/">GTKWave</a> and you can see different signals and what happens in each clock cycle and the final outputs. Of course, the results can be automatically tested with Scala but if you want to debug and find possible errors, you can see the signal waves.</p><p>If you want to use ModelSim with Chisel, I made an automated Python script to make necessary conversions between different formats and make Chisel results compatible with ModelSim, you can find it <a href="https://github.com/SinaKarvandi/hardware-design-stack/tree/main/Sim">here</a>, it also describes how you can use it.</p><h3 id="testing-hdl-codes-using-verilator"><span class="mr-2">Testing HDL Codes Using Verilator</span><a href="#testing-hdl-codes-using-verilator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Up until now, we have seen how to make HDL designs and we used Chisel to generate Verilog codes. We also see how we can test the HDL and Chisel codes. Now we encounter another problem and it’s speed. Testing complicated and big projects is time-consuming, we already wrote a very simple testbench but in reality, when we encounter a big project, it would take a lot of time to simulate a circuit. In order to solve this issue, hardware designers came across the idea of converting the simulation Verilog codes into C++ and compiling the simulation codes. Now, instead of interpreting codes and generating waves, everything was running directly in an executable binary file, you can assume it is like a Verilog code that is converted to C++ code but the generated C++ code is designed based on how integrated circuits work.</p><p><img data-src="../../assets/images/Verilator_logo.png" alt="Verilator" data-proofer-ignore></p><p>The tool that is responsible for this conversion is <a href="https://www.veripool.org/verilator/">Verilator</a> and this conversion is called “verilate”. It verilates the specified Verilog or SystemVerilog code by reading it, performing lint checks, and optionally inserting assertion checks and coverage-analysis points. It outputs single- or multithreaded .cpp and .h files, the “Verilated” code.</p><p>For the demonstration, I verilated the toggle code that we wrote previously, you can see the generated CPP files <a href="https://github.com/SinaKarvandi/hardware-design-stack/tree/main/Verilator">here</a>.</p><p>There is also a very good <a href="https://itsembedded.com/dhd/verilator_1/">tutorial</a> if you want to start learning verilator. You can also use Verilator <a href="https://github.com/freechipsproject/chisel-testers/blob/master/src/test/scala/verilator/Verilator.scala">directly</a> with Chisel codes.</p><p>Now that we test our designed logic, it’s time to either implement the codes in FPGAs or fabricate them into chips.</p><h2 id="synthesising-hdl-codes"><span class="mr-2">Synthesising HDL Codes</span><a href="#synthesising-hdl-codes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Once we successfully pass the tests and simulate logic, it’s time to synthesize codes. There are two major FPGA vendors that design and fabricate FPGAs <a href="https://www.xilinx.com/">Xilinx</a> (acquired by <a href="https://www.amd.com/">AMD</a>) and <a href="https://www.intel.com/content/www/us/en/products/programmable.html">Intel FPGAs</a> (previously Altera). These two giant companies provide different tools for programming their FPGAs. Altera made <a href="https://www.intel.com/content/www/us/en/products/details/fpga/development-tools/quartus-prime.html">Quartus</a> while Xilinx offers <a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>. In this blog post, we use Vivado as the main tool.</p><p>Usually, the designs that are made for FPGAs are different from the ASICs. For example, there are plenty of considerations that make a Verilog design FPGA-efficient or ASIC-efficient. Most of the time, those codes that are generated for FPGAs use FPGA components like Block RAM (more about it later) or use FPGA IPs that make the code only synthesizable for FPGAs. The same is also true about ASIC design. Some designs might not be suitable for FPGAs and need to be fabricated in ASIC chips.</p><h3 id="programming-xilinx-fpgas-using-vivado"><span class="mr-2">Programming Xilinx FPGAs Using Vivado</span><a href="#programming-xilinx-fpgas-using-vivado" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>We can use the <a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado Design Suite</a> to synthesize the Verilog code that we previously wrote and finally generate a bitstream file that can program an FPGA.</p><p><img data-src="../../assets/images/vivado-toggle-code.jpg" alt="Vivado toggle Verilog code" data-proofer-ignore></p><p>Another essential step for Vivado is I/O pin planning and we can connect the clock source to our design ports or connect I/O pins (e.g., a key, LED, AXI, SPI pins, etc.). It finally produces a design constraints file (XDC file) that will guide Vivado through routing the FPGA pins.</p><p><img data-src="../../assets/images/vivado-toggle-io-planning.jpg" alt="Vivado I/O planning" data-proofer-ignore></p><p>For example, this is an XDC file that is used for connecting clock signals as well as some VGA I/O ports to FPGA pins.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">set_property</span> <span class="n">PACKAGE_PIN</span> <span class="n">F22</span> <span class="p">[</span><span class="n">get_ports</span> <span class="n">reset</span><span class="p">]</span>
<span class="n">set_property</span> <span class="n">IOSTANDARD</span> <span class="n">LVCMOS33</span> <span class="p">[</span><span class="n">get_ports</span> <span class="n">sys_clock</span><span class="p">]</span>
<span class="n">set_property</span> <span class="n">PACKAGE_PIN</span> <span class="n">AB19</span> <span class="p">[</span><span class="n">get_ports</span> <span class="p">{</span><span class="n">VGA_B</span><span class="p">[</span><span class="mi">3</span><span class="p">]}]</span>
<span class="n">set_property</span> <span class="n">PACKAGE_PIN</span> <span class="n">AB20</span> <span class="p">[</span><span class="n">get_ports</span> <span class="p">{</span><span class="n">VGA_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]}]</span>
<span class="n">set_property</span> <span class="n">PACKAGE_PIN</span> <span class="n">Y20</span> <span class="p">[</span><span class="n">get_ports</span> <span class="p">{</span><span class="n">VGA_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]}]</span>
<span class="n">set_property</span> <span class="n">PACKAGE_PIN</span> <span class="n">Y21</span> <span class="p">[</span><span class="n">get_ports</span> <span class="p">{</span><span class="n">VGA_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]}]</span>
<span class="n">set_property</span> <span class="n">PACKAGE_PIN</span> <span class="n">AA21</span> <span class="p">[</span><span class="n">get_ports</span> <span class="p">{</span><span class="n">VGA_G</span><span class="p">[</span><span class="mi">3</span><span class="p">]}]</span>
<span class="p">...</span>
</pre></table></code></div></div><p>Finally, it elaborates the code, makes schematic files, and generates bitstreams. Here is the schematic view generated for our toggle example.</p><p><img data-src="../../assets/images/vivado-toggle-schematic.jpg" alt="Vivado schematic" data-proofer-ignore></p><p>The schematic file of the above design is available <a href="https://github.com/SinaKarvandi/hardware-design-stack/tree/main/Schematic">here</a>.</p><h3 id="vivado-netlists"><span class="mr-2">Vivado Netlists</span><a href="#vivado-netlists" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Before making the bitstream file needed for programming FPGA, the codes are converted to a lower abstraction level called <strong>netlist</strong> which is basically specific to the target FPGA components and contains the necessary components along with their interconnection to implement the actual designed logic and satisfy the design requirements.</p><p>For example, assume the very first examples (Verilog code) that we made for toggling switches. We could use the following TCL commands (Vivado command-line) to generate Verilog and VHDL functional simulation netlist:</p><p>For generating Verilog netlists:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">write_verilog</span> <span class="o">-</span><span class="n">mode</span> <span class="n">funcsim</span> <span class="n">Verilog_Netlist_Toggle</span><span class="p">.</span><span class="n">v</span>
</pre></table></code></div></div><p>For generating VHDL netlists:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">write_vhdl</span> <span class="o">-</span><span class="n">mode</span> <span class="n">funcsim</span> <span class="n">VHDL_Netlist_Toggle</span><span class="p">.</span><span class="n">vhd</span>
</pre></table></code></div></div><p>The final netlist is a new Verilog file (netlist file):</p><div class="language-verilog highlighter-rouge"><div class="code-header"> <span data-label-text="Verilog"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
</pre><td class="rouge-code"><pre><span class="c1">// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.</span>
<span class="c1">// --------------------------------------------------------------------------------</span>
<span class="c1">// Tool Version: Vivado v.2022.2 (win64) Build 3671981 Fri Oct 14 05:00:03 MDT 2022</span>
<span class="c1">// Date        : Thu Oct  5 21:13:49 2023</span>
<span class="c1">// Host        : DESKTOP-J3QO9T8 running 64-bit major release  (build 9200)</span>
<span class="c1">// Command     : write_verilog -mode funcsim Verilog_Netlist_Name.v</span>
<span class="c1">// Design      : Switch_Control</span>
<span class="c1">// Purpose     : This verilog netlist is a functional simulation representation of the design and should not be modified</span>
<span class="c1">//               or synthesized. This netlist cannot be used for SDF annotated simulation.</span>
<span class="c1">// Device      : xc7z020clg484-1</span>
<span class="c1">// --------------------------------------------------------------------------------</span>
<span class="cp">`timescale</span> <span class="mi">1</span> <span class="n">ps</span> <span class="o">/</span> <span class="mi">1</span> <span class="n">ps</span>

<span class="p">(</span><span class="o">*</span> <span class="n">NotValidForBitStream</span> <span class="o">*</span><span class="p">)</span>
<span class="k">module</span> <span class="n">Switch_Control</span>
   <span class="p">(</span><span class="n">clock</span><span class="p">,</span>
    <span class="n">switch</span><span class="p">);</span>
  <span class="kt">input</span> <span class="n">clock</span><span class="p">;</span>
  <span class="kt">output</span> <span class="n">switch</span><span class="p">;</span>

  <span class="kt">wire</span> <span class="n">clock</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="n">clock_IBUF</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="n">clock_IBUF_BUFG</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="n">p_0_in</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="n">switch</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="n">switch_OBUF</span><span class="p">;</span>

  <span class="n">BUFG</span> <span class="n">clock_IBUF_BUFG_inst</span>
       <span class="p">(.</span><span class="n">I</span><span class="p">(</span><span class="n">clock_IBUF</span><span class="p">),</span>
        <span class="p">.</span><span class="n">O</span><span class="p">(</span><span class="n">clock_IBUF_BUFG</span><span class="p">));</span>
  <span class="n">IBUF</span> <span class="p">#(</span>
    <span class="p">.</span><span class="n">CCIO_EN</span><span class="p">(</span><span class="s">"TRUE"</span><span class="p">))</span> 
    <span class="n">clock_IBUF_inst</span>
       <span class="p">(.</span><span class="n">I</span><span class="p">(</span><span class="n">clock</span><span class="p">),</span>
        <span class="p">.</span><span class="n">O</span><span class="p">(</span><span class="n">clock_IBUF</span><span class="p">));</span>
  <span class="n">OBUF</span> <span class="n">switch_OBUF_inst</span>
       <span class="p">(.</span><span class="n">I</span><span class="p">(</span><span class="n">switch_OBUF</span><span class="p">),</span>
        <span class="p">.</span><span class="n">O</span><span class="p">(</span><span class="n">switch</span><span class="p">));</span>
  <span class="n">LUT1</span> <span class="p">#(</span>
    <span class="p">.</span><span class="n">INIT</span><span class="p">(</span><span class="mh">2'h1</span><span class="p">))</span> 
    <span class="n">toggle_i_1</span>
       <span class="p">(.</span><span class="n">I0</span><span class="p">(</span><span class="n">switch_OBUF</span><span class="p">),</span>
        <span class="p">.</span><span class="n">O</span><span class="p">(</span><span class="n">p_0_in</span><span class="p">));</span>
  <span class="n">FDRE</span> <span class="p">#(</span>
    <span class="p">.</span><span class="n">INIT</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">))</span> 
    <span class="n">toggle_reg</span>
       <span class="p">(.</span><span class="n">C</span><span class="p">(</span><span class="n">clock_IBUF_BUFG</span><span class="p">),</span>
        <span class="p">.</span><span class="n">CE</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">D</span><span class="p">(</span><span class="n">p_0_in</span><span class="p">),</span>
        <span class="p">.</span><span class="n">Q</span><span class="p">(</span><span class="n">switch_OBUF</span><span class="p">),</span>
        <span class="p">.</span><span class="n">R</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">));</span>
<span class="k">endmodule</span>
<span class="cp">`ifndef</span> <span class="n">GLBL</span>
<span class="cp">`define</span> GLBL<span class="cp">
`timescale</span>  <span class="mi">1</span> <span class="n">ps</span> <span class="o">/</span> <span class="mi">1</span> <span class="n">ps</span>

<span class="k">module</span> <span class="n">glbl</span> <span class="p">();</span>

    <span class="k">parameter</span> <span class="n">ROC_WIDTH</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
    <span class="k">parameter</span> <span class="n">TOC_WIDTH</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">parameter</span> <span class="n">GRES_WIDTH</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
    <span class="k">parameter</span> <span class="n">GRES_START</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

<span class="c1">//--------   STARTUP Globals --------------</span>
    <span class="kt">wire</span> <span class="n">GSR</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">GTS</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">GWE</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">PRLD</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">GRESTORE</span><span class="p">;</span>
    <span class="kt">tri1</span> <span class="n">p_up_tmp</span><span class="p">;</span>
    <span class="kt">tri</span> <span class="p">(</span><span class="n">weak1</span><span class="p">,</span> <span class="kt">strong0</span><span class="p">)</span> <span class="n">PLL_LOCKG</span> <span class="o">=</span> <span class="n">p_up_tmp</span><span class="p">;</span>

    <span class="kt">wire</span> <span class="n">PROGB_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">CCLKO_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">FCSBO_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">DO_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">DI_GLBL</span><span class="p">;</span>
   
    <span class="kt">reg</span> <span class="n">GSR_int</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">GTS_int</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">PRLD_int</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">GRESTORE_int</span><span class="p">;</span>

<span class="c1">//--------   JTAG Globals --------------</span>
    <span class="kt">wire</span> <span class="n">JTAG_TDO_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">JTAG_TCK_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">JTAG_TDI_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">JTAG_TMS_GLBL</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="n">JTAG_TRST_GLBL</span><span class="p">;</span>

    <span class="kt">reg</span> <span class="n">JTAG_CAPTURE_GLBL</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_RESET_GLBL</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_SHIFT_GLBL</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_UPDATE_GLBL</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_RUNTEST_GLBL</span><span class="p">;</span>

    <span class="kt">reg</span> <span class="n">JTAG_SEL1_GLBL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_SEL2_GLBL</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_SEL3_GLBL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_SEL4_GLBL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">reg</span> <span class="n">JTAG_USER_TDO1_GLBL</span> <span class="o">=</span> <span class="mb">1'bz</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_USER_TDO2_GLBL</span> <span class="o">=</span> <span class="mb">1'bz</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_USER_TDO3_GLBL</span> <span class="o">=</span> <span class="mb">1'bz</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="n">JTAG_USER_TDO4_GLBL</span> <span class="o">=</span> <span class="mb">1'bz</span><span class="p">;</span>

    <span class="k">assign</span> <span class="p">(</span><span class="kt">strong1</span><span class="p">,</span> <span class="n">weak0</span><span class="p">)</span> <span class="n">GSR</span> <span class="o">=</span> <span class="n">GSR_int</span><span class="p">;</span>
    <span class="k">assign</span> <span class="p">(</span><span class="kt">strong1</span><span class="p">,</span> <span class="n">weak0</span><span class="p">)</span> <span class="n">GTS</span> <span class="o">=</span> <span class="n">GTS_int</span><span class="p">;</span>
    <span class="k">assign</span> <span class="p">(</span><span class="n">weak1</span><span class="p">,</span> <span class="n">weak0</span><span class="p">)</span> <span class="n">PRLD</span> <span class="o">=</span> <span class="n">PRLD_int</span><span class="p">;</span>
    <span class="k">assign</span> <span class="p">(</span><span class="kt">strong1</span><span class="p">,</span> <span class="n">weak0</span><span class="p">)</span> <span class="n">GRESTORE</span> <span class="o">=</span> <span class="n">GRESTORE_int</span><span class="p">;</span>

    <span class="k">initial</span> <span class="k">begin</span>
	<span class="n">GSR_int</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">PRLD_int</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="p">#(</span><span class="n">ROC_WIDTH</span><span class="p">)</span>
	<span class="n">GSR_int</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">PRLD_int</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">initial</span> <span class="k">begin</span>
	<span class="n">GTS_int</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="p">#(</span><span class="n">TOC_WIDTH</span><span class="p">)</span>
	<span class="n">GTS_int</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">initial</span> <span class="k">begin</span> 
	<span class="n">GRESTORE_int</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="p">#(</span><span class="n">GRES_START</span><span class="p">);</span>
	<span class="n">GRESTORE_int</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="p">#(</span><span class="n">GRES_WIDTH</span><span class="p">);</span>
	<span class="n">GRESTORE_int</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">end</span>

<span class="k">endmodule</span>
<span class="cp">`endif</span>

</pre></table></code></div></div><p>The generated netlist in VHDL format is also available <a href="https://github.com/SinaKarvandi/hardware-design-stack/blob/main/Netlists/VHDL_Netlist_Toggle.vhd">here</a>. As you can see, these generated HDL netlists are elaborated in different abstraction levels and it’s quite challenging to understand the intent of this code. Even though they’re basically the same as the codes that we wrote for toggling output and do the exact same operation, but this is the eventual code that will be programmed in the FPGA.</p><p>Fortunately, there are tools that can be used for reverse engineering netlists (more about it later).</p><h2 id="the-memory"><span class="mr-2">The Memory</span><a href="#the-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>One of the fundamental components of chips is Static Random Access Memory (SRAM). You probably saw that Intel processors with more cache are offered at higher prices. The reason for that is that they need to chain the different numbers of flip-flops to form the cache. These chains of flip-flops are SRAMs and can be accessed immediately without any waiting clocks.</p><p>Static RAM (SRAM) consists of flip-flops, a bistable circuit composed of four to six transistors. Once a flip-flop stores a bit, it keeps that value until the opposite value is stored in it. SRAM gives fast access to data (immediate), but it is physically relatively large. Even though SRAMs are perfect for designing memory, these components are relatively expensive. That’s why other types of RAMs (like DRAMs) are used in computers.</p><p>Now let’s talk about different types of memories used in FPGAs and ASIC design.</p><h3 id="distributed-rams-in-fpgas"><span class="mr-2">Distributed RAMs in FPGAs</span><a href="#distributed-rams-in-fpgas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>In FPGAs, there are Block RAMs (BRAMs) and distributed RAMs. Distributed RAM is made up of LUTs and is used when the size of memory is small. For instance, in your code, you have a memory with a depth of 64 and a word size of 32. This one will be inferred into Distributed RAM, not BRAM.</p><p>Let’s define a memory in VHDL:</p><div class="language-vhdl highlighter-rouge"><div class="code-header"> <span data-label-text="Vhdl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">ram_type</span> <span class="k">is</span> <span class="k">array</span> <span class="p">(</span><span class="mi">0</span> <span class="k">to</span> <span class="mi">3</span><span class="p">)</span> <span class="k">of</span> <span class="kt">STD_LOGIC_VECTOR</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">signal</span> <span class="n">ram</span><span class="p">:</span> <span class="n">ram_type</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="s1">"00000000"</span><span class="p">);</span>
</pre></table></code></div></div><p>The above code defines an array type with four elements, indexed from 0 to 3. Each element of this array is a <code class="language-c highlighter-rouge"><span class="n">STD_LOGIC_VECTOR</span></code> type, which represents an array of bits. In this case, each element is an 8-bit wide <code class="language-c highlighter-rouge"><span class="n">STD_LOGIC_VECTOR</span></code> (ranging from bit 7 to bit 0), effectively creating a 4x8-bit memory structure. The FPGA will infer it as a distributed RAM, not Block RAM (BRAM) because the size is relatively small.</p><h3 id="block-ram-bram-in-fpgas"><span class="mr-2">Block RAM (BRAM) in FPGAs</span><a href="#block-ram-bram-in-fpgas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Block RAM (or BRAM) stands for Block Random Access Memory and is used for storing large amounts of data inside of your FPGA. BRAMs are usually external or embedded chips in the FPGA. For example, the following chip is the external design (port map) of a 36-KB BRAM used in Xilinx FPGAs.</p><p><img data-src="../../assets/images/bram-36kb-xilinx.jpg" alt="36KB BRAM Xilinx" data-proofer-ignore></p><p>The delay for these BRAM components are 1-clock cycle means that if you want to access data bits in BRAMs, you have to request from the BRAM chip and it will be available at the rising edge of the next clock cycle.</p><p>Usually, FPGAs have different formats of codes for <strong>inferring</strong> Block RAMs. For example, the following Verilog code is used for inferring BRAMs in Xilinx FPGAs where you can initialize it with particular data bits specified in the file.</p><div class="language-verilog highlighter-rouge"><div class="code-header"> <span data-label-text="Verilog"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">module</span> <span class="n">rams_init_file</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">din</span><span class="p">,</span> <span class="n">dout</span><span class="p">);</span>
<span class="kt">input</span> <span class="n">clk</span><span class="p">;</span>
<span class="kt">input</span> <span class="n">we</span><span class="p">;</span>
<span class="kt">input</span> <span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>
<span class="kt">input</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">din</span><span class="p">;</span>
<span class="kt">output</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>

<span class="kt">reg</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">ram</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">63</span><span class="p">];</span>
<span class="kt">reg</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>

<span class="k">initial</span> <span class="k">begin</span>
    <span class="p">$</span><span class="nb">readmemb</span><span class="p">(</span><span class="s">"rams_init_file.data"</span><span class="p">,</span><span class="n">ram</span><span class="p">);</span>
<span class="k">end</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
    <span class="k">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">we</span><span class="p">)</span>
            <span class="n">ram</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">din</span><span class="p">;</span>
            <span class="n">dout</span> <span class="o">&lt;=</span> <span class="n">ram</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>
<span class="k">end</span> <span class="k">endmodule</span>
</pre></table></code></div></div><p>This Verilog module, <code class="language-c highlighter-rouge"><span class="n">rams_init_file</span></code>, represents a simple RAM with a read initialization from a memory file. It responds to clock edges and writes to enable signals to update and read data from its memory array. Once you use the above code in Vivado, it automatically infers Block RAM (BRAM).</p><p>You can even initialize it with custom values.</p><div class="language-vhdl highlighter-rouge"><div class="code-header"> <span data-label-text="Vhdl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">library</span> <span class="n">ieee</span><span class="p">;</span>
<span class="k">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="k">all</span><span class="p">;</span>

<span class="k">entity</span> <span class="n">rams_sp_rom</span> <span class="k">is</span>
<span class="k">port</span><span class="p">(</span>
    <span class="n">clk</span> <span class="p">:</span> <span class="k">in</span> <span class="kt">std_logic</span><span class="p">;</span>
    <span class="n">we</span> <span class="p">:</span> <span class="k">in</span> <span class="kt">std_logic</span><span class="p">;</span>
    <span class="n">addr</span> <span class="p">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">5</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">di</span> <span class="p">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">19</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">do</span> <span class="p">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">19</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">end</span> <span class="n">rams_sp_rom</span><span class="p">;</span>

<span class="k">architecture</span> <span class="n">syn</span> <span class="k">of</span> <span class="n">rams_sp_rom</span> <span class="k">is</span>
    <span class="k">type</span> <span class="n">ram_type</span> <span class="k">is</span> <span class="k">array</span> <span class="p">(</span><span class="mi">63</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="k">of</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">19</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">signal</span> <span class="n">RAM</span> <span class="p">:</span> <span class="n">ram_type</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="s1">X"0200A"</span><span class="p">,</span> <span class="s1">X"00300"</span><span class="p">,</span> <span class="s1">X"08101"</span><span class="p">,</span> <span class="s1">X"04000"</span><span class="p">,</span> <span class="s1">X"08601"</span><span class="p">,</span> <span class="s1">X"0233A"</span><span class="p">,</span>
                            <span class="s1">X"00300"</span><span class="p">,</span> <span class="s1">X"08602"</span><span class="p">,</span> <span class="s1">X"02310"</span><span class="p">,</span> <span class="s1">X"0203B"</span><span class="p">,</span> <span class="s1">X"08300"</span><span class="p">,</span> <span class="s1">X"04002"</span><span class="p">,</span>
                            <span class="s1">X"08201"</span><span class="p">,</span> <span class="s1">X"00500"</span><span class="p">,</span> <span class="s1">X"04001"</span><span class="p">,</span> <span class="s1">X"02500"</span><span class="p">,</span> <span class="s1">X"00340"</span><span class="p">,</span> <span class="s1">X"00241"</span><span class="p">,</span>
                            <span class="s1">X"04002"</span><span class="p">,</span> <span class="s1">X"08300"</span><span class="p">,</span> <span class="s1">X"08201"</span><span class="p">,</span> <span class="s1">X"00500"</span><span class="p">,</span> <span class="s1">X"08101"</span><span class="p">,</span> <span class="s1">X"00602"</span><span class="p">,</span>
                            <span class="s1">X"04003"</span><span class="p">,</span> <span class="s1">X"0241E"</span><span class="p">,</span> <span class="s1">X"00301"</span><span class="p">,</span> <span class="s1">X"00102"</span><span class="p">,</span> <span class="s1">X"02122"</span><span class="p">,</span> <span class="s1">X"02021"</span><span class="p">,</span>
                            <span class="s1">X"00301"</span><span class="p">,</span> <span class="s1">X"00102"</span><span class="p">,</span> <span class="s1">X"02222"</span><span class="p">,</span> <span class="s1">X"04001"</span><span class="p">,</span> <span class="s1">X"00342"</span><span class="p">,</span> <span class="s1">X"0232B"</span><span class="p">,</span>
                            <span class="s1">X"00900"</span><span class="p">,</span> <span class="s1">X"00302"</span><span class="p">,</span> <span class="s1">X"00102"</span><span class="p">,</span> <span class="s1">X"04002"</span><span class="p">,</span> <span class="s1">X"00900"</span><span class="p">,</span> <span class="s1">X"08201"</span><span class="p">,</span>
                            <span class="s1">X"02023"</span><span class="p">,</span> <span class="s1">X"00303"</span><span class="p">,</span> <span class="s1">X"02433"</span><span class="p">,</span> <span class="s1">X"00301"</span><span class="p">,</span> <span class="s1">X"04004"</span><span class="p">,</span> <span class="s1">X"00301"</span><span class="p">,</span>
                            <span class="s1">X"00102"</span><span class="p">,</span> <span class="s1">X"02137"</span><span class="p">,</span> <span class="s1">X"02036"</span><span class="p">,</span> <span class="s1">X"00301"</span><span class="p">,</span> <span class="s1">X"00102"</span><span class="p">,</span> <span class="s1">X"02237"</span><span class="p">,</span>
                            <span class="s1">X"04004"</span><span class="p">,</span> <span class="s1">X"00304"</span><span class="p">,</span> <span class="s1">X"04040"</span><span class="p">,</span> <span class="s1">X"02500"</span><span class="p">,</span> <span class="s1">X"02500"</span><span class="p">,</span> <span class="s1">X"02500"</span><span class="p">,</span>
                            <span class="s1">X"0030D"</span><span class="p">,</span> <span class="s1">X"02341"</span><span class="p">,</span> <span class="s1">X"08201"</span><span class="p">,</span> <span class="s1">X"0400D"</span><span class="p">);</span>
    <span class="k">begin</span>
        <span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span>
        <span class="k">begin</span>
            <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="k">then</span>
                <span class="k">if</span> <span class="n">we</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="k">then</span>
                    <span class="n">RAM</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">di</span><span class="p">;</span>
                <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
                <span class="n">do</span> <span class="o">&lt;=</span> <span class="n">RAM</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">(</span><span class="n">addr</span><span class="p">)));</span>
            <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
        <span class="k">end</span> <span class="k">process</span><span class="p">;</span>

<span class="k">end</span> <span class="n">syn</span><span class="p">;</span>
</pre></table></code></div></div><p>This Block RAM (BRAM) is a Verilog module called <code class="language-c highlighter-rouge"><span class="n">rams_sp_rom</span></code> representing a simple synchronous read-only memory (ROM) with a 64-entry memory array. It has a clock input <code class="language-c highlighter-rouge"><span class="n">clk</span></code>, write enable input <code class="language-c highlighter-rouge"><span class="n">we</span></code>, address input <code class="language-c highlighter-rouge"><span class="n">addr</span></code>, data input <code class="language-c highlighter-rouge"><span class="n">di</span></code>, and data output <code class="language-c highlighter-rouge"><span class="k">do</span></code>. On each rising clock edge, it either writes data to the ROM if <code class="language-c highlighter-rouge"><span class="n">we</span></code> is high or reads data from the ROM based on the provided address, updating the <code class="language-c highlighter-rouge"><span class="k">do</span></code> output accordingly. The memory content is initialized with preset values in the <code class="language-c highlighter-rouge"><span class="n">RAM</span></code> signal. Same as above, Vivado infers a BRAM for the above code.</p><p>As you can see, you can write HDL codes to READ/WRITE into the Block RAM memory. You can even create Read-Only Memory (ROM) by removing the modification (write) logic. Keep in mind that the logic of the Block RAM itself is also written with HDL codes, so it’s like using another HDL module with this difference that the Block RAMs are previously fabricated and physically available into the chips.</p><h3 id="static-ram-sram-in-asic"><span class="mr-2">Static RAM (SRAM) in ASIC</span><a href="#static-ram-sram-in-asic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is no Block RAM (BRAM) in ASIC designs. If you want to implement a block RAM (BRAM) into an ASIC chip, you have to implement it or use custom tools for creating and simulating RAMs. One of these tools is <a href="https://github.com/VLSIDA/OpenRAM/">OpenRAM</a>. OpenRAM is an open-source framework to create the layout, netlists, timing and power models, placement and routing models, and other views necessary to use SRAMs in ASIC design.</p><p>You can configure the OpenRAM and it will create different <a href="https://github.com/VLSIDA/OpenRAM/blob/stable/docs/source/basic_usage.md#output-files">outputs</a> from Verilog files to GDS files that can be used for fabricating SRAMs. Finally, it gives you the necessary files that are suitable for your custom technology (45 nm, 40 nm, etc.).</p><h2 id="elaborating-asic-designs"><span class="mr-2">Elaborating ASIC Designs</span><a href="#elaborating-asic-designs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Once the implementation of hardware (usually in HDL languages) is done, it’s time to use special tools to implement them into actual transistors. This task can be done with (usually commercial, expensive, and complicated) tools like Synopsys Design Compiler. These tools try to optimize designs for timing, area, power, and test and finally generate designs that can be fabricated and implemented into chips.</p><p>Other than the commercial tools, there are open-source equivalent tools like <a href="https://github.com/YosysHQ/yosys">Yosys</a> that are able to synthesize and design Verilog codes.</p><h2 id="building-hardware-layout-gdsii"><span class="mr-2">Building Hardware Layout (GDSII)</span><a href="#building-hardware-layout-gdsii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Once you’ve done designing your hardware, it’s time to make it ready for fabrication. This time, the GDSII format is used to create a layout available to be used and fabricated in the industry. GDSII is an industry-standard database file format that is used to exchange data on IC layout artwork. It is a binary file format representing planar geometric shapes, text labels, and other information about the layout in hierarchical form.</p><p>Once you created your final Verilog files, you can use different tools to create a standard GDSII format. As an example, the open-source <a href="https://github.com/The-OpenROAD-Project/OpenLane">OpenROAD-Project’s OpenLane</a> can be used that perform all ASIC implementation steps from RTL all the way down to GDSII.</p><p>As an example, I used the Blinky Verilog code that we generated by Chisel as an input for OpenLange and this is the picture of a chip that I made by using this project:</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 50% 50%'%3E%3C/svg%3E" data-src="https://rayanfam.com/assets/images/gds-II-blinky.jpg" alt="OpenLane generated image" width="50%" height="50%" data-proofer-ignore></p><p>If you want to zoom into the picture, the SVG version of this file is available <a href="../../assets/images/gds-II-blinky.svg">here</a>.</p><p>This was the last step and we explored our journey from HDL codes to creating hardware using GDSII. Of course, there are plenty of other steps and industry considerations at this point that should be done before making the actual chip, but I think you’ve got a very high-level idea of how chips are made.</p><p>Before wrapping up, let’s explore one more step, reverse engineering of netlists!</p><h2 id="reverse-engineering-netlists"><span class="mr-2">Reverse Engineering Netlists</span><a href="#reverse-engineering-netlists" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>If you remember from the previous sections where we explored the netlists of Vivado, you probably noticed that the netlists are mostly hard to understand. Fortunately, there are tools to help us with analyzing netlists and one of them is called <a href="https://github.com/emsec/hal">HAL</a> (or The Hardware Analyzer). As they mentioned in the git repo, their vision is that HAL becomes the hardware reverse-engineering equivalent of tools like IDA or Ghidra.</p><p>From the main descriptions: virtually all available research on netlist analysis operates on a graph-based representation of the netlist under inspection. At its core, HAL provides exactly that: A framework to parse netlists of arbitrary sources, e.g., FPGAs or ASICs, into a graph-based netlist representation and to provide the necessary built-in tools for traversal and analysis of the included gates and nets.</p><p><img data-src="../../assets/images/hal_screenshot.jpg" alt="HAL" data-proofer-ignore></p><p>We can use HAL to analyze the netlist codes generated by Vivado from the previous step. First, we need to <a href="https://github.com/emsec/hal/wiki/Building-HAL">build</a> HAL and then import the netlist file. As you can see, it visualizes the netlist view of the chips along with their input and output ports and shows the arithmetic logic behind each element (flip-flops, LUTs, Boolean Function) in the netlist. We could also use Python codes to further elaborate the netlist.</p><p><img data-src="../../assets/images/hal-toggle.jpg" alt="HAL" data-proofer-ignore></p><p>One other interesting feature of HAL is its <a href="https://github.com/emsec/hal/wiki/Netlist-Simulator-and-Waveform-Viewer">Netlist Simulator and Waveform Viewer</a>. This tool is also able to create automated waves for the target netlist and enables the reverse engineer to simulate selected parts of the netlist in a cycle-accurate fashion.</p><p><img data-src="../../assets/images/screenshot_waveform_viewer.jpg" alt="HAL waveviewer" data-proofer-ignore></p><p>Now, what if we don’t have access to the netlist files? Or if the netlist is too complex to be interpreted? Can we physically perform the reverse engineering tasks? The answer to this question is yes!</p><p>Sometimes even getting your hands on a netlist file is a hard task. In such cases, prior to reverse engineering the circuit’s netlist, an adversary will be needed to reproduce the internal netlist of the target IC. This has been a great challenge in terms of IP/IC cloning and piracy. Once the attacker gets his hand on an optical microscope, he can prepare depackaging the IC using corrosive chemicals, then delayering individual layers (metal, poly, or diffusion) using corrosive chemicals. Finally Imaging the top-view of each layer using an optical microscope or <a href="https://en.wikipedia.org/wiki/Scanning_electron_microscope">single electron microscope</a> (SEM). The image may contain metal routing, contacts, vias, and pins in that layer.</p><p><img data-src="../../assets/images/netlist-p3.jpg" alt="optical probing1" data-proofer-ignore> <img data-src="../../assets/images/netlist-p4.jpg" alt="optical probing2" data-proofer-ignore></p><p>Furthermore, annotation aligns and stitches the images of different layers could be carried out to extract gate-level netlist from the annotated images.</p><p>To mitigate such reverse engineering there have been a number of methods including <a href="https://dl.acm.org/doi/pdf/10.1145/2508859.2516656">gate camouflages</a>, dummy contacts, <a href="https://dl.acm.org/doi/pdf/10.1145/2228360.2228377">netlist obfuscation</a>, <a href="https://www.usenix.org/system/files/sec21-han-zhaokun.pdf">logic locking</a> and so on. Some methods are shown below:</p><p><img data-src="../../assets/images/netlist-p2.jpg" alt="dummy contact" data-proofer-ignore></p><p>Nevertheless, similar invasive methods like <a href="https://www.usenix.org/system/files/sec21-krachenfels.pdf">this</a> and <a href="https://ieeexplore.ieee.org/abstract/document/10179341">this</a> could be used to get information from the hardware imaging and eventually complete reverse engineering.</p><p><img data-src="../../assets/images/netlist-p1.jpg" alt="RE" data-proofer-ignore></p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>This was a very basic introduction to the digital and hardware design world and most of the introduced tools are either open-source or publicly available, however, you should keep in mind that most of the big computer maker companies probably have their own approaches to generating hardware along with their proprietary tools, so it might not reflect how the actual hardware is made in a big tech company but sure it will give you an idea of the capabilities of the hardware design and how these hardware devices can be made.</p><p>In wrapping up our exploration of hardware design, we’ve taken a journey into the world of silicon. From the incredible advancements driven by Moore’s Law to the high-level and low-level description of hardware chips using different languages like VHDL, Verilog, and Chisel, testing hardware descriptions using tools like ModelSim, Verilator, and making design layouts ready to be fabricated using OpenLane or programming FPGA’s using Vivado. Whether you’re a seasoned expert or a newcomer to the field, hardware design continues to be an awesome adventure, where innovation and curiosity work hand in hand to shape the future of computing.</p><p>I hope you enjoyed this blog post and I will try to make more content about chip design in the future. Make sure to use the comment section below to discuss this article and see you at the next blog posts!</p><h2 id="references"><span class="mr-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>[1] Jensen Huang Tells the Media That Moore’s Law is Dead (The featured image) - (<a href="https://www.techpowerup.com/299159/jensen-huang-tells-the-media-that-moores-law-is-dead">https://www.techpowerup.com/299159/jensen-huang-tells-the-media-that-moores-law-is-dead</a>)</p><p>[2] 3 nm process - (<a href="https://en.wikipedia.org/wiki/3_nm_process">https://en.wikipedia.org/wiki/3_nm_process</a>)</p><p>[3] Moore’s law - (<a href="https://en.wikipedia.org/wiki/Moore%27s_law">https://en.wikipedia.org/wiki/Moore%27s_law</a>)</p><p>[4] Amdahl’s law - (<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">https://en.wikipedia.org/wiki/Amdahl%27s_law</a>)</p><p>[5] Comparison among Different Adders - (<a href="https://www.iosrjournals.org/iosr-jvlsi/papers/vol5-issue6/Version-1/A05610106.pdf">https://www.iosrjournals.org/iosr-jvlsi/papers/vol5-issue6/Version-1/A05610106.pdf</a>)</p><p>[6] Difference between Verilog and SystemVerilog - (<a href="https://www.geeksforgeeks.org/difference-between-verilog-and-systemverilog/">https://www.geeksforgeeks.org/difference-between-verilog-and-systemverilog/</a>)</p><p>[7] Verilog Example Codes - (<a href="https://verificationguide.com/verilog-examples/">https://verificationguide.com/verilog-examples/</a>)</p><p>[8] “Light, Thin, Short and Small”, The Development of Semiconductor Packages - (<a href="https://news.skhynix.com/light-thin-short-and-small-the-development-of-semiconductor-packages/">https://news.skhynix.com/light-thin-short-and-small-the-development-of-semiconductor-packages/</a>)</p><p>[9] IC packages - (<a href="https://colegiogradual.com.br/pt/plastic-leaded-chip-carrier-plcc-pllc-dummy-component-rr-z1Qd8ysk">https://colegiogradual.com.br/pt/plastic-leaded-chip-carrier-plcc-pllc-dummy-component-rr-z1Qd8ysk</a>)</p><p>[10] OpenROAD-Project’s OpenLane - (<a href="https://github.com/The-OpenROAD-Project/OpenLane">https://github.com/The-OpenROAD-Project/OpenLane</a>)</p><p>[11] HAL – The Hardware Analyzer - (<a href="https://github.com/emsec/hal">https://github.com/emsec/hal</a>)</p><p>[12] An open-source static random access memory (SRAM) compiler - (<a href="https://github.com/VLSIDA/OpenRAM/">https://github.com/VLSIDA/OpenRAM/</a>)</p><p>[13] flip-flop - (<a href="https://www.britannica.com/technology/flip-flop">https://www.britannica.com/technology/flip-flop</a>)</p><p>[14] What is a Block RAM (BRAM) in an FPGA? Tutorial for beginners - (<a href="https://nandland.com/lesson-15-what-is-a-block-ram-bram/">https://nandland.com/lesson-15-what-is-a-block-ram-bram/</a>)</p><p>[15] Block RAM - (<a href="https://docs.xilinx.com/r/en-US/am007-versal-memory/Data-Flow">https://docs.xilinx.com/r/en-US/am007-versal-memory/Data-Flow</a>)</p><p>[16] Initializing Block RAM From an External Data File (VHDL) - (<a href="https://docs.xilinx.com/r/en-US/ug901-vivado-synthesis/Initializing-Block-RAM-From-an-External-Data-File-Verilog">https://docs.xilinx.com/r/en-US/ug901-vivado-synthesis/Initializing-Block-RAM-From-an-External-Data-File-Verilog</a>)</p><p>[17] OpenRAM results - (<a href="https://github.com/VLSIDA/OpenRAM/blob/stable/docs/source/results.md">https://github.com/VLSIDA/OpenRAM/blob/stable/docs/source/results.md</a>)</p><p>[18] Chisel: A Modern Hardware Design Language - (<a href="https://github.com/chipsalliance/chisel">https://github.com/chipsalliance/chisel</a>)</p><p>[19] 6.11. Incorporating Verilog Blocks - (<a href="https://chipyard.readthedocs.io/en/stable/Customization/Incorporating-Verilog-Blocks.html">https://chipyard.readthedocs.io/en/stable/Customization/Incorporating-Verilog-Blocks.html</a>)</p><p>[20] Design Compiler - (<a href="https://www.synopsys.com/implementation-and-signoff/rtl-synthesis-test/dc-ultra.html">https://www.synopsys.com/implementation-and-signoff/rtl-synthesis-test/dc-ultra.html</a>)</p><p>[21] Generating a Netlist - (<a href="https://docs.xilinx.com/r/en-US/ug900-vivado-logic-simulation/Working-with-Simulation-Sets">https://docs.xilinx.com/r/en-US/ug900-vivado-logic-simulation/Working-with-Simulation-Sets</a>)</p><p>[22] ModelSim-Intel FPGAs Standard Edition Software Version 18.1 - (<a href="https://www.intel.com/content/www/us/en/software-kit/750368/modelsim-intel-fpgas-standard-edition-software-version-18-1.html">https://www.intel.com/content/www/us/en/software-kit/750368/modelsim-intel-fpgas-standard-edition-software-version-18-1.html</a>)</p><p>[23] Netlist Simulator and Waveform Viewer - (<a href="https://github.com/emsec/hal/wiki/Netlist-Simulator-and-Waveform-Viewer">https://github.com/emsec/hal/wiki/Netlist-Simulator-and-Waveform-Viewer</a>)</p><p>[24] Writing Test Benches - (<a href="https://alchitry.com/writing-test-benches-verilog">https://alchitry.com/writing-test-benches-verilog</a>)</p><p>[25] chiseltest - (<a href="https://github.com/ucb-bar/chiseltest/blob/main/README.md">https://github.com/ucb-bar/chiseltest/blob/main/README.md</a>)</p><p>[26] Chisel3 Testing Cheat Sheet - (<a href="https://inst.eecs.berkeley.edu/~cs250/sp17/handouts/chisel-testercheatsheet.pdf">https://inst.eecs.berkeley.edu/~cs250/sp17/handouts/chisel-testercheatsheet.pdf</a>)</p><p>[27] Chisel Testing Intensive (Beginner Track) - Chisel Community Conference 2018 - (<a href="https://www.youtube.com/watch?v=yYosPQ9RI4I&amp;ab_channel=Chisel">https://www.youtube.com/watch?v=yYosPQ9RI4I&amp;ab_channel=Chisel</a>)</p><p>[28] Verilator, the fastest Verilog/SystemVerilog simulator - (<a href="https://www.veripool.org/verilator/">https://www.veripool.org/verilator/</a>)</p><p>[29] High-level synthesis - (<a href="https://en.wikipedia.org/wiki/High-level_synthesis">https://en.wikipedia.org/wiki/High-level_synthesis</a>)</p><p>[30] Vitis HLS - (<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-hls.html">https://www.xilinx.com/products/design-tools/vitis/vitis-hls.html</a>)</p><p>[31] <a href="https://www.usenix.org/system/files/sec21-krachenfels.pdf">Krachenfels, Thilo, et al. “Automatic Extraction of Secrets from the Transistor Jungle using {Laser-Assisted}{Side-Channel} Attacks.” 30th USENIX security symposium (USENIX security 21). 2021.</a></p><p>[32] <a href="https://ieeexplore.ieee.org/abstract/document/10179341">Puschner, Endres, et al. “Red Team vs. Blue Team: A Real-World Hardware Trojan Detection Case Study Across Four Modern CMOS Technology Generations.” 2023 IEEE Symposium on Security and Privacy (SP). IEEE, 2023.</a></p><p>[33] <a href="https://dl.acm.org/doi/pdf/10.1145/2508859.2516656">Rajendran, J., Sam, M., Sinanoglu, O. and Karri, R., 2013, November. Security analysis of integrated circuit camouflaging. In Proceedings of the 2013 ACM SIGSAC conference on Computer &amp; communications security (pp. 709-720)</a></p><p>[34] <a href="https://dl.acm.org/doi/pdf/10.1145/2228360.2228377">Rajendran, J., Pino, Y., Sinanoglu, O., &amp; Karri, R. (2012, June). Security analysis of logic obfuscation. In Proceedings of the 49th annual design automation conference (pp. 83-89)</a></p><p>[35] <a href="https://www.usenix.org/system/files/sec21-han-zhaokun.pdf">Han, Zhaokun, Muhammad Yasin, and Jeyavijayan JV Rajendran. “Does logic locking work with {EDA} tools?.” 30th USENIX Security Symposium (USENIX Security 21). 2021.</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/hardware/'>hardware</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hardware-design/" class="post-tag no-text-decoration" >hardware-design</a> <a href="/tags/hdl-languages/" class="post-tag no-text-decoration" >HDL-languages</a> <a href="/tags/chisel/" class="post-tag no-text-decoration" >chisel</a> <a href="/tags/hls/" class="post-tag no-text-decoration" >hls</a> <a href="/tags/vivado/" class="post-tag no-text-decoration" >vivado</a> <a href="/tags/vitis/" class="post-tag no-text-decoration" >vitis</a> <a href="/tags/netlist/" class="post-tag no-text-decoration" >netlist</a> <a href="/tags/reversing-netlist/" class="post-tag no-text-decoration" >reversing-netlist</a> <a href="/tags/openlane/" class="post-tag no-text-decoration" >OpenLane</a> <a href="/tags/openram/" class="post-tag no-text-decoration" >OpenRAM</a> <a href="/tags/gdsii/" class="post-tag no-text-decoration" >GDSII</a> <a href="/tags/block-ram/" class="post-tag no-text-decoration" >Block-RAM</a> <a href="/tags/verilog/" class="post-tag no-text-decoration" >Verilog</a> <a href="/tags/vhdl/" class="post-tag no-text-decoration" >VHDL</a> <a href="/tags/modelsim/" class="post-tag no-text-decoration" >ModelSim</a> <a href="/tags/gtkwave/" class="post-tag no-text-decoration" >GTKWave</a> <a href="/tags/verilator/" class="post-tag no-text-decoration" >Verilator</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Building Silicon Dreams: An Adventure in Hardware Design - Rayanfam Blog&amp;url=https://rayanfam.com/topics/hardware-design-stack/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Building Silicon Dreams: An Adventure in Hardware Design - Rayanfam Blog&amp;u=https://rayanfam.com/topics/hardware-design-stack/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://rayanfam.com/topics/hardware-design-stack/&amp;text=Building Silicon Dreams: An Adventure in Hardware Design - Rayanfam Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/topics/hypervisor-from-scratch-part-1/">Hypervisor From Scratch - Part 1: Basic Concepts & Configure Testing Environment</a><li><a href="/topics/hypervisor-from-scratch-part-2/">Hypervisor From Scratch – Part 2: Entering VMX Operation</a><li><a href="/topics/hypervisor-from-scratch-part-5/">Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</a><li><a href="/topics/hypervisor-from-scratch-part-6/">Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</a><li><a href="/topics/hypervisor-from-scratch-part-7/">Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/topics/hyperdbg-one-thousand-and-one-nights/"><div class="card-body"> <em class="timeago small" data-ts="1655078400" > 2022-06-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>HyperDbg’s One Thousand and One Nights</h3><div class="text-muted small"><p> This post is a different one, in that, it is more of an overview, rather than a technical post. Here, we provide a high-level summary of HyperDbg Debugger, its principles, and perspective. Intro...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-8/"><div class="card-body"> <em class="timeago small" data-ts="1585008000" > 2020-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-7/"><div class="card-body"> <em class="timeago small" data-ts="1579478400" > 2020-01-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/topics/hyperdbg-one-thousand-and-one-nights/" class="btn btn-outline-primary" prompt="Older"><p>HyperDbg’s One Thousand and One Nights</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://rayanfam.com/topics/hardware-design-stack/'; this.page.identifier = '/topics/hardware-design-stack/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://rayanfam.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/rayanfam">Rayanfam Blog</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-P6M1BDG57Z"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-P6M1BDG57Z'); }); </script>
