<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Hypervisor From Scratch – Part 6: Virtualizing An Already Running System" /><meta name="author" content="Sina Karvandi" /><meta property="og:locale" content="en" /><meta name="description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><meta property="og:description" content="We write about Windows Internals, Hypervisors, Linux, and Networks." /><link rel="canonical" href="https://rayanfam.com/topics/hypervisor-from-scratch-part-6/" /><meta property="og:url" content="https://rayanfam.com/topics/hypervisor-from-scratch-part-6/" /><meta property="og:site_name" content="Rayanfam Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-02-25T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Hypervisor From Scratch – Part 6: Virtualizing An Already Running System" /><meta name="twitter:site" content="@Intel80x86" /><meta name="twitter:creator" content="@Sina Karvandi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sina Karvandi"},"dateModified":"2024-07-13T13:14:26+00:00","datePublished":"2019-02-25T00:00:00+00:00","description":"We write about Windows Internals, Hypervisors, Linux, and Networks.","headline":"Hypervisor From Scratch – Part 6: Virtualizing An Already Running System","mainEntityOfPage":{"@type":"WebPage","@id":"https://rayanfam.com/topics/hypervisor-from-scratch-part-6/"},"url":"https://rayanfam.com/topics/hypervisor-from-scratch-part-6/"}</script><title>Hypervisor From Scratch – Part 6: Virtualizing An Already Running System | Rayanfam Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Rayanfam Blog"><meta name="application-name" content="Rayanfam Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/images/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Rayanfam Blog</a></div><div class="site-subtitle font-italic">An aggressive out-of-order, superscalar blog...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tutorials/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TUTORIALS</span> </a><li class="nav-item"> <a href="/tools/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>TOOLS & SCRIPTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/rayanfam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Intel80x86" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sina','rayanfam.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/Intel80x86">Sina Karvandi</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1551052800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2019-02-25 </em> </span> <span> Updated <em class="timeago" data-ts="1720876466" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-07-13 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9124 words"> <em>50 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="../../assets/images/hypervisor-from-scratch-6-cover.png" alt="" data-proofer-ignore></p><p><strong>If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out <a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and reversing applications. A free and comprehensive tutorial on hypervisor-based reverse engineering is available at <a href="https://ost2.fyi/dbg3301">OpenSecurityTraining2’s website</a> (<em>preferred</em>) and <a href="https://www.youtube.com/playlist?list=PLUFkSN0XLZ-kF1f143wlw8ujlH2A45nZY">YouTube</a>, which demonstrates numerous practical examples on how to utilize hypervisors for reverse engineering.</strong></p><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hello and welcome to the 6th part of the tutorial <strong>Hypervisor From Scratch</strong>. In this part, we’ll learn how to virtualize an already running system using our custom-made hypervisor. Like other parts, this part depends on the previous parts, so make sure to read them first.</p><h2 id="table-of-contents"><span class="mr-2">Table of contents</span><a href="#table-of-contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><strong>Introduction</strong><li><strong>Table of contents</strong><li><strong>Overview</strong><li><strong>VMX 0-settings and 1-settings</strong><li><strong>VMX-Fixed Bits in CR0 and CR4</strong><li><strong>Capturing the State of the Current Machine</strong><ul><li>Configuring VMCS Fields<li>Changing IRQL on all Cores</ul><li><strong>Changing the User-Mode App</strong><ul><li>Getting a handle using CreateFile</ul><li><strong>Using VMX Monitoring Features</strong><ul><li>CR3-Target Controls<li>Handling guest CPUID execution<li>Prevent CPUID Timing Leakages<li>Instructions That Cause VM-exits Conditionally<li>Control Registers Modification Detection<li><strong>MSR Bitmaps</strong><ul><li>Handling MSRs Read<li>Handling MSRs Write</ul></ul><li><strong>Turning off VMX and Exit from Hypervisor</strong><li><strong>VM-Exit Handler</strong><li><strong>Let’s Test it!</strong><ul><li>Virtualizing all the cores<li>Changing CPUID using Hypervisor<li>Detecting MSR Read &amp; Write (MSR Bitmap)</ul><li><strong>Conclusion</strong><li><strong>References</strong></ul><h2 id="overview"><span class="mr-2">Overview</span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In the 6th part, we’ll see how we can virtualize our currently running system by configuring VMCS. We use monitoring features of VMX to detect the execution of important instructions like CPUID (and change the result of CPUID from user-mode and kernel-mode), detect modifications on different control registers, and describe VMX capabilities on different microarchitectures, talking about MSR Bitmaps and lots of other cool things.</p><p>Before starting, I should give my special thanks to my friend <a href="https://twitter.com/PetrBenes">Petr Benes</a> as he always solves my problems, explains to me patiently, and gives me ideas to implement a hypervisor from scratch.</p><p>The full source code of this tutorial is available on GitHub :</p><p>[<a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch">https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a>]</p><p>Note: Remember that hypervisors change over time because new features are added to the operating systems or new technologies are used. For example, updates to Meltdown &amp; Spectre have made a lot of changes to the hypervisors. So, if you want to use Hypervisor From Scratch in your projects, research, or whatever, you should use the <a href="https://github.com/HyperDbg/HyperDbg"><strong>HyperDbg</strong></a> drivers. <strong>HyperDbg</strong> is actively maintained, stable, and reliable, ensuring you avoid the errors and instability problems that can arise from using older parts of the tutorial series.</p><p>Please make sure to have your own lab to test your hypervisor. I tested my hypervisor on the 7th generation of Intel processors, so if you use an older processor, it might not support some features on your processor, and without a remote kernel debugger (not the local kernel debugger), you might see your system halting or BSODs without understanding the actual error.</p><h2 id="vmx-0-settings-and-1-settings"><span class="mr-2">VMX 0-settings and 1-settings</span><a href="#vmx-0-settings-and-1-settings" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In the previous parts, we implemented a function called <strong>AdjustControl</strong>. This is an essential part of each hypervisor as you might want to run your hypervisor on many different processors with different microarchitectures. We should be aware of our processor capabilities to avoid undefined behaviors and VM-Entry errors.</p><p>This works like this; first, an MSR is sent the below function, which indicates the VMCS control that needs to be modified. Then we check the corresponding MSR to understand the 1-settings and 0-settings of the control. At last, we remove the not supported bits, set those that are mandatory to be 1, and configure the control.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">ULONG</span>
<span class="nf">AdjustControls</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">Ctl</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Msr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MSR</span> <span class="n">MsrValue</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">MsrValue</span><span class="p">.</span><span class="n">Content</span> <span class="o">=</span> <span class="n">__readmsr</span><span class="p">(</span><span class="n">Msr</span><span class="p">);</span>
    <span class="n">Ctl</span> <span class="o">&amp;=</span> <span class="n">MsrValue</span><span class="p">.</span><span class="n">High</span><span class="p">;</span> <span class="cm">/* bit == 0 in high word ==&gt; must be zero */</span>
    <span class="n">Ctl</span> <span class="o">|=</span> <span class="n">MsrValue</span><span class="p">.</span><span class="n">Low</span><span class="p">;</span>  <span class="cm">/* bit == 1 in low word  ==&gt; must be one  */</span>
    <span class="k">return</span> <span class="n">Ctl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If you remember from the previous part, we used the above function in 4 situations.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_ACTIVATE_MSR_BITMAP</span> <span class="o">|</span> <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_CTL2_RDTSCP</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_INVPCID</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">));</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">PIN_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PINBASED_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">VM_EXIT_IA32E_MODE</span> <span class="cm">/* | VM_EXIT_ACK_INTR_ON_EXIT */</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_EXIT_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">));</span>
</pre></table></code></div></div><p>A brief look at <strong>APPENDIX A -VMX CAPABILITY REPORTING FACILITY</strong> shows the explanation about <strong>RESERVED CONTROLS AND DEFAULT SETTINGS</strong>. In Intel VMX, certain controls are reserved and must be set to a specific value (0 or 1) determined by the processor. The specific value to which a reserved control must be set is its <strong>default setting</strong>. These kinds of settings vary for each processor and microarchitecture, but in general, there are three types of classes :</p><ul><li><strong>Always-flexible</strong>: These have never been reserved.<li><strong>Default0</strong>: These are (or have been) reserved with a default setting of 0.<li><strong>Default1</strong>: They are (or have been) reserved with a default setting of 1.</ul><p>Now, There are separate capability MSRs for <strong>pin-based VM-execution controls</strong>, <strong>primary processor-based VM-execution controls</strong>, <strong>VM-Entry Controls</strong>, <strong>VM-Exit Controls</strong> and <strong>secondary processor-based VM-execution controls</strong>.</p><p>These MSRs are used to check the above controls:</p><ul><li>MSR_IA32_VMX_PROCBASED_CTLS<li>MSR_IA32_VMX_PROCBASED_CTLS2<li>MSR_IA32_VMX_EXIT_CTLS<li>MSR_IA32_VMX_ENTRY_CTLS<li>MSR_IA32_VMX_PINBASED_CTLS</ul><p>In all of the above MSRs, bits <strong>31:0</strong> indicate the allowed 0-settings of these controls. VM entry allows control X (bit X) to be 0 if bit X in the MSR is cleared to 0; if bit X in the MSR is set to 1, VM entry fails if control X is 0. Meanwhile, bits <strong>63:32</strong> indicate the allowed 1-settings of these controls. VM entry allows control X to be 1 if bit 32+X in the MSR is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry fails if control X is 1.</p><p>Although there are some exceptions, now, you should understand the purpose of <strong>AdjustControls</strong> as it first reads the MSR corresponding to the VM-execution control, then adjusts the 0-settings and 1-settings, and return the final result.</p><p>I recommend seeing the result of <strong>AdjustControls</strong> specifically for <strong>MSR_IA32_VMX_PROCBASED_CTLS</strong> and <strong>MSR_IA32_VMX_PROCBASED_CTLS2</strong> as you might unintentionally set some of the bits to 1 so, you should have a plan for handling some VM-Exits based on your specific processor.</p><p><img data-src="../../assets/images/anime-girl-bloom.jpg" alt="" data-proofer-ignore></p><h2 id="vmx-fixed-bits-in-cr0-and-cr4"><span class="mr-2">VMX-Fixed Bits in CR0 and CR4</span><a href="#vmx-fixed-bits-in-cr0-and-cr4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For CR0, <strong>IA32_VMX_CR0_FIXED0</strong> MSR (index 486H) and <strong>IA32_VMX_CR0_FIXED1</strong> MSR (index 487H) and for CR4 <strong>IA32_VMX_CR4_FIXED0</strong> MSR (index 488H) and <strong>IA32_VMX_CR4_FIXED1</strong> MSR (index 489H) indicate how bits in CR0 and CR4 may be set in VMX operation. If bit X is 1 in <strong>IA32_VMX_CRx_FIXED0</strong>, then that bit of CRx is fixed to 1 in VMX operation. Similarly, if bit X is 0 in <strong>IA32_VMX_CRx_FIXED1</strong>, then that bit of CRx is fixed to 0 in VMX operation. It is always the case that if bit X is 1 in <strong>IA32_VMX_CRx_FIXEDx</strong>, then that bit is also 1 in <strong>IA32_VMX_CRx_FIXED1</strong>.</p><h2 id="capturing-the-state-of-the-current-machine"><span class="mr-2">Capturing the State of the Current Machine</span><a href="#capturing-the-state-of-the-current-machine" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In the 5th part, we saw how to configure different VMCS fields and finally execute our instruction (HLT) under the guest context. This part is similar to the last part, with some minor changes in some VMCS attributes. Let’s review and see the differences.</p><p>The first thing you need to know is that you have to create different stacks for each core as we’re going to virtualize all the cores simultaneously. These stacks will be used whenever a VM-Exit occurs.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Allocate stack for the VM Exit Handler</span>
    <span class="c1">//</span>
    <span class="n">UINT64</span> <span class="n">VmmStackVa</span>                  <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span> <span class="n">VMM_STACK_SIZE</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
    <span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span> <span class="o">=</span> <span class="n">VmmStackVa</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Error in allocating VMM Stack</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span><span class="p">,</span> <span class="n">VMM_STACK_SIZE</span><span class="p">);</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMM Stack for logical processor %d : %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ProcessorID</span><span class="p">,</span> <span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">].</span><span class="n">VmmStack</span><span class="p">);</span>
</pre></table></code></div></div><p>As you can see from the above code, we use <code class="language-c highlighter-rouge"><span class="n">VmmStack</span></code> for each core separately (defined in the <code class="language-c highlighter-rouge"><span class="n">VIRTUAL_MACHINE_STATE</span></code> structure).</p><p>All the other things like clearing the VMCS state, loading VMCS, and executing VMLAUNCH are exactly the same as the previous part, so I don’t want to describe them again but see the function responsible for preparing our current core to be virtualized.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">VirtualizeCurrentSystem</span><span class="p">(</span><span class="kt">int</span> <span class="n">ProcessorID</span><span class="p">,</span> <span class="n">PEPTP</span> <span class="n">EPTP</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">GuestStack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">======================== Virtualizing Current System (Logical Core 0x%x) =============================</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ProcessorID</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// Clear the VMCS State</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ClearVmcsState</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">]))</span>
    <span class="p">{</span>
        <span class="k">goto</span> <span class="n">ErrorReturn</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">// Load VMCS (Set the Current VMCS)</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LoadVmcs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">]))</span>
    <span class="p">{</span>
        <span class="k">goto</span> <span class="n">ErrorReturn</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Setting up VMCS for current system.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">SetupVmcsAndVirtualizeMachine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessorID</span><span class="p">],</span> <span class="n">EPTP</span><span class="p">,</span> <span class="n">GuestStack</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// Change this hook (detect modification of MSRs using RDMSR &amp; WRMSR)</span>
    <span class="c1">//</span>
    <span class="c1">// DbgPrint("[*] Setting up MSR bitmaps.\n");</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Executing VMLAUNCH.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">__vmx_vmlaunch</span><span class="p">();</span>

    <span class="c1">//</span>
    <span class="c1">// if VMLAUNCH succeeds will never be here!</span>
    <span class="c1">//</span>
    <span class="n">ULONG64</span> <span class="n">ErrorCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ErrorCode</span><span class="p">);</span>
    <span class="n">__vmx_off</span><span class="p">();</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMLAUNCH Error : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="p">);</span>
    <span class="n">DbgBreakPoint</span><span class="p">();</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">===================================================================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="nl">ReturnWithoutError:</span>

    <span class="n">__vmx_off</span><span class="p">();</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMXOFF Executed Successfully!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Return With Error</span>
    <span class="c1">//</span>
<span class="nl">ErrorReturn:</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Fail to setup VMCS!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>From the above code, <code class="language-c highlighter-rouge"><span class="n">SetupVmcsAndVirtualizeMachine</span></code> is new, so let’s see what’s inside this function.</p><h3 id="configuring-vmcs-fields"><span class="mr-2">Configuring VMCS Fields</span><a href="#configuring-vmcs-fields" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>VMCS Fields are nothing new. We should configure these fields to manage the state of the virtualized core.</p><p>All the VMCS fields are the same as the last part, except for the configuration of VMCS control bits:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] MSR_IA32_VMX_PROCBASED_CTLS : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_ACTIVATE_MSR_BITMAP</span> <span class="o">|</span> <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">));</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] MSR_IA32_VMX_PROCBASED_CTLS2 : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_CTL2_RDTSCP</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_INVPCID</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">));</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_ACTIVATE_MSR_BITMAP</span> <span class="o">|</span> <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span> <span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">));</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">AdjustControls</span><span class="p">(</span><span class="n">CPU_BASED_CTL2_RDTSCP</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_INVPCID</span> <span class="o">|</span> <span class="n">CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">));</span>
</pre></table></code></div></div><p>As you can see, for the <strong>CPU_BASED_VM_EXEC_CONTROL</strong>, we set <strong>CPU_BASED_ACTIVATE_MSR_BITMAP</strong>; this way, we can enable the MSR BITMAP filter (described later in this part). Setting this field is somehow mandatory. As you might guess, Windows accesses lots of MSRs during a simple kernel execution, so if we don’t set this bit, then we’ll exit on each MSR access, and of course, our VMX Exit-Handler is called, hence clearing this bit to zero makes the system substantially slower.</p><p>For the <strong>SECONDARY_VM_EXEC_CONTROL</strong>, we use <strong>CPU_BASED_CTL2_RDTSCP</strong> to enable <strong>RDTSCP</strong>, <strong>CPU_BASED_CTL2_ENABLE_INVPCID</strong> to enable <strong>INVPCID</strong> and the <strong>CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS</strong> to enable <strong>XSAVE</strong> and <strong>XRSTORS</strong>.</p><p>It’s because I run the above code in my Windows 10 1809 and see that Windows uses <strong>INVPCID</strong> and <strong>XSAVE</strong> for its internal use (in the processors that support these features), so if you didn’t enable them before virtualizing the core, then it probably leads to error.</p><p>Note that <strong>RDTSCP</strong> reads the current value of the processor’s time-stamp counter into the <strong>EDX:EAX</strong> registers and also reads the value of the <strong>IA32_TSC_AUX</strong> MSR (address C0000103H) into the <strong>ECX</strong> register. This instruction adds ordering to RDTSC and makes performance measures more accurate than <strong>RDTSC</strong>.</p><p><strong>INVPCID</strong> invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on the process-context identifier (PCID), and <strong>XSAVE</strong> Performs a full or partial save of processor state components to the <strong>XSAVE</strong> area located at the memory address specified by the destination operand.</p><p>Please ensure to review the final value that you put on these fields as your processor might not support all these features, so you have to implement some additional functions or ignore some of them.</p><p>Nothing is left in this function except <strong>GuestStack</strong>, which is used as the <strong>GUEST_RSP</strong>. I’ll tell you what to put in this argument later.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">GuestStack</span><span class="p">);</span>     <span class="c1">//setup guest sp</span>
</pre></table></code></div></div><p>OK, now the problem is from where we can start our hypervisor. I mean, how to save the state of a particular core, then execute the <strong>VMLAUNCH</strong> instruction on it, and then continue the rest of the execution.</p><p>For this purpose, I’ve changed the <code class="language-c highlighter-rouge"><span class="n">DrvCreate</span></code> routine, so you must change <code class="language-c highlighter-rouge"><span class="n">CreateFile</span></code> from the user-mode application (I will discuss it later). In fact, <code class="language-c highlighter-rouge"><span class="n">DrvCreate</span></code> is the function responsible for putting all the cores in the VMX state. First, it queries the core’s count and then performs the necessary initialization for each core.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="n">NTSTATUS</span>
<span class="nf">DrvCreate</span><span class="p">(</span><span class="n">IN</span> <span class="n">PDEVICE_OBJECT</span> <span class="n">DeviceObject</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] DrvCreate Called !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// *** Start Virtualizing Current System ***</span>
    <span class="c1">//</span>

    <span class="c1">//</span>
    <span class="c1">// Initiating EPTP and VMX</span>
    <span class="c1">//</span>
    <span class="n">PEPTP</span> <span class="n">EPTP</span> <span class="o">=</span> <span class="n">InitializeEptp</span><span class="p">();</span>
    <span class="n">InitializeVmx</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">LogicalProcessorsCount</span> <span class="o">=</span> <span class="n">KeQueryActiveProcessorCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LogicalProcessorsCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Launching VM for Test (in the all logical processor)</span>
        <span class="kt">int</span> <span class="n">ProcessorID</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

        <span class="c1">// Allocating VMM Stack</span>
        <span class="n">AllocateVmmStack</span><span class="p">(</span><span class="n">ProcessorID</span><span class="p">);</span>

        <span class="c1">// Allocating MSR Bit</span>
        <span class="n">AllocateMsrBitmap</span><span class="p">(</span><span class="n">ProcessorID</span><span class="p">);</span>

        <span class="n">RunOnProcessor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">EPTP</span><span class="p">,</span> <span class="n">VmxSaveState</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">======================================================================================================</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ProcessorID</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span>      <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Our tiny driver is designed to be used in uni-core, two, three, and even all the cores. As you can see from the code below, it queries the logical processor count.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="n">LogicalProcessorsCount</span> <span class="o">=</span> <span class="n">KeQueryActiveProcessorCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>You can edit this line to virtualize a certain number of cores or just a specific core, but the above code virtualizes all the cores by default.</p><h3 id="changing-irql-on-all-cores"><span class="mr-2">Changing IRQL on all Cores</span><a href="#changing-irql-on-all-cores" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is a function called <code class="language-c highlighter-rouge"><span class="n">RunOnProcessor</span></code>. This function takes processor ID as its first parameter, the EPTP pointer (explained in the 4th part) as the second parameter, and a particular routine called <code class="language-c highlighter-rouge"><span class="n">VmxSaveState</span></code> as the third.</p><p><code class="language-c highlighter-rouge"><span class="n">RunOnProcessor</span></code> sets the processor affinity to a special core, then it raises the IRQL to Dispatch-Level so the Windows Scheduler can’t kick in to change the context; thus, it runs our routine, and when it returns from <code class="language-c highlighter-rouge"><span class="n">VmxSaveState</span></code>, the currently running core is virtualized so it can lower the IRQL to what it was before. Now Windows can continue its normal execution while it is under the hypervisor’s governance. IRQL stands for <strong>I</strong>nterrupt <strong>R</strong>e<strong>q</strong>uest <strong>L</strong>evel, a Windows-specific mechanism to manage interrupts or give priority by their level, so raising IRQL means your routine will execute with higher priority than normal Windows codes (<code class="language-c highlighter-rouge"><span class="n">PASSIVE</span><span class="err">\</span><span class="n">_LEVEL</span></code> &amp; <code class="language-c highlighter-rouge"><span class="n">APC_LEVEL</span></code>). For more information, you can visit <a href="https://blogs.msdn.microsoft.com/doronh/2010/02/02/what-is-irql/">here</a>.</p><p>The <code class="language-c highlighter-rouge"><span class="n">RunOnProcessor</span></code> code is shown below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">RunOnProcessor</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">ProcessorNumber</span><span class="p">,</span> <span class="n">PEPTP</span> <span class="n">EPTP</span><span class="p">,</span> <span class="n">PFUNC</span> <span class="n">Routine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">KIRQL</span> <span class="n">OldIrql</span><span class="p">;</span>

    <span class="n">KeSetSystemAffinityThread</span><span class="p">((</span><span class="n">KAFFINITY</span><span class="p">)(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ProcessorNumber</span><span class="p">));</span>

    <span class="n">OldIrql</span> <span class="o">=</span> <span class="n">KeRaiseIrqlToDpcLevel</span><span class="p">();</span>

    <span class="n">Routine</span><span class="p">(</span><span class="n">ProcessorNumber</span><span class="p">,</span> <span class="n">EPTP</span><span class="p">);</span>

    <span class="n">KeLowerIrql</span><span class="p">(</span><span class="n">OldIrql</span><span class="p">);</span>

    <span class="n">KeRevertToUserAffinityThread</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-c highlighter-rouge"><span class="n">VmxSaveState</span></code> has to save the state and call another function, <code class="language-c highlighter-rouge"><span class="n">VirtualizeCurrentSystem</span></code>.</p><p>We have to use this function in the assembly file (VMXState.asm) as all <code class="language-c highlighter-rouge"><span class="n">VmxSaveState</span></code> is implemented in assembly. For using a C function, in the assembly, we can write the function name and use the <strong>EXTERN</strong> keyword.</p><p>The following example shows how we can use the <code class="language-c highlighter-rouge"><span class="n">VirtualizeCurrentSystem</span></code> in the assembly file.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">EXTERN</span> <span class="n">VirtualizeCurrentSystem</span><span class="o">:</span><span class="n">PROC</span>
</pre></table></code></div></div><p>The <code class="language-c highlighter-rouge"><span class="n">VMXSaveState</span></code> is implemented like this (in assembly):</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="n">VmxSaveState</span> <span class="n">PROC</span>

	<span class="n">PUSH</span> <span class="n">RAX</span>
	<span class="n">PUSH</span> <span class="n">RCX</span>
	<span class="n">PUSH</span> <span class="n">RDX</span>
	<span class="n">PUSH</span> <span class="n">RBX</span>
	<span class="n">PUSH</span> <span class="n">RBP</span>
	<span class="n">PUSH</span> <span class="n">RSI</span>
	<span class="n">PUSH</span> <span class="n">RDI</span>
	<span class="n">PUSH</span> <span class="n">R8</span>
	<span class="n">PUSH</span> <span class="n">R9</span>
	<span class="n">PUSH</span> <span class="n">R10</span>
	<span class="n">PUSH</span> <span class="n">R11</span>
	<span class="n">PUSH</span> <span class="n">R12</span>
	<span class="n">PUSH</span> <span class="n">R13</span>
	<span class="n">PUSH</span> <span class="n">R14</span>
	<span class="n">PUSH</span> <span class="n">R15</span>

	<span class="n">SUB</span> <span class="n">RSP</span><span class="p">,</span> <span class="mi">28</span><span class="n">h</span>

	<span class="p">;</span> <span class="n">It</span> <span class="n">a</span> <span class="n">x64</span> <span class="n">FastCall</span> <span class="n">function</span> <span class="n">but</span> <span class="n">as</span> <span class="kt">long</span> <span class="n">as</span> <span class="n">the</span> <span class="n">definition</span> <span class="n">of</span> <span class="n">SaveState</span> <span class="n">is</span> <span class="n">the</span> <span class="n">same</span>
	<span class="p">;</span> <span class="n">as</span> <span class="n">VirtualizeCurrentSystem</span><span class="p">,</span> <span class="n">so</span> <span class="n">we</span> <span class="n">RCX</span> <span class="o">&amp;</span> <span class="n">RDX</span> <span class="n">both</span> <span class="n">have</span> <span class="n">a</span> <span class="n">correct</span> <span class="n">value</span>
	<span class="p">;</span> <span class="n">But</span> <span class="n">VirtualizeCurrentSystem</span> <span class="n">also</span> <span class="n">has</span> <span class="n">a</span> <span class="n">stack</span><span class="p">,</span> <span class="n">so</span> <span class="n">it</span><span class="err">'</span><span class="n">s</span> <span class="n">the</span> <span class="n">third</span> <span class="n">argument</span>
	<span class="p">;</span> <span class="n">and</span> <span class="n">according</span> <span class="n">to</span> <span class="n">FastCall</span><span class="p">,</span> <span class="n">it</span> <span class="n">should</span> <span class="n">be</span> <span class="n">in</span> <span class="n">R8</span>

	<span class="n">MOV</span> <span class="n">R8</span><span class="p">,</span> <span class="n">RSP</span>

	<span class="n">CALL</span> <span class="n">VirtualizeCurrentSystem</span>

	<span class="n">RET</span>

<span class="n">VmxSaveState</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>It first saves the state of all registers, subtracts the stack because of <strong>Shadow Space</strong> for fast call functions, and then puts <strong>RSP to **R8</strong> and calls the <code class="language-c highlighter-rouge"><span class="n">VirtualizeCurrentSystem</span></code>. RSP should be moved into the R8 (as I told you for <code class="language-c highlighter-rouge"><span class="n">GuestStack</span></code> ) because the x64 fastcall parameter should be passed in this order: <strong>RCX</strong>, <strong>RDX</strong>, <strong>R8</strong>, <strong>R9</strong> + <strong>Stack</strong>. This means that our third argument to this function is current <strong>RSP</strong>, and this value will be used as <code class="language-c highlighter-rouge"><span class="n">GUEST_RSP</span></code> in the VMCS.</p><p>If the above function runs without error, we should never reach to <code class="language-c highlighter-rouge"><span class="n">ret</span></code> instruction as the state will later continue in another function called <code class="language-c highlighter-rouge"><span class="n">VmxRestoreState</span></code>.</p><p>As we can see in the <code class="language-c highlighter-rouge"><span class="n">VirtualizeCurrentSystem</span></code>, which eventually calls <code class="language-c highlighter-rouge"><span class="n">SetupVmcsAndVirtualizeMachine</span></code>, the <strong>GUEST_RIP</strong> is pointing to <code class="language-c highlighter-rouge"><span class="n">VmxRestoreState</span></code>, so the first routine that executes in the current core is <code class="language-c highlighter-rouge"><span class="n">VmxRestoreState</span></code>.</p><p>This function is defined like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">VmxRestoreState</span> <span class="n">PROC</span>

	<span class="n">ADD</span> <span class="n">RSP</span><span class="p">,</span> <span class="mi">28</span><span class="n">h</span>
	<span class="n">POP</span> <span class="n">R15</span>
	<span class="n">POP</span> <span class="n">R14</span>
	<span class="n">POP</span> <span class="n">R13</span>
	<span class="n">POP</span> <span class="n">R12</span>
	<span class="n">POP</span> <span class="n">R11</span>
	<span class="n">POP</span> <span class="n">R10</span>
	<span class="n">POP</span> <span class="n">R9</span>
	<span class="n">POP</span> <span class="n">R8</span>
	<span class="n">POP</span> <span class="n">RDI</span>
	<span class="n">POP</span> <span class="n">RSI</span>
	<span class="n">POP</span> <span class="n">RBP</span>
	<span class="n">POP</span> <span class="n">RBX</span>
	<span class="n">POP</span> <span class="n">RDX</span>
	<span class="n">POP</span> <span class="n">RCX</span>
	<span class="n">POP</span> <span class="n">RAX</span>
	
	<span class="n">RET</span>
	
<span class="n">VmxRestoreState</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>In the above function, first, we remove the <strong>Shadow Space</strong> and restore the registers state.</p><p>When we return to <code class="language-c highlighter-rouge"><span class="n">RunOnProcessor</span></code>, it’s time to lower the IRQL.</p><p>This function will be called many times (based on our logical cores count), and eventually, all of our cores are under VMX operation, and now we are in the <strong>VMX non-root operation</strong>.</p><h2 id="changing-the-user-mode-app"><span class="mr-2">Changing the User-Mode App</span><a href="#changing-the-user-mode-app" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Based on the above assumptions, we have to make some trivial changes in our user-mode application so after loading the driver, it can be used to notify kernel-mode code to start and finally end of loading the hypervisor.</p><h3 id="getting-a-handle-using-createfile"><span class="mr-2">Getting a handle using CreateFile</span><a href="#getting-a-handle-using-createfile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>After some checks for the vendor and presence of hypervisor, now we have to call <code class="language-c highlighter-rouge"><span class="n">DrvCreate</span></code> from the kernel-mode, and it’s through the <code class="language-c highlighter-rouge"><span class="n">CreateFile</span></code> user-mode function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>    <span class="n">HANDLE</span> <span class="n">Handle</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">MyHypervisorDevice"</span><span class="p">,</span>
                               <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
                               <span class="n">FILE_SHARE_READ</span> <span class="o">|</span>
                                   <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span>
                               <span class="nb">NULL</span><span class="p">,</span> <span class="c1">/// lpSecurityAttirbutes</span>
                               <span class="n">OPEN_EXISTING</span><span class="p">,</span>
                               <span class="n">FILE_ATTRIBUTE_NORMAL</span> <span class="o">|</span>
                                   <span class="n">FILE_FLAG_OVERLAPPED</span><span class="p">,</span>
                               <span class="nb">NULL</span><span class="p">);</span> <span class="c1">/// lpTemplateFile</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Handle</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DWORD</span> <span class="n">ErrNum</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[*] CreateFile failed : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ErrNum</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><code class="language-c highlighter-rouge"><span class="n">CreateFile</span></code> gives us a handle that can be used in our future functions to interact with our driver. Still, whenever we close the application or call <code class="language-c highlighter-rouge"><span class="n">CloseHandle</span></code> in the user-mode, the <code class="language-c highlighter-rouge"><span class="n">DrvClose</span></code> is automatically called in the kernel. <code class="language-c highlighter-rouge"><span class="n">DrvClose</span></code> turns off the hypervisor and restores the state to what it was before (not virtualized).</p><h2 id="using-vmx-monitoring-features"><span class="mr-2">Using VMX Monitoring Features</span><a href="#using-vmx-monitoring-features" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>After configuring all the above fields, it’s time to use the monitoring features of the VMX. We’ll see how these features are unique in the case of security applications or reverse engineering tasks. As an extra resource, you can use <a href="https://hyperdbg.com">HyperDbg Debugger</a>. HyperDbg is a hypervisor-based debugger that allows us to use most of these VT-x features in our debugging journey.</p><h3 id="cr3-target-controls"><span class="mr-2">CR3-Target Controls</span><a href="#cr3-target-controls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The VM-execution control fields include a set of 4 CR3-target values and a CR3-target count. If you remember the VMCS fields that I presented before in the <code class="language-c highlighter-rouge"><span class="n">SetupVmcsAndVirtualizeMachine</span></code>, you can see the following lines :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>Intel defines CR3-Target controls like this :</p><p>An execution of MOV to CR3 in VMX non-root operation does not cause a VM exit if its source operand matches one of these values. If the CR3-target count is n, only the first n CR3-target values are considered.</p><p>The implementation of using this feature is like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">SetTargetControls</span><span class="p">(</span><span class="n">UINT64</span> <span class="n">CR3</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">Index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Index starts from 0 , not 1</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Not supported for more than 4 , at least for now :(</span>
        <span class="c1">//</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">UINT64</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">CR3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_Cr3TargetCount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// Invalid command as g_Cr3TargetCount cannot be less than zero</span>
            <span class="c1">// s</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">g_Cr3TargetCount</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE0</span><span class="p">,</span> <span class="n">CR3</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE1</span><span class="p">,</span> <span class="n">CR3</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE2</span><span class="p">,</span> <span class="n">CR3</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE3</span><span class="p">,</span> <span class="n">CR3</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">g_Cr3TargetCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR3_TARGET_COUNT</span><span class="p">,</span> <span class="n">g_Cr3TargetCount</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>I don’t have any good example of how this control might be helpful in a regular Windows as there are thousands of CR3 changes for each process. Still, one of my friends told me that it’s used in some special cases in scientific projects to improve the overall performance.</p><h3 id="handling-guest-cpuid-execution"><span class="mr-2">Handling guest CPUID execution</span><a href="#handling-guest-cpuid-execution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>CPUID</strong> is an instruction that unconditionally causes VM-exit. As you know, <strong>CPUID</strong> is used because it allows the software to discover details of the processor. It is also used for flushing the pipeline for processors that don’t support instructions like <strong>RDTSCP</strong>, so they can use <strong>CPUID + RDTSC</strong> and use <strong>CPUID</strong> as a barrier.</p><p>Whenever any software in any privilege level executes a <strong>CPUID</strong> instruction, our vm-exit handler is called, and now we can decide whatever we want to show to the software. For example, previously, I published an article “<a href="https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/">Defeating malware’s Anti-VM techniques (CPUID-Based Instructions)</a>”. This article describes how to configure VMware Workstation in a way that changes the <strong>CPUID</strong> instruction results so that the malware with an anti-VM technique can’t understand that they’re executing in a virtualized environment. VMware Workstation (and other virtual environments) perform the same mechanism for handling <strong>CPUID</strong>. In the following example, I just passed the state of registers (state of registers before the VM-exits) to the <code class="language-c highlighter-rouge"><span class="n">HandleCPUID</span></code>. This function decides whether the requested <strong>CPUID</strong> should have a modified result or just execute passthrough the original results.</p><p>The default behavior for handling every VM-Exit (caused by execution of <strong>CPUID</strong> in VMX non-root) is to get the original result by using <code class="language-c highlighter-rouge"><span class="n">_cpuidex</span></code>, which is the intrinsic function for <strong>CPUID</strong>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">__cpuidex</span><span class="p">(</span><span class="n">CpuInfo</span><span class="p">,</span> <span class="p">(</span><span class="n">INT32</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">,</span> <span class="p">(</span><span class="n">INT32</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">);</span>
</pre></table></code></div></div><p>As you can see, VMX non-root by itself isn’t able to execute a <strong>CPUID</strong>, and we can execute <strong>CPUID</strong> in VMX root-mode and give back the results to the VMX non-root mode.</p><p>We need to check if <strong>RAX</strong> (<strong>CPUID</strong> Index) was <strong>1</strong> or not. It’s because there is an indicator bit that shows whether the current machine is running under a hypervisor or not. Like many other virtual machines, we set the present hypervisor bit (the constant used in this example is like hyper-v’s bit <code class="language-c highlighter-rouge"><span class="n">HYPERV_HYPERVISOR_PRESENT_BIT</span></code>) to show that we’re running under a hypervisor.</p><p>There is a second check about the hypervisor provider. We set it to ‘<strong>HVFS</strong>’ to show that our hypervisor is [<strong>H</strong>]yper[<strong>V</strong>]isor [<strong>F</strong>]rom [<strong>S</strong>]cratch.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Check if this was CPUID 1h, which is the features request</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Set the Hypervisor Present-bit in RCX, which Intel and AMD have both</span>
        <span class="c1">// reserved for this indication</span>
        <span class="c1">//</span>
        <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">HYPERV_HYPERVISOR_PRESENT_BIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="n">HYPERV_CPUID_INTERFACE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Return our interface identifier</span>
        <span class="c1">//</span>
        <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">HVFS</span><span class="err">'</span><span class="p">;</span> <span class="c1">// [H]yper[V]isor [F]rom [S]cratch</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>We can easily add more checks to the above code and customize our CPUID filter, for instance, changing our computer vendor string, etc.</p><p>Finally, we put them into registers so that the guest has a proper result every time our routine is executed.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// Copy the values from the logical processor registers into the VP GPRs</span>
    <span class="c1">//</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rbx</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rdx</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</pre></table></code></div></div><p>Putting all the above codes together, we have the following function:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">HandleCPUID</span><span class="p">(</span><span class="n">PGUEST_REGS</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT32</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">Mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Check for the magic CPUID sequence, and check that it is coming from</span>
    <span class="c1">// Ring 0. Technically we could also check the RIP and see if this falls</span>
    <span class="c1">// in the expected function, but we may want to allow a separate "unload"</span>
    <span class="c1">// driver or code at some point</span>
    <span class="c1">//</span>

    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Mode</span><span class="p">);</span>
    <span class="n">Mode</span> <span class="o">=</span> <span class="n">Mode</span> <span class="o">&amp;</span> <span class="n">RPL_MASK</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="mh">0x41414141</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">==</span> <span class="mh">0x42424242</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Mode</span> <span class="o">==</span> <span class="n">DPL_SYSTEM</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span> <span class="c1">// Indicates we have to turn off VMX</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">// Otherwise, issue the CPUID to the logical processor based on the indexes</span>
    <span class="c1">// on the VP's GPRs</span>
    <span class="c1">//</span>
    <span class="n">__cpuidex</span><span class="p">(</span><span class="n">CpuInfo</span><span class="p">,</span> <span class="p">(</span><span class="n">INT32</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">,</span> <span class="p">(</span><span class="n">INT32</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// Check if this was CPUID 1h, which is the features request</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Set the Hypervisor Present-bit in RCX, which Intel and AMD have both</span>
        <span class="c1">// reserved for this indication</span>
        <span class="c1">//</span>
        <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">HYPERV_HYPERVISOR_PRESENT_BIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="n">HYPERV_CPUID_INTERFACE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Return our interface identifier</span>
        <span class="c1">//</span>
        <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">HVFS</span><span class="err">'</span><span class="p">;</span> <span class="c1">// [H]yper[V]isor [F]rom [S]cratch</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">// Copy the values from the logical processor registers into the VP GPRs</span>
    <span class="c1">//</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rbx</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">rdx</span> <span class="o">=</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// Indicates we don't have to turn off VMX</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s somehow like instruction level hooking for <strong>CPUID</strong>. Also, you can have the same handling functions for many other important instructions by configuring the primary and secondary processor-based controls. Later we describe some of these instructions.</p><h3 id="prevent-cpuid-timing-leakages"><span class="mr-2">Prevent CPUID Timing Leakages</span><a href="#prevent-cpuid-timing-leakages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>As an extra explanation about the hypervisor, <strong>CPUID</strong> is one of the ways that cause user-mode or kernel-mode software to detect the presence of hypervisor by using delta timing side-channel attacks. It originates from the fact that this instruction leads to an unconditional VM-exit which, in the case of a hypervisor, it takes much longer to execute in contrast with a non-virtualized machine.</p><p>The description of these attacks is out of this article’s scope, but in case you’re interested, you can read a detailed explanation about these attacks in <a href="https://research.hyperdbg.org/debugger/transparency.html">this paper</a>.</p><h3 id="instructions-that-cause-vm-exits-conditionally"><span class="mr-2">Instructions That Cause VM-exits Conditionally</span><a href="#instructions-that-cause-vm-exits-conditionally" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here is a list of instructions that cause VM-exits in VMX non-root operation depending on the setting of the VM-execution controls. - CLTS - ENCLS - HLT - IN, INS/INSB/INSW/INSD, OUT, OUTS/OUTSB/OUTSW/OUTSD. - INVLPG - INVPCID - LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, STR - LMSW - MONITOR - MOV from CR3/CR8, MOV to CR0/1/3/4/8 - MOV DR - MWAIT - PAUSE - RDMSR, WRMSR - RDPMC - RDRAND, RDSEED - RDTSC, RDTSCP - RSM - VMREAD, VMWRITE - WBINVD - XRSTORS, XSAVES</p><h3 id="control-registers-modification-detection"><span class="mr-2">Control Registers Modification Detection</span><a href="#control-registers-modification-detection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Detecting and handling Control Registers’ (CR) modifications is one of the great monitoring features provided by hypervisors.</p><p>Imagine if someone exploits the Windows Kernel (or any other OSs) and wants to unset one of the control register bits (let’s say Write Protected or<strong>SMEP</strong>); then the hypervisor detects this modification and prevents further execution.</p><blockquote><p>Note that SMEP stands for Supervisor Mode Execution Protection. <strong>CR4.SMEP</strong> allows pages to be protected from supervisor-mode instruction fetches. If <strong>CR4.SMEP = 1</strong>, software operating in supervisor mode cannot fetch instructions from linear addresses that are accessible in user mode, and <strong>WP</strong> stands for <strong>W</strong>rite <strong>P</strong>rotect. <strong>CR0.WP</strong> allows pages to be protected from supervisor-mode writes. If <strong>CR0.WP = 0</strong>, supervisor-mode write accesses are allowed to linear addresses with read-only access rights; if <strong>CR0.WP = 1</strong>, they are not (User-mode write accesses are never allowed to linear addresses with read-only access rights, regardless of the value of CR0.WP).</p></blockquote><p>Now it’s time to implement our functions.</p><p>First, let’s read the <strong>GUEST_CRs</strong> and <code class="language-c highlighter-rouge"><span class="n">EXIT_QUALIFICATION</span></code> of the VMCS.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitQualification</span><span class="p">);</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR0</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestCR0</span><span class="p">);</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR3</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">GuestCR3</span><span class="p">);</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">GuestCR4</span><span class="p">);</span>
</pre></table></code></div></div><p>As you can see, the following picture shows how we can interpret Exit Qualifications.</p><p><img data-src="../../assets/images/control-register-access.png" alt="" data-proofer-ignore></p><p>Note that <code class="language-c highlighter-rouge"><span class="n">EXIT_QUALIFICATION</span></code> is somehow a general VMCS field that, in some situations like VM-exits caused by Invalid VMCS Layout, Control Register Modifications, I/O Bitmaps, and other events, gives additional information about the reason for the VM-exit.</p><p>As you can see from the above picture, let’s make some variables to describe the situation based on <code class="language-c highlighter-rouge"><span class="n">EXIT_QUALIFICATION</span></code>.</p><p>Whenever a VM-Exit occurs caused by instructions like <code class="language-c highlighter-rouge"><span class="n">MOV</span> <span class="n">CRx</span><span class="p">,</span> <span class="n">REG</span></code>, we have to manually modify the <strong>CRx</strong> of guest VMCS from VMX-root mode. The following code shows how to change the <strong>GUEST_CRx</strong> field of VMCS using VMWRITE.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre>     <span class="k">case</span> <span class="n">TYPE_MOV_TO_CR</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>

            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">RegPtr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">)));</span>

            <span class="c1">//</span>
            <span class="c1">// In the case of using EPT, the context of EPT/VPID should be</span>
            <span class="c1">// invalidated</span>
            <span class="c1">//</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Unsupported register %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
</pre></table></code></div></div><p>Otherwise, we have to read the <strong>CRx</strong> from our guest VMCS (not host Control Register as it might be different), then put it into the corresponding registers (in registers that we saved when the VM-exit handler called), then continue with <strong>VMRESUME</strong>. This way, the guest thinks as if it executed the <code class="language-c highlighter-rouge"><span class="n">MOV</span> <span class="n">reg</span><span class="p">,</span> <span class="n">CRx</span></code> successfully.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">TYPE_MOV_FROM_CR</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Unsupported register %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>Putting it all together, we have a function like this :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">HandleControlRegisterAccess</span><span class="p">(</span><span class="n">PGUEST_REGS</span> <span class="n">GuestState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">ExitQualification</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitQualification</span><span class="p">);</span>

    <span class="n">PMOV_CR_QUALIFICATION</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMOV_CR_QUALIFICATION</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ExitQualification</span><span class="p">;</span>

    <span class="n">PULONG64</span> <span class="n">RegPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GuestState</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">Register</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Because its RSP and as we didn't save RSP correctly (because of pushes)</span>
    <span class="c1">// so we have to make it points to the GUEST_RSP</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">Register</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">INT64</span> <span class="n">RSP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RSP</span><span class="p">);</span>
        <span class="o">*</span><span class="n">RegPtr</span> <span class="o">=</span> <span class="n">RSP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">AccessType</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">TYPE_MOV_TO_CR</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>

            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">RegPtr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">)));</span>

            <span class="c1">//</span>
            <span class="c1">// In the case of using EPT, the context of EPT/VPID should be</span>
            <span class="c1">// invalidated</span>
            <span class="c1">//</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="o">*</span><span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Unsupported register %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">TYPE_MOV_FROM_CR</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="n">RegPtr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Unsupported register %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">ControlRegister</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] Unsupported operation %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">Fields</span><span class="p">.</span><span class="n">AccessType</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The reason why implementing functions like <strong>HandleControlRegisterAccess</strong> is necessary is because some processors have 1-settings of some processor-based VM-execution controls like CR3-Load Exiting &amp; CR3-Store Existing, so we have to manage these kinds of VM-exits by ourselves, but if our processor can continue without these settings, it’s strongly recommended to reduce the amounts of VM-exits and avoid configuring the settings that lead to these kinds of VM-exits because modern OSs access control registers a lot; thus, it has a significant performance penalty.</p><h3 id="msr-bitmaps"><span class="mr-2">MSR Bitmaps</span><a href="#msr-bitmaps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Everything here is based on whether you set the 28th bit of Primary Processor Based controls or not.</p><p>On processors that support the 1-setting of the “<strong>use MSR bitmaps</strong>” VM-execution control, the VM-execution control fields include the 64-bit physical address of four contiguous MSR bitmaps, which are each 1-KByte in size.</p><p>The definition of MSR bitmap is pretty clear in Intel SDM, so I just copied them from the original manual. After reading them, we’ll start to implement them and put them into our hypervisor.</p><ul><li><p>Read bitmap for low MSRs (located at the MSR-bitmap address). This contains one bit for each MSR address in the range 00000000H to 00001FFFH. The bit determines whether the execution of RDMSR applied to that MSR causes a VM-exit.</p><li><p>Read bitmap for high MSRs (located at the MSR-bitmap address plus 1024). This contains one bit for each MSR address in the range C0000000H toC0001FFFH. The bit determines whether the execution of RDMSR applied to that MSR causes a VM-exit.</p><li><p>Write bitmap for low MSRs (located at the MSR-bitmap address plus 2048). This contains one bit for each MSR address in the range 00000000H to 00001FFFH. The bit determines whether the execution of WRMSR applied to that MSR causes a VM-exit.</p><li><p>Write bitmap for high MSRs (located at the MSR-bitmap address plus 3072). This contains one bit for each MSR address in the range C0000000H toC0001FFFH. The bit determines whether the execution of WRMSR applied to that MSR causes a VM-exit.</p></ul><p>OK, let’s bring the above sentences into the codes. First, we’ll write our handler for MSR VM-exits.</p><h4 id="handling-msrs-read"><span class="mr-2">Handling MSRs Read**</span><a href="#handling-msrs-read" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>In our passthrough hypervisor, if any of the <strong>RDMSR</strong> or <strong>WRMSR</strong> caused a VM-exit, we have to manually execute <strong>RDMSR</strong> or <strong>WRMSR</strong> and set the results into the registers. Because of this, we have a function to manage our RDMSRs like :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">HandleMSRRead</span><span class="p">(</span><span class="n">PGUEST_REGS</span> <span class="n">GuestRegs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MSR</span> <span class="n">msr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">//</span>
    <span class="c1">// RDMSR. The RDMSR instruction causes a VM exit if any of the following are true:</span>
    <span class="c1">//</span>
    <span class="c1">// The "use MSR bitmaps" VM-execution control is 0.</span>
    <span class="c1">// The value of ECX is not in the ranges 00000000H - 00001FFFH and C0000000H - C0001FFFH</span>
    <span class="c1">// The value of ECX is in the range 00000000H - 00001FFFH and bit n in read bitmap for low MSRs is 1,</span>
    <span class="c1">//   where n is the value of ECX.</span>
    <span class="c1">// The value of ECX is in the range C0000000H - C0001FFFH and bit n in read bitmap for high MSRs is 1,</span>
    <span class="c1">//   where n is the value of ECX &amp; 00001FFFH.</span>
    <span class="c1">//</span>

    <span class="k">if</span> <span class="p">(((</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="mh">0x00001FFF</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="mh">0xC0000000</span> <span class="o">&lt;=</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="mh">0xC0001FFF</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">msr</span><span class="p">.</span><span class="n">Content</span> <span class="o">=</span> <span class="n">MSRRead</span><span class="p">((</span><span class="n">ULONG</span><span class="p">)</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">msr</span><span class="p">.</span><span class="n">Content</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">msr</span><span class="p">.</span><span class="n">Low</span><span class="p">;</span>
    <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rdx</span> <span class="o">=</span> <span class="n">msr</span><span class="p">.</span><span class="n">High</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You can see that it just checks for the sanity of MSR and then executes the <strong>RDMSR</strong> and ultimately put the results into <strong>RAX</strong> and <strong>RDX</strong> (because a non-virtualized <strong>RDMSR</strong> does the same thing).</p><h4 id="handling-msrs-writes"><span class="mr-2">Handling MSRs Writes</span><a href="#handling-msrs-writes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>There is another function for handling <strong>WRMSR</strong> VM-exits :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">HandleMSRWrite</span><span class="p">(</span><span class="n">PGUEST_REGS</span> <span class="n">GuestRegs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MSR</span> <span class="n">msr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">//</span>
    <span class="c1">// Check for the sanity of MSR</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="mh">0x00001FFF</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="mh">0xC0000000</span> <span class="o">&lt;=</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&lt;=</span> <span class="mh">0xC0001FFF</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">msr</span><span class="p">.</span><span class="n">Low</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">;</span>
        <span class="n">msr</span><span class="p">.</span><span class="n">High</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">;</span>
        <span class="n">MSRWrite</span><span class="p">((</span><span class="n">ULONG</span><span class="p">)</span><span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">,</span> <span class="n">msr</span><span class="p">.</span><span class="n">Content</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The functionality of the function is simple. Still, one thing that is worth experimenting by yourself is to avoid setting <code class="language-c highlighter-rouge"><span class="n">CPU_BASED_ACTIVATE_MSR_BITMAP</span></code> in <code class="language-c highlighter-rouge"><span class="n">CPU_BASED_VM_EXEC_CONTROL</span></code>, you’ll see that all of the MSR reads and modifications will cause a VM-exit with these reasons :</p><ul><li>EXIT_REASON_MSR_READ<li>EXIT_REASON_MSR_WRITE</ul><p>This time, we have to pass everything to the above functions and log these VM-exits, so you can see what are MSRs that Windows use while running in the hypervisor. As I told you above, Windows executes a vast amount of MSR instructions, so it can make your system much slower than you can bear it.</p><p>OK, let’s get back to our MSR Bitmap. We need two functions to Set bits of our MSR Bitmap.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">SetBit</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">Bit</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">Set</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PAGED_CODE</span><span class="p">();</span>

    <span class="n">UINT64</span> <span class="n">Byte</span> <span class="o">=</span> <span class="n">Bit</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">UINT64</span> <span class="n">Temp</span> <span class="o">=</span> <span class="n">Bit</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">UINT64</span> <span class="n">N</span>    <span class="o">=</span> <span class="mi">7</span> <span class="o">-</span> <span class="n">Temp</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="o">*</span> <span class="n">Addr2</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Set</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Addr2</span><span class="p">[</span><span class="n">Byte</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Addr2</span><span class="p">[</span><span class="n">Byte</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The other function is for retrieving a particular bit.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">GetBit</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">UINT64</span> <span class="n">Bit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UINT64</span> <span class="n">Byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Byte</span>         <span class="o">=</span> <span class="n">Bit</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">K</span>            <span class="o">=</span> <span class="mi">7</span> <span class="o">-</span> <span class="n">Bit</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="o">*</span> <span class="n">Addr2</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Addr2</span><span class="p">[</span><span class="n">Byte</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">K</span><span class="p">);</span>
<span class="p">}</span>

</pre></table></code></div></div><p>Now it’s time to gather everything in one function based on the above descriptions about MSR Bitmaps. The following function first checks for the sanity of MSR; then, it changes the MSR Bitmap of the target logical core (this is why we hold both the Physical Address and the Virtual Address of MSR Bitmap, the physical address for VMCS fields, and the virtual address to ease the modification and future deallocation). If it’s a read (<strong>RDMSR</strong>) for low MSRs, then set the corresponding bit in MSR Bitmap Virtual Address, if it’s a write (<strong>WRMSR</strong>) for the low MSRs, then modify the MSR Bitmap + 2048 (as noted in Intel manual) and exact the same thing for high MSRs (between <em>0xC0000000</em> and <em>0xC0001FFF</em>) but don’t forget the subtraction (<em>0xC0000000</em>) because <em>0xC000nnnn</em> is not a valid bit.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">SetMsrBitmap</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">Msr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ProcessID</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">ReadDetection</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">WriteDetection</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadDetection</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">WriteDetection</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Invalid Command</span>
        <span class="c1">//</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Msr</span> <span class="o">&lt;=</span> <span class="mh">0x00001FFF</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ReadDetection</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SetBit</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessID</span><span class="p">].</span><span class="n">MsrBitmap</span><span class="p">,</span> <span class="n">Msr</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">WriteDetection</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SetBit</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessID</span><span class="p">].</span><span class="n">MsrBitmap</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">Msr</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="mh">0xC0000000</span> <span class="o">&lt;=</span> <span class="n">Msr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Msr</span> <span class="o">&lt;=</span> <span class="mh">0xC0001FFF</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ReadDetection</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SetBit</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessID</span><span class="p">].</span><span class="n">MsrBitmap</span> <span class="o">+</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">Msr</span> <span class="o">-</span> <span class="mh">0xC0000000</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">WriteDetection</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SetBit</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">ProcessID</span><span class="p">].</span><span class="n">MsrBitmap</span> <span class="o">+</span> <span class="mi">3072</span><span class="p">,</span> <span class="n">Msr</span> <span class="o">-</span> <span class="mh">0xC0000000</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Just one more thing to remember, only the above MSR ranges are currently valid in Intel processors, so even any other RDMSRs and WRMSRs cause a VM-exit. Still, the sanity check here is mandatory as the guest might send invalid MSRs and cause the whole system to crash (in VMX root-mode). In the future parts, when we learn about the event injection, we’ll simulate the physical machine’s behavior by injecting events to the guest in the case when the guest attempted to access an invalid MSR.</p><h2 id="turning-off-vmx-and-exit-from-hypervisor"><span class="mr-2">Turning off VMX and Exit from Hypervisor</span><a href="#turning-off-vmx-and-exit-from-hypervisor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>It’s time to turn off our hypervisor and restore the processor state to what it was before running the hypervisor.</p><p>Like how we enter hypervisor (<strong>VMLAUNCH</strong>), we have to combine our C functions with Assembly routines to save the state, execute <strong>VMXOFF</strong>, free all of our previously allocated pools, and finally restore the state.</p><p>The <strong>VMXOFF</strong> part of this routine should be executed in the VMX root-mode. You can’t just execute <code class="language-c highlighter-rouge"><span class="n">__vmx_vmxoff</span></code> in one of your driver functions and expect it turns off the hypervisor as Windows and all its drivers are currently running in VMX non-root, so executing any of the VMX instructions is like a VM-exit with one of the following reasons.</p><ul><li>EXIT_REASON_VMCLEAR<li>EXIT_REASON_VMPTRLD<li>EXIT_REASON_VMPTRST<li>EXIT_REASON_VMREAD<li>EXIT_REASON_VMRESUME<li>EXIT_REASON_VMWRITE<li>EXIT_REASON_VMXOFF<li>EXIT_REASON_VMXON<li>EXIT_REASON_VMLAUNCH</ul><p>For turning off the hypervisor, it’s better to use one of our IRP Major functions. In our case, we used <code class="language-c highlighter-rouge"><span class="n">DrvClose</span></code> as it always gets notified whenever a handle to our device is closed. If you remember from the above, we create a handle from our device using <code class="language-c highlighter-rouge"><span class="n">CreateFile</span></code> (<code class="language-c highlighter-rouge"><span class="n">DrvCreate</span></code>), and now it’s time to close our handle using <code class="language-c highlighter-rouge"><span class="n">DrvClose</span></code>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">NTSTATUS</span>
<span class="nf">DrvClose</span><span class="p">(</span><span class="n">IN</span> <span class="n">PDEVICE_OBJECT</span> <span class="n">DeviceObject</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PIRP</span> <span class="n">Irp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] DrvClose Called !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// executing VMXOFF (From CPUID) on every logical processor</span>
    <span class="n">TerminateVmx</span><span class="p">();</span>

    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span>      <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Nothing special about the above function; only the <code class="language-c highlighter-rouge"><span class="n">TerminateVmx</span></code> is added.</p><p>This function is similar to the routine of executing <strong>VMLAUNCH</strong>, except it runs <strong>VMXOFF</strong> instead.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">TerminateVmx</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[*] Terminating VMX...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">LogicalProcessorsCount</span> <span class="o">=</span> <span class="n">KeQueryActiveProcessorCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LogicalProcessorsCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s"> + Terminating VMX on processor %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">RunOnProcessorForTerminateVMX</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="c1">//</span>
        <span class="c1">// Free the destination memory</span>
        <span class="c1">//</span>
        <span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">PhysicalToVirtualAddress</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmxonRegion</span><span class="p">));</span>
        <span class="n">MmFreeContiguousMemory</span><span class="p">(</span><span class="n">PhysicalToVirtualAddress</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmcsRegion</span><span class="p">));</span>
        <span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VmmStack</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
        <span class="n">ExFreePoolWithTag</span><span class="p">(</span><span class="n">g_GuestState</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">MsrBitmap</span><span class="p">,</span> <span class="n">POOLTAG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMX Operation turned off successfully. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, it executes <code class="language-c highlighter-rouge"><span class="n">RunOnProcessorForTerminateVMX</span></code> on all the running logical cores. It then frees the allocated buffers for <code class="language-c highlighter-rouge"><span class="n">VmxonRegion</span></code>, <code class="language-c highlighter-rouge"><span class="n">VmcsRegion</span></code>, <code class="language-c highlighter-rouge"><span class="n">VmmStack</span></code>, and <code class="language-c highlighter-rouge"><span class="n">MsrBitmap</span></code> using <code class="language-c highlighter-rouge"><span class="n">MmFreeContiguousMemory</span></code> and, of course, converts physicals to virtuals whenever needed.</p><p>Note that you have to modify this function if you virtualized a portion of cores (not all).</p><p>In <code class="language-c highlighter-rouge"><span class="n">RunOnProcessorForTerminateVMX</span></code>, we must tell theVMX Root Operation about turning off the hypervisor. As I told you, it’s because we can’t execute any VMX instructions in the regular driver routines, and it’s pretty clear that VMX Root Operation can prevent us from this operation if there isn’t any mechanism for handling this situation or we’re not privileged enough to unload the hypervisor.</p><p>There are several ways to tell our VMX Root Operation about <strong>VMXOFF</strong>, but in our case, we’ll use <strong>CPUID</strong>.</p><p>By now, you definitely know that executing <strong>CPUID</strong> will cause VM-exit. Now in our <strong>CPUID</strong> exit handler routine, we manage that whenever a <strong>CPUID</strong> with <code class="language-c highlighter-rouge"><span class="n">RAX</span> <span class="o">=</span> <span class="mh">0x41414141</span></code> and <code class="language-c highlighter-rouge"><span class="n">RCX</span> <span class="o">=</span> <span class="mh">0x42424242</span></code> is executed, then we have to return <strong>true</strong>, and it shows the caller that the hypervisor needs to be off.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="k">if</span> <span class="p">((</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">==</span> <span class="mh">0x41414141</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">==</span> <span class="mh">0x42424242</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Mode</span> <span class="o">==</span> <span class="n">DPL_SYSTEM</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span> <span class="c1">// Indicates we have to turn off VMX</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>There is also another check for <strong>DPL</strong> to make sure that <strong>CPUID</strong> with <code class="language-c highlighter-rouge"><span class="n">RAX</span> <span class="o">=</span> <span class="mh">0x41414141</span></code> and <code class="language-c highlighter-rouge"><span class="n">RCX</span> <span class="o">=</span> <span class="mh">0x42424242</span></code> is only executed in the system privilege level (kernel-mode). Hence, none of the user-mode applications are able to unload our hypervisor.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="n">ULONG</span> <span class="n">Mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Mode</span><span class="p">);</span>
    <span class="n">Mode</span> <span class="o">=</span> <span class="n">Mode</span> <span class="o">&amp;</span> <span class="n">RPL_MASK</span><span class="p">;</span>
</pre></table></code></div></div><p>Now our <code class="language-c highlighter-rouge"><span class="n">RunOnProcessorForTerminateVMX</span></code> executes <strong>CPUID</strong> with adjusted values into registers on all cores separately.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="n">BOOLEAN</span>
<span class="nf">RunOnProcessorForTerminateVMX</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">ProcessorNumber</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">KIRQL</span> <span class="n">OldIrql</span><span class="p">;</span>
    <span class="n">INT32</span> <span class="n">CpuInfo</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">KeSetSystemAffinityThread</span><span class="p">((</span><span class="n">KAFFINITY</span><span class="p">)(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ProcessorNumber</span><span class="p">));</span>

    <span class="n">OldIrql</span> <span class="o">=</span> <span class="n">KeRaiseIrqlToDpcLevel</span><span class="p">();</span>

    <span class="c1">//</span>
    <span class="c1">// Our routine is VMXOFF</span>
    <span class="c1">//</span>
    <span class="n">__cpuidex</span><span class="p">(</span><span class="n">CpuInfo</span><span class="p">,</span> <span class="mh">0x41414141</span><span class="p">,</span> <span class="mh">0x42424242</span><span class="p">);</span>

    <span class="n">KeLowerIrql</span><span class="p">(</span><span class="n">OldIrql</span><span class="p">);</span>

    <span class="n">KeRevertToUserAffinityThread</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the <code class="language-c highlighter-rouge"><span class="n">EXIT_REASON_CPUID</span></code> handler, we know that if the handler returns true, then we have to turn it off, so we should think about some other things. For example, Windows expects to later continue from <code class="language-c highlighter-rouge"><span class="n">GUEST_RIP</span></code> and needs its previous <code class="language-c highlighter-rouge"><span class="n">GUEST_RSP</span></code> whenever the VM-exit handler returns; thus, we have to save them in some locations and use them later to restore the Windows state.</p><p>Also, we have to increase <strong>GUEST_RIP</strong> because we want to restore the state after the CPUID.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">EXIT_REASON_CPUID</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">Status</span> <span class="o">=</span> <span class="n">HandleCPUID</span><span class="p">(</span><span class="n">GuestRegs</span><span class="p">);</span> <span class="c1">// Detect whether we have to turn off VMX or Not</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// We have to save GUEST_RIP &amp; GUEST_RSP somewhere to restore them directly</span>

            <span class="n">ULONG</span> <span class="n">ExitInstructionLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">g_GuestRIP</span>                  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">g_GuestRSP</span>                  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_GuestRIP</span><span class="p">);</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_GuestRSP</span><span class="p">);</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitInstructionLength</span><span class="p">);</span>

            <span class="n">g_GuestRIP</span> <span class="o">+=</span> <span class="n">ExitInstructionLength</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>From the 5th part, you probably know <code class="language-c highlighter-rouge"><span class="n">MainVmexitHandler</span></code> is called from <code class="language-c highlighter-rouge"><span class="n">VmexitHandler</span></code> (Assembly function from <strong>VMExitHandler.asm</strong>)</p><p>Let’s see it in detail.</p><p>First, we have to extern some previously defined variables.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">EXTERN</span> <span class="n">g_GuestRIP</span><span class="o">:</span><span class="n">QWORD</span>
<span class="n">EXTERN</span> <span class="n">g_GuestRSP</span><span class="o">:</span><span class="n">QWORD</span>
</pre></table></code></div></div><p>Now our <code class="language-c highlighter-rouge"><span class="n">VmexitHandler</span></code> works like this, whenever a VM-exit occurs, the target logical core executes <code class="language-c highlighter-rouge"><span class="n">VmexitHandler</span></code> as it’s defined in <code class="language-c highlighter-rouge"><span class="n">HOST_RIP</span></code>, and our <strong>RSP</strong> is set to <code class="language-c highlighter-rouge"><span class="n">HOST_RSP</span></code>, then we have to save all the registers. It means we must create a structure that allows us to read and modify registers in a C-like structure.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GUEST_REGS</span>
<span class="p">{</span>
    <span class="n">ULONG64</span> <span class="n">rax</span><span class="p">;</span> <span class="c1">// 0x00         // NOT VALID FOR SVM</span>
    <span class="n">ULONG64</span> <span class="n">rcx</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">rdx</span><span class="p">;</span> <span class="c1">// 0x10</span>
    <span class="n">ULONG64</span> <span class="n">rbx</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">rsp</span><span class="p">;</span> <span class="c1">// 0x20         // rsp is not stored here on SVM</span>
    <span class="n">ULONG64</span> <span class="n">rbp</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">rsi</span><span class="p">;</span> <span class="c1">// 0x30</span>
    <span class="n">ULONG64</span> <span class="n">rdi</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">r8</span><span class="p">;</span> <span class="c1">// 0x40</span>
    <span class="n">ULONG64</span> <span class="n">r9</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">r10</span><span class="p">;</span> <span class="c1">// 0x50</span>
    <span class="n">ULONG64</span> <span class="n">r11</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">r12</span><span class="p">;</span> <span class="c1">// 0x60</span>
    <span class="n">ULONG64</span> <span class="n">r13</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">r14</span><span class="p">;</span> <span class="c1">// 0x70</span>
    <span class="n">ULONG64</span> <span class="n">r15</span><span class="p">;</span>
<span class="p">}</span> <span class="n">GUEST_REGS</span><span class="p">,</span> <span class="o">*</span><span class="n">PGUEST_REGS</span><span class="p">;</span>
</pre></table></code></div></div><p>Just push all the registers in the <code class="language-c highlighter-rouge"><span class="n">GUEST_REGS</span></code> structure order and push the <strong>RSP</strong> as the first argument to <code class="language-c highlighter-rouge"><span class="n">MainVmexitHandler</span></code> (Fastcall <strong>RCX</strong>), then some subtraction for Shadow Space.</p><p>You can see the <code class="language-c highlighter-rouge"><span class="n">VmexitHandler</span></code> here:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="n">VmexitHandler</span> <span class="n">PROC</span>

    <span class="n">PUSH</span> <span class="n">R15</span>
    <span class="n">PUSH</span> <span class="n">R14</span>
    <span class="n">PUSH</span> <span class="n">R13</span>
    <span class="n">PUSH</span> <span class="n">R12</span>
    <span class="n">PUSH</span> <span class="n">R11</span>
    <span class="n">PUSH</span> <span class="n">R10</span>
    <span class="n">PUSH</span> <span class="n">R9</span>
    <span class="n">PUSH</span> <span class="n">R8</span>        
    <span class="n">PUSH</span> <span class="n">RDI</span>
    <span class="n">PUSH</span> <span class="n">RSI</span>
    <span class="n">PUSH</span> <span class="n">RBP</span>
    <span class="n">PUSH</span> <span class="n">RBP</span>	<span class="p">;</span> <span class="n">RSP</span>
    <span class="n">PUSH</span> <span class="n">RBX</span>
    <span class="n">PUSH</span> <span class="n">RDX</span>
    <span class="n">PUSH</span> <span class="n">RCX</span>
    <span class="n">PUSH</span> <span class="n">RAX</span>	


	<span class="n">MOV</span> <span class="n">RCX</span><span class="p">,</span> <span class="n">RSP</span>		<span class="p">;</span> <span class="n">Fast</span> <span class="n">CALL</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">PGUEST_REGS</span>
	<span class="n">SUB</span>	<span class="n">RSP</span><span class="p">,</span> <span class="mi">28</span><span class="n">h</span>		<span class="p">;</span> <span class="n">Free</span> <span class="n">some</span> <span class="n">space</span> <span class="k">for</span> <span class="n">Shadow</span> <span class="n">Section</span>

	<span class="n">CALL</span>	<span class="n">MainVmexitHandler</span>

	<span class="n">ADD</span>	<span class="n">RSP</span><span class="p">,</span> <span class="mi">28</span><span class="n">h</span>		<span class="p">;</span> <span class="n">Restore</span> <span class="n">the</span> <span class="n">state</span>

	<span class="p">;</span> <span class="n">Check</span> <span class="n">whether</span> <span class="n">we</span> <span class="n">have</span> <span class="n">to</span> <span class="n">turn</span> <span class="n">off</span> <span class="n">VMX</span> <span class="n">or</span> <span class="n">Not</span> <span class="p">(</span><span class="n">the</span> <span class="n">result</span> <span class="n">is</span> <span class="n">in</span> <span class="n">RAX</span><span class="p">)</span>

	<span class="n">CMP</span>	<span class="n">AL</span><span class="p">,</span> <span class="mi">1</span>
	<span class="n">JE</span>		<span class="n">VmxoffHandler</span>

	<span class="p">;</span> <span class="n">Restore</span> <span class="n">the</span> <span class="n">state</span>
	<span class="n">POP</span> <span class="n">RAX</span>
    <span class="n">POP</span> <span class="n">RCX</span>
    <span class="n">POP</span> <span class="n">RDX</span>
    <span class="n">POP</span> <span class="n">RBX</span>
    <span class="n">POP</span> <span class="n">RBP</span>		<span class="p">;</span> <span class="n">RSP</span>
    <span class="n">POP</span> <span class="n">RBP</span>
    <span class="n">POP</span> <span class="n">RSI</span>
    <span class="n">POP</span> <span class="n">RDI</span> 
    <span class="n">POP</span> <span class="n">R8</span>
    <span class="n">POP</span> <span class="n">R9</span>
    <span class="n">POP</span> <span class="n">R10</span>
    <span class="n">POP</span> <span class="n">R11</span>
    <span class="n">POP</span> <span class="n">R12</span>
    <span class="n">POP</span> <span class="n">R13</span>
    <span class="n">POP</span> <span class="n">R14</span>
    <span class="n">POP</span> <span class="n">R15</span>

	<span class="n">SUB</span> <span class="n">RSP</span><span class="p">,</span> <span class="mo">0100</span><span class="n">h</span> <span class="p">;</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">error</span> <span class="n">in</span> <span class="n">future</span> <span class="n">functions</span>

	<span class="n">JMP</span> <span class="n">VmResumeInstruction</span>
	

<span class="n">VmexitHandler</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>From the above code, when we return from the <code class="language-c highlighter-rouge"><span class="n">MainVmexitHandler</span></code>, we have to check whether the return result of <code class="language-c highlighter-rouge"><span class="n">MainVmexitHandler</span></code> (in <strong>RAX</strong>) tells us to turn off the hypervisor or just continue.</p><p>If it needs to be continued, restore the registers state and jump to our <code class="language-c highlighter-rouge"><span class="n">VmResumeInstruction</span></code> function.</p><p><code class="language-c highlighter-rouge"><span class="n">VmResumeInstruction</span></code> executes <code class="language-c highlighter-rouge"><span class="n">__vmx_vmresume</span></code> and the processor sets the <strong>RIP</strong> register to <code class="language-c highlighter-rouge"><span class="n">GUEST_RIP</span></code>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">VOID</span>
<span class="nf">VmResumeInstruction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ULONG64</span> <span class="n">ErrorCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">__vmx_vmresume</span><span class="p">();</span>

    <span class="c1">//</span>
    <span class="c1">// if VMRESUME succeeds will never be here!</span>
    <span class="c1">//</span>
    <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ErrorCode</span><span class="p">);</span>
    <span class="n">__vmx_off</span><span class="p">();</span>
    <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] VMRESUME Error : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// It's such a bad error because we don't where to go</span>
    <span class="c1">// prefer to break</span>
    <span class="c1">//</span>
    <span class="n">DbgBreakPoint</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But what if it needs to be turned off?</p><p>Then based on the <strong>AL</strong> register, it jumps to another function called <code class="language-c highlighter-rouge"><span class="n">VmxoffHandler</span></code>. This function executes the <strong>VMXOFF</strong> instruction, turns off the hypervisor (in the current logical core), and then restores the registers to their previous state as we saved them in <code class="language-c highlighter-rouge"><span class="n">VmexitHandler</span></code>.</p><p>The only thing we have to do here is changing the stack pointer to <code class="language-c highlighter-rouge"><span class="n">GUEST_RSP</span></code> (We saved them in <code class="language-c highlighter-rouge"><span class="n">g_GuestRSP</span></code>) and jump to the <code class="language-c highlighter-rouge"><span class="n">GUEST_RIP</span></code> (saved in <code class="language-c highlighter-rouge"><span class="n">g_GuestRIP</span></code>).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">VmxoffHandler</span> <span class="n">PROC</span>

	<span class="p">;</span> <span class="n">Turn</span> <span class="n">VMXOFF</span>
	<span class="n">VMXOFF</span>

	<span class="p">;</span> <span class="n">Restore</span> <span class="n">the</span> <span class="n">state</span>

	<span class="n">POP</span> <span class="n">RAX</span>
    <span class="n">POP</span> <span class="n">RCX</span>
    <span class="n">POP</span> <span class="n">RDX</span>
    <span class="n">POP</span> <span class="n">RBX</span>
    <span class="n">POP</span> <span class="n">RBP</span>		<span class="p">;</span> <span class="n">RSP</span>
    <span class="n">POP</span> <span class="n">RBP</span>
    <span class="n">POP</span> <span class="n">RSI</span>
    <span class="n">POP</span> <span class="n">RDI</span> 
    <span class="n">POP</span> <span class="n">R8</span>
    <span class="n">POP</span> <span class="n">R9</span>
    <span class="n">POP</span> <span class="n">R10</span>
    <span class="n">POP</span> <span class="n">R11</span>
    <span class="n">POP</span> <span class="n">R12</span>
    <span class="n">POP</span> <span class="n">R13</span>
    <span class="n">POP</span> <span class="n">R14</span>
    <span class="n">POP</span> <span class="n">R15</span>

	<span class="p">;</span> <span class="n">Set</span> <span class="n">guest</span> <span class="n">RIP</span> <span class="n">and</span> <span class="n">RSP</span>

	<span class="n">MOV</span>		<span class="n">RSP</span><span class="p">,</span> <span class="n">g_GuestRSP</span>

	<span class="n">JMP</span>		<span class="n">g_GuestRIP</span>

<span class="n">VmxoffHandler</span> <span class="n">ENDP</span>
</pre></table></code></div></div><p>Now everything is done, we executed our normal Windows (driver) routine; I mean, start the execution after the last <strong>CPUID</strong> that was executed from <code class="language-c highlighter-rouge"><span class="n">RunOnProcessorForTerminateVMX</span></code> but now we’re not in VMX operation.</p><h2 id="vm-exit-handler"><span class="mr-2">VM-Exit Handler</span><a href="#vm-exit-handler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Putting all the above codes together, now we have to manage different kinds of VM-exits, so we need to modify our previously explained (in the 5th part) VM-exit handler; if you forget about it, please review the 5th part (<strong>VM-Exit Handler</strong>), it’s exactly the same but with different actions for various exit reasons.</p><p>The first thing we need to manage is to detect every VMX instructions that are executed in VMX non-root operation; it can be done using the following code :</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>    <span class="c1">//</span>
    <span class="c1">// 25.1.2  Instructions That Cause VM Exits Unconditionally</span>
    <span class="c1">// The following instructions cause VM exits when they are executed in VMX non-root operation: CPUID, GETSEC,</span>
    <span class="c1">// INVD, and XSETBV. This is also true of instructions introduced with VMX, which include: INVEPT, INVVPID,</span>
    <span class="c1">// VMCALL, VMCLEAR, VMLAUNCH, VMPTRLD, VMPTRST, VMRESUME, VMXOFF, and VMXON.</span>
    <span class="c1">//</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMCLEAR</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMPTRLD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMPTRST</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMREAD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMRESUME</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMWRITE</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMXOFF</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMXON</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">EXIT_REASON_VMLAUNCH</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="c1">// DbgBreakPoint();</span>

        <span class="cm">/*	DbgPrint("\n [*] Target guest tries to execute VM Instruction ,"
                "it probably causes a fatal error or system halt as the system might"
                " think it has VMX feature enabled while it's not available due to our use of hypervisor.\n");
                */</span>

        <span class="n">ULONG</span> <span class="n">RFLAGS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RFLAGS</span><span class="p">);</span>
        <span class="n">__vmx_vmwrite</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">RFLAGS</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span> <span class="c1">// cf=1 indicate vm instructions fail</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>As I told you in <strong>DbgPrint</strong>, executing these kinds of VMX instructions will eventually cause BSOD because there might be some checks for the presence of a hypervisor before our hypervisor comes. Hence, the routine that executes these instructions (of course, it’s from the kernel) probably thinks it can execute these instructions. If it didn’t manage them well (which is common), you’ll see BSOD. Thus, you have to discover the cause of invoking these kinds of instructions and manually disable them.</p><p>If you configured any CPU-based controls or your processor support 1-settings of any of the CR Access Exit controls, you could manage them using the following VM-exit.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">EXIT_REASON_CR_ACCESS</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">HandleControlRegisterAccess</span><span class="p">(</span><span class="n">GuestRegs</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>The same thing is true for MSRs accesses. If we didn’t set any MSR Bit, every <strong>RDMSR</strong> and <strong>WRMSR</strong> cause to exit, or if we set any bits in <code class="language-c highlighter-rouge"><span class="n">MsrBitmap</span></code>, then we have to manage them using the following function for <strong>RDMSR</strong>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">EXIT_REASON_MSR_READ</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">ULONG</span> <span class="n">ECX</span> <span class="o">=</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>

        <span class="c1">// DbgPrint("[*] RDMSR (based on bitmap) : 0x%llx\n", ECX);</span>
        <span class="n">HandleMSRRead</span><span class="p">(</span><span class="n">GuestRegs</span><span class="p">);</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>And this code for managing <strong>WRMSR</strong>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">EXIT_REASON_MSR_WRITE</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">ULONG</span> <span class="n">ECX</span> <span class="o">=</span> <span class="n">GuestRegs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] WRMSR (based on bitmap) : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ECX</span><span class="p">);</span>
        <span class="n">HandleMSRWrite</span><span class="p">(</span><span class="n">GuestRegs</span><span class="p">);</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>And if you want to detect I/O instruction execution, then:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">EXIT_REASON_IO_INSTRUCTION</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">UINT64</span> <span class="n">RIP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RIP</span><span class="p">);</span>

        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[*] RIP executed IO instruction : 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">RIP</span><span class="p">);</span>
        <span class="n">DbgBreakPoint</span><span class="p">();</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>Don’t forget to set adequate CPU-based control fields if you want to use the above functionalities.</p><p>The last thing that is important for us is the <strong>CPUID</strong> Handler. It calls <code class="language-c highlighter-rouge"><span class="n">HandleCPUID</span></code> (described above), and if the result is <em>true</em>, then it saves the <code class="language-c highlighter-rouge"><span class="n">GUEST_RSP</span></code> and <code class="language-c highlighter-rouge"><span class="n">GUEST_RIP</span></code> so that these values can be used to restore the state after <strong>VMXOFF</strong> is executed in the target core.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">EXIT_REASON_CPUID</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">Status</span> <span class="o">=</span> <span class="n">HandleCPUID</span><span class="p">(</span><span class="n">GuestRegs</span><span class="p">);</span> <span class="c1">// Detect whether we have to turn off VMX or Not</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// We have to save GUEST_RIP &amp; GUEST_RSP somewhere to restore them directly</span>

            <span class="n">ULONG</span> <span class="n">ExitInstructionLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">g_GuestRIP</span>                  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">g_GuestRSP</span>                  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_GuestRIP</span><span class="p">);</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_GuestRSP</span><span class="p">);</span>
            <span class="n">__vmx_vmread</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExitInstructionLength</span><span class="p">);</span>

            <span class="n">g_GuestRIP</span> <span class="o">+=</span> <span class="n">ExitInstructionLength</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><h2 id="lets-test-it"><span class="mr-2">Let’s Test it!</span><a href="#lets-test-it" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now it’s time to test our hypervisor.</p><h3 id="virtualizing-all-the-cores"><span class="mr-2">Virtualizing all the cores</span><a href="#virtualizing-all-the-cores" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>First, we have to load our driver.</p><p><img data-src="../../assets/images/running-HVFS-1.png" alt="" data-proofer-ignore></p><p>Then our <code class="language-c highlighter-rouge"><span class="n">DriverEntry</span></code> is called, so we have to run our user-mode application to virtualize all the cores.</p><p><img data-src="../../assets/images/running-HVFS-2.png" alt="" data-proofer-ignore></p><p>You can see that if you press any key or close this window, it’ll call <code class="language-c highlighter-rouge"><span class="n">DrvClose</span></code> and restores the state (<strong>VMXOFF</strong>).</p><p><img data-src="../../assets/images/running-HVFS-3.png" alt="" data-proofer-ignore></p><p>The above picture shows the driver logs. At this point, all the cores are now under the hypervisor.</p><h3 id="changing-cpuid-using-hypervisor"><span class="mr-2">Changing CPUID using Hypervisor</span><a href="#changing-cpuid-using-hypervisor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Now let’s test the presence of the hypervisor. For this case, I used Immunity Debugger to execute <strong>CPUID</strong> with custom <strong>EAX</strong>. You can use any other debugger or any custom application.</p><p><img data-src="../../assets/images/cpuid-handle-1.png" alt="" data-proofer-ignore></p><p>We have to manually set the <strong>EAX</strong> to <strong>0x40000001</strong> or the <code class="language-c highlighter-rouge"><span class="n">HYPERV_CPUID_INTERFACE</span></code> and then execute <strong>CPUID</strong>.</p><p><img data-src="../../assets/images/cpuid-handle-2.png" alt="" data-proofer-ignore></p><p>As you can see, <strong>HVFS</strong> (0x48564653) is on <strong>EAX</strong>, so we successfully hooked the <strong>CPUID</strong> execution using our hypervisor.</p><p><img data-src="../../assets/images/cpuid-handle-3.png" alt="" data-proofer-ignore></p><p>The above picture shows the <code class="language-c highlighter-rouge"><span class="n">HYPERV_CPUID_INTERFACE</span></code> without the hypervisor.</p><p>At last, we have to close the user-mode app window, so it executes <strong>VMXOFF</strong> on all cores. Let’s test the above example again.</p><p><img data-src="../../assets/images/cpuid-handle-4.png" alt="" data-proofer-ignore></p><p>You can see that the actual results have appeared as we’re no longer under the hypervisor.</p><h3 id="detecting-msr-read--write-msr-bitmap"><span class="mr-2">Detecting MSR Read &amp; Write (MSR Bitmap)</span><a href="#detecting-msr-read--write-msr-bitmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>In order to test MSR Bitmaps, I create a local kernel debugger (using WinDbg). In WinDbg, we can execute <code class="language-c highlighter-rouge"><span class="n">rdmsr</span></code> and <code class="language-c highlighter-rouge"><span class="n">wrmsr</span></code> commands to read and write into MSRs. It’s exactly like executing <strong>RDMSR</strong> and <strong>WRMSR</strong> using a system driver.</p><p>In the <code class="language-c highlighter-rouge"><span class="n">VirtualizeCurrentSystem</span></code> function, the following line is added.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">SetMSRBitmap</span><span class="p">(</span><span class="mh">0xc0000082</span><span class="p">,</span> <span class="n">ProcessorID</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
</pre></table></code></div></div><p><img data-src="../../assets/images/MSR-bitmap-1.png" alt="" data-proofer-ignore></p><p>In WinDbg Local Debugger, we executed the above commands, and in the remote debugger, we can see the result as follows,</p><p><img data-src="../../assets/images/MSR-bitmap-2.png" alt="" data-proofer-ignore></p><p>As you can see, the execution of <strong>RDMSR</strong> is detected. Our hypervisor is working perfectly!</p><p>That’s it all, folks.</p><p><img data-src="../../assets/images/anime-girl-reading-book.jpg" alt="" data-proofer-ignore></p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In this part, we saw how we could virtualize an already running system by configuring the VMCS fields separately for each logical core. Then we used our hypervisor to change the result of the <strong>CPUID</strong> instruction and monitor every access to control registers or MSRs. After this part, our hypervisor is almost ready to be used for a practical project. The future part is about using the Extended Page Table (as described previously in the 4th part). I believe most of the exciting works in hypervisor can be performed using EPT because it has a special logging mechanism, e.g., page read/write access detection and many other cool things you’ll see in the next parts.</p><p>See you in the next part.</p><p>The seventh part is also available <a href="https://rayanfam.com/topics/hypervisor-from-scratch-part-7/">here</a>.</p><h2 id="references"><span class="mr-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>[1] Vol 3C – Chapter 24 – (VIRTUAL MACHINE CONTROL STRUCTURES (<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a>)</p><p>[2] cpu-internals (<a href="https://github.com/LordNoteworthy/cpu-internals">https://github.com/LordNoteworthy/cpu-internals</a>)</p><p>[3] RDTSCP — Read Time-Stamp Counter and Processor ID (<a href="https://www.felixcloutier.com/x86/rdtscp">https://www.felixcloutier.com/x86/rdtscp</a>)</p><p>[4] INVPCID — Invalidate Process-Context Identifier (<a href="https://www.felixcloutier.com/x86/invpcid">https://www.felixcloutier.com/x86/invpcid</a>)</p><p>[5] XSAVE — Save Processor Extended States (<a href="https://www.felixcloutier.com/x86/xsave">https://www.felixcloutier.com/x86/xsave</a>)</p><p>[6] XRSTORS — Restore Processor Extended States Supervisor (<a href="https://www.felixcloutier.com/x86/xrstors">https://www.felixcloutier.com/x86/xrstors</a>)</p><p>[7] What is IRQL ? (<a href="https://blogs.msdn.microsoft.com/doronh/2010/02/02/what-is-irql/">https://blogs.msdn.microsoft.com/doronh/2010/02/02/what-is-irql/</a>)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cpu/'>cpu</a>, <a href='/categories/hypervisor/'>hypervisor</a>, <a href='/categories/tutorials/'>tutorials</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hypervisor/" class="post-tag no-text-decoration" >hypervisor</a> <a href="/tags/control-registers-modification/" class="post-tag no-text-decoration" >control-registers-modification</a> <a href="/tags/cpuid-modification/" class="post-tag no-text-decoration" >cpuid-modification</a> <a href="/tags/hypervisor-from-scratch/" class="post-tag no-text-decoration" >hypervisor-from-scratch</a> <a href="/tags/hypervisor-logging/" class="post-tag no-text-decoration" >hypervisor-logging</a> <a href="/tags/msr-modification-detection/" class="post-tag no-text-decoration" >msr-modification-detection</a> <a href="/tags/virtualize-all-logical-cores/" class="post-tag no-text-decoration" >virtualize-all-logical-cores</a> <a href="/tags/virtualize-current-system/" class="post-tag no-text-decoration" >virtualize-current-system</a> <a href="/tags/vmfunc/" class="post-tag no-text-decoration" >vmfunc</a> <a href="/tags/vmx-0-settings-and-1-settings/" class="post-tag no-text-decoration" >vmx-0-settings-and-1-settings</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Hypervisor From Scratch – Part 6: Virtualizing An Already Running System - Rayanfam Blog&amp;url=https://rayanfam.com/topics/hypervisor-from-scratch-part-6/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Hypervisor From Scratch – Part 6: Virtualizing An Already Running System - Rayanfam Blog&amp;u=https://rayanfam.com/topics/hypervisor-from-scratch-part-6/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://rayanfam.com/topics/hypervisor-from-scratch-part-6/&amp;text=Hypervisor From Scratch – Part 6: Virtualizing An Already Running System - Rayanfam Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/topics/hypervisor-from-scratch-part-1/">Hypervisor From Scratch - Part 1: Basic Concepts & Configure Testing Environment</a><li><a href="/topics/hypervisor-from-scratch-part-2/">Hypervisor From Scratch – Part 2: Entering VMX Operation</a><li><a href="/topics/hypervisor-from-scratch-part-5/">Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</a><li><a href="/topics/hypervisor-from-scratch-part-6/">Hypervisor From Scratch – Part 6: Virtualizing An Already Running System</a><li><a href="/topics/hypervisor-from-scratch-part-7/">Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/topics/hypervisor-from-scratch-part-8/"><div class="card-body"> <em class="timeago small" data-ts="1585008000" > 2020-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor!</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-5/"><div class="card-body"> <em class="timeago small" data-ts="1544918400" > 2018-12-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 5: Setting up VMCS & Running Guest Code</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div><div class="card"> <a href="/topics/hypervisor-from-scratch-part-7/"><div class="card-body"> <em class="timeago small" data-ts="1579478400" > 2020-01-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hypervisor From Scratch – Part 7: Using EPT & Page-Level Monitoring Features</h3><div class="text-muted small"><p> If you’re looking to use a hypervisor for analysis and reverse engineering tasks, check out HyperDbg Debugger. It’s a hypervisor-based debugger designed specifically for analyzing, fuzzing, and r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/topics/packetscript-lua-kernel/" class="btn btn-outline-primary" prompt="Older"><p>PacketScript overview: A Lua scripting engine for in-kernel packet processing</p></a> <a href="/topics/finding-the-real-access-rights-needed-by-handles/" class="btn btn-outline-primary" prompt="Newer"><p>Why you should not always trust MSDN: Finding Real Access Rights Needed By Handles</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://rayanfam.com/topics/hypervisor-from-scratch-part-6/'; this.page.identifier = '/topics/hypervisor-from-scratch-part-6/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://rayanfam.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/rayanfam">Rayanfam Blog</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hypervisor/">hypervisor</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/debian/">debian</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/cisco/">cisco</a> <a class="post-tag" href="/tags/invept/">invept</a> <a class="post-tag" href="/tags/ios/">ios</a> <a class="post-tag" href="/tags/vmcs/">vmcs</a> <a class="post-tag" href="/tags/active-directory/">active-directory</a> <a class="post-tag" href="/tags/cache/">cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-P6M1BDG57Z"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-P6M1BDG57Z'); }); </script>
